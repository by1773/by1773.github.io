<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于docker、nginx配置通过http/https访问服务</title>
    <url>/2020/04/22/nginx-http-https/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="基于docker、nginx配置通过http-https访问服务"><a href="#基于docker、nginx配置通过http-https访问服务" class="headerlink" title="基于docker、nginx配置通过http/https访问服务"></a>基于docker、nginx配置通过http/https访问服务</h1><h2 id="1-下载nginx镜像"><a href="#1-下载nginx镜像" class="headerlink" title="1. 下载nginx镜像"></a>1. 下载nginx镜像</h2><pre><code class="ruby">$ docker pull nginx:latest</code></pre>
<h2 id="2-启动nginx容器"><a href="#2-启动nginx容器" class="headerlink" title="2. 启动nginx容器"></a>2. 启动nginx容器</h2><p>运行如下命令来启动nginx container</p>
<pre><code class="jsx">docker run --detach 
        --name wx-nginx 
        -p 443:443
        -p 80:80 
        -v /home/evan/workspace/wxserver/nginx/data:/usr/share/nginx/html:rw
        -v /home/evan/workspace/wxserver/nginx/config/nginx.conf:/etc/nginx/nginx.conf/:rw
        -v /home/evan/workspace/wxserver/nginx/config/conf.d/default.conf:/etc/nginx/conf.d/default.conf:rw
        -v /home/evan/workspace/wxserver/nginx/logs:/var/log/nginx/:rw
        -v /home/evan/workspace/wxserver/nginx/ssl:/ssl/:rw
        -d nginx</code></pre>
<ul>
<li>映射端口443，用于https请求</li>
<li>映射端口80，用于http请求；</li>
<li>nginx的默认首页html的存放目录映射到host盘的目录， /home/evan/workspace/wxserver/nginx/data</li>
<li>nginx的配置文件映射到host盘的文件，/home/evan/workspace/wxserver/nginx/config/nginx.conf</li>
</ul>
<p>这里需要准备如下几个文件，</p>
<ol>
<li>nginx的配置文件<br>首先是nginx.conf文件，默认的配置文件如下</li>
</ol>
<pre><code class="php">#运行nginx的用户
user  nginx;
#启动进程设置成和CPU数量相等
worker_processes  1;

#全局错误日志及PID文件的位置
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

#工作模式及连接数上限
events {
        #单个后台work进程最大并发数设置为1024
    worker_connections  1024;
}


http {
        #设定mime类型
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

        #设定日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

        #设置连接超时的事件
    keepalive_timeout  65;

        #开启GZIP压缩
    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}</code></pre>
<p>可以看到最后一行还要包含另一个配置文件conf.d/default.conf，用来配置server字段</p>
<pre><code class="bash">server {
    listen    80;       #侦听80端口，如果强制所有的访问都必须是HTTPs的，这行需要注销掉
    server_name  www.buagengen.com;             #域名

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

        # 定义首页索引目录和名称
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #定义错误提示页面
    #error_page  404              /404.html;

    #重定向错误页面到 /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}</code></pre>
<ol>
<li>nginx的默认首页的html文件<br>这个html可以自己定义一个，任意的都可以。</li>
</ol>
<p>这个时候直接通过IP地址就可以访问nginx定义的这个html文件了。但是这个时候的访问只是http的，https的访问还是不行的，需要添加证书到nginx服务器。</p>
<h2 id="3-通过openssl生成证书"><a href="#3-通过openssl生成证书" class="headerlink" title="3. 通过openssl生成证书"></a>3. 通过openssl生成证书</h2><ul>
<li>设置server.key，这里需要设置两遍密码:</li>
</ul>
<pre><code class="csharp">openssl genrsa -des3 -out server.key 1024 </code></pre>
<ul>
<li>参数设置，首先这里需要输入之前设置的密码:</li>
</ul>
<pre><code class="csharp">openssl req -new -key server.key -out server.csr</code></pre>
<p>然后需要输入如下的信息，大概填一下就可以了，反正是测试用的</p>
<pre><code class="dart">Country Name (2 letter code) [AU]: 国家名称
State or Province Name (full name) [Some-State]: 省
Locality Name (eg, city) []: 城市
Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名
Organizational Unit Name (eg, section) []: 
Common Name (e.g. server FQDN or YOUR name) []: 网站域名
Email Address []: 邮箱

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []: 这里要求输入密码
An optional company name []:</code></pre>
<ul>
<li>写RSA秘钥（这里也要求输入之前设置的密码）:</li>
</ul>
<pre><code class="css">openssl rsa -in server.key -out server_nopwd.key</code></pre>
<ul>
<li>获取私钥:</li>
</ul>
<pre><code class="css">openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt</code></pre>
<p>完成这一步之后就得到了我们需要的证书文件和私钥了</p>
<ul>
<li>server.crt</li>
<li>server.key</li>
</ul>
<h2 id="4-配置nginx服务器，支持https访问"><a href="#4-配置nginx服务器，支持https访问" class="headerlink" title="4. 配置nginx服务器，支持https访问"></a>4. 配置nginx服务器，支持https访问</h2><p>把前面一步生成的文件拷贝到host上的ssl目录，/home/evan/workspace/wxserver/nginx/ssl。<br>然后修改配置文件default.conf，添加ssl支持，</p>
<pre><code class="csharp">server {
    listen    80;       #侦听80端口，如果强制所有的访问都必须是HTTPs的，这行需要注销掉
    listen    443 ssl;
    server_name  www.buagengen.com;             #域名

    # 增加ssl
    #ssl on;        #如果强制HTTPs访问，这行要打开
    ssl_certificate /ssl/server.crt;
    ssl_certificate_key /ssl/server.key;

    ssl_session_cache    shared:SSL:1m;
    ssl_session_timeout  5m;

     # 指定密码为openssl支持的格式
     ssl_protocols  SSLv2 SSLv3 TLSv1.2;

     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式
     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码

     # 定义首页索引目录和名称
     location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
     }

    #重定向错误页面到 /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}</code></pre>
<p>重启nginx容器，现在就可以通过https来访问nginx的服务器了</p>
</body></html>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建MySQL服务</title>
    <url>/2020/04/09/docker-mysql/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="使用Docker搭建MySQL服务"><a href="#使用Docker搭建MySQL服务" class="headerlink" title="使用Docker搭建MySQL服务"></a><a href="https://www.cnblogs.com/sablier/p/11605606.html" target="_blank" rel="noopener">使用Docker搭建MySQL服务</a></h1><h3 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker#"></a>一、安装docker<a href="https://www.cnblogs.com/sablier/p/11605606.html#2145598473" target="_blank" rel="noopener">#</a></h3><p>windows 和 mac 版可以直接到官网下载 docker desktop</p>
<p>linux 的安装方法可以参考 <a href="https://www.cnblogs.com/myzony/p/9071210.html" target="_blank" rel="noopener">https://www.cnblogs.com/myzony/p/9071210.html</a></p>
<p>可以在shell中输入以下命令检查是否成功安装： <code>sudo docker version</code></p>
<h3 id="二、建立镜像"><a href="#二、建立镜像" class="headerlink" title="二、建立镜像#"></a>二、建立镜像<a href="https://www.cnblogs.com/sablier/p/11605606.html#244533582" target="_blank" rel="noopener">#</a></h3><ol>
<li><p>拉取官方镜像（我们这里选择5.7，如果不写后面的版本号则会自动拉取最新版）</p>
<pre><code class="shell">Copydocker pull mysql:5.7   # 拉取 mysql 5.7
docker pull mysql       # 拉取最新版mysql镜像</code></pre>
<p><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">MySQL文档地址</a></p>
</li>
<li><p>检查是否拉取成功</p>
<pre><code>Copy$ sudo docker images</code></pre></li>
<li><p>一般来说数据库容器不需要建立目录映射</p>
<pre><code class="shell">Copysudo docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre>
<ul>
<li>–name：容器名，此处命名为<code>mysql</code></li>
<li>-e：配置信息，此处配置mysql的root用户的登陆密码</li>
<li>-p：端口映射，此处映射 主机3306端口 到 容器的3306端口</li>
</ul>
</li>
<li><p>如果要建立目录映射</p>
<pre><code class="shell">Copyduso docker run -p 3306:3306 --name mysql \
-v /usr/local/docker/mysql/conf:/etc/mysql \
-v /usr/local/docker/mysql/logs:/var/log/mysql \
-v /usr/local/docker/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7</code></pre>
<ul>
<li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录</li>
</ul>
</li>
<li><p>检查容器是否正确运行</p>
<pre><code class="shell">Copydocker container ls</code></pre>
<ul>
<li>可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字</li>
</ul>
</li>
</ol>
<h3 id="三、连接mysql"><a href="#三、连接mysql" class="headerlink" title="三、连接mysql#"></a>三、连接mysql<a href="https://www.cnblogs.com/sablier/p/11605606.html#303544512" target="_blank" rel="noopener">#</a></h3><ol>
<li><p>进入docker本地连接mysql客户端</p>
<pre><code class="shell">Copysudo docker exec -it mysql bash
mysql -uroot -p123456</code></pre>
</li>
<li><p>使用 Navicat 远程连接mysql</p>
<p>我只找到了 mac 版本的 Navicat Premiun（如下），没有找到windows和linux的。大家可以自行寻找。</p>
<p> <a href="https://pan.baidu.com/s/1bcJVyIvFneiEoMZPU-oIbA#list/path=/" target="_blank" rel="noopener">百度云连接</a> 密码: qps3 （该软件包来自著名分享网站 Pirate ，并感谢网友 chaosgod 和 jor_ivy）</p>
<p><a href="https://img-blog.csdn.net/20180801090208199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener"><img alt="img" data-src="https://img-blog.csdn.net/20180801090208199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a></p>
<p><a href="https://img-blog.csdn.net/20180801090230920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener"><img alt="img" data-src="https://img-blog.csdn.net/20180801090230920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a></p>
<p>安装完之后：复制中文包”zh-Hans.lproj”放到 /Contents/Resources 即可。（应用程序右键显示包内容）</p>
</li>
<li><p>使用远程连接软件时要注意一个问题</p>
<p>我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问：</p>
<pre><code>Copyhost: 127.0.0.1
port: 3306
user: root
password: 123456</code></pre></li>
<li><p>如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：</p>
<ul>
<li><p>防火墙阻拦</p>
<pre><code class="shell">Copy# 开放端口：
$ systemctl status firewalld
$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent
$ firewall-cmd  --reload
# 关闭防火墙：
$ sudo systemctl stop firewalld</code></pre>
</li>
<li><p>需要进入docker本地客户端设置远程访问账号</p>
<pre><code class="shell">Copy$ sudo docker exec -it mysql bash
$ mysql -uroot -p123456
mysql> grant all privileges on *.* to root@'%' identified by "password";</code></pre>
<p>原理：</p>
<pre><code class="shell">Copy# mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）

mysql> use mysql;
Database changed

mysql> select host,user,password from user;
+--------------+------+-------------------------------------------+
| host                    | user      | password                                                                 |
+--------------+------+-------------------------------------------+
| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |
| 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |
+--------------+------+-------------------------------------------+
2 rows in set (0.00 sec)

mysql> grant all privileges  on *.* to root@'%' identified by "password";
Query OK, 0 rows affected (0.00 sec)

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql> select host,user,password from user;
+--------------+------+-------------------------------------------+
| host                    | user      | password                                                                 |
+--------------+------+-------------------------------------------+
| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
| 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
| %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
+--------------+------+-------------------------------------------+
3 rows in set (0.00 sec)</code></pre>
</li>
</ul>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>lerna 包管理</title>
    <url>/2020/04/09/lerna/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="lerna（大型前端项目模块管理工具）"><a href="#lerna（大型前端项目模块管理工具）" class="headerlink" title="lerna（大型前端项目模块管理工具）"></a>lerna（大型前端项目模块管理工具）</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">Lerna</a>是一个工具，它优化了使用git和npm管理多包存储库的工作流；vue、babel、react等都在用。</p>
<h2 id="2、工作模式"><a href="#2、工作模式" class="headerlink" title="2、工作模式"></a>2、工作模式</h2><p>lerna有2种工作模式</p>
<ul>
<li><h3 id="Fixed-Locked-mode-default"><a href="#Fixed-Locked-mode-default" class="headerlink" title="Fixed/Locked mode (default)"></a>Fixed/Locked mode (default)</h3></li>
</ul>
<p>vue,babel都是用这种，在<code>publish</code>的时候,会在<code>lerna.json</code>文件里面<code>"version": "0.1.5",</code>,依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号，会统一的使用这一个发布的版本号。</p>
<ul>
<li><h3 id="Independent-mode"><a href="#Independent-mode" class="headerlink" title="Independent mode"></a>Independent mode</h3></li>
</ul>
<pre><code class="javascript">lerna init --independent`初始化项目。
`lerna.json`文件里面`"version": "independent",</code></pre>
<p>每次<code>publish</code>时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改。</p>
<p><a href="01.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="01.png" class="lazyload"></a></p>
<h2 id="3、快速开始"><a href="#3、快速开始" class="headerlink" title="3、快速开始"></a>3、快速开始</h2><pre><code class="javascript">    $ npm install lerna -g
    $ mkdir lerna-gp && cd $_
    $ npm lerna init # 用的默认的固定模式，vue babel等都是这个

     # Add packages
    $ cd packages
    $ mkdir daybyday gpnode gpwebpack
    ...
    #分别进入三个目录初始化成包
    $ cd daybyday
    $ npm init -y 
    $ cd ../gpnode
    $ npm init -y
    $ cd ../gpwebpack
    $ npm init -y</code></pre>
<h3 id="4-、-项目结构"><a href="#4-、-项目结构" class="headerlink" title="4 、 项目结构"></a>4 、 项目结构</h3><pre><code class="json">➜  lerna-gp git:(master) ✗ tree
.
├── lerna.json
├── package.json
└── packages
    ├── daybyday
    │   └── package.json
    ├── gpnode
    │   └── package.json
    └── gpwebpack
        └── package.json

4 directories, 5 files</code></pre>
<h2 id="5、-Set-up"><a href="#5、-Set-up" class="headerlink" title="5、 Set up"></a>5、 Set up</h2><h3 id="Set-up-git-npm"><a href="#Set-up-git-npm" class="headerlink" title="Set up git + npm"></a>Set up git + npm</h3><pre><code class="javascript">✗ git remote add origin git@gitlab.yourSite.com:gaopo/lerna-gp.git

#查看是否登录
✗ npm whoami
gp0320

#没有则登录 
npm login 
# 输入username password 
Logged in as gp0320 on https://registry.npmjs.org/. # succeed</code></pre>
<h3 id="Set-up-yarn的workspaces模式"><a href="#Set-up-yarn的workspaces模式" class="headerlink" title="Set up yarn的workspaces模式"></a>Set up yarn的workspaces模式</h3><blockquote>
<p>默认是npm, 而且每个子package都有自己的<code>node_modules</code>，通过这样设置后，只有顶层有一个<code>node_modules</code></p>
</blockquote>
<ul>
<li>修改顶层 <code>package.json and lerna.json</code></li>
</ul>
<pre><code class="json"># package.json 文件加入
 "private": true,
  "workspaces": [
    "packages/*"
  ],

# lerna.json 文件加入
"useWorkspaces": true,
"npmClient": "yarn",
</code></pre>
<h2 id="6-、Lerna-Script"><a href="#6-、Lerna-Script" class="headerlink" title="6 、Lerna Script"></a>6 、Lerna Script</h2><h3 id="lerna-create-loc"><a href="#lerna-create-loc" class="headerlink" title="lerna create  [loc]"></a>lerna create <name> [loc]</name></h3><blockquote>
<p>创建一个包，name包名，loc 位置可选</p>
</blockquote>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="javascript"># 根目录的package.json 
 "workspaces": [
    "packages/*",
    "packages/@gp0320/*"
  ],

# 创建一个包gpnote默认放在 workspaces[0]所指位置
lerna create gpnote 

# 创建一个包gpnote指定放在 packages/@gp0320文件夹下，注意必须在workspaces先写入packages/@gp0320，看上面
lerna create gpnote packages/@gp0320</code></pre>
<h3 id="lerna-add-version-–dev-–exact"><a href="#lerna-add-version-–dev-–exact" class="headerlink" title="lerna add [@version] [–dev] [–exact]"></a>lerna add <package>[@version] [–dev] [–exact]</package></h3><blockquote>
<p>增加本地或者远程<code>package</code>做为当前项目<code>packages</code>里面的依赖</p>
</blockquote>
<ul>
<li><code>--dev</code> devDependencies 替代 <code>dependencies</code></li>
<li><code>--exact</code> 安装准确版本，就是安装的包版本前面不带<code>^</code>, Eg: <code>"^2.20.0" ➜ "2.20.0"</code></li>
</ul>
<h4 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="javascript"># Adds the module-1 package to the packages in the 'prefix-' prefixed folders
lerna add module-1 packages/prefix-*

# Install module-1 to module-2
lerna add module-1 --scope=module-2

# Install module-1 to module-2 in devDependencies
lerna add module-1 --scope=module-2 --dev

# Install module-1 in all modules except module-1
lerna add module-1

# Install babel-core in all modules
lerna add babel-core</code></pre>
<h3 id="lerna-bootstrap"><a href="#lerna-bootstrap" class="headerlink" title="lerna bootstrap"></a>lerna bootstrap</h3><p>默认是npm i,因为我们指定过yarn，so,run yarn install,会把所有包的依赖安装到根<code>node_modules</code>.</p>
<h3 id="lerna-list"><a href="#lerna-list" class="headerlink" title="lerna list"></a>lerna list</h3><p>列出所有的包，如果与你文夹里面的不符，进入那个包运行<code>yarn init -y</code>解决</p>
<pre><code>➜  lerna-gp git:(master) ✗ lerna list
lerna notice cli v3.14.1
daybyday
gpnode
gpnote
gpwebpack
lerna success found 4 packages</code></pre><h3 id="lerna-import"><a href="#lerna-import" class="headerlink" title="lerna import "></a>lerna import <path-to-external-repository></path-to-external-repository></h3><p>导入本地已经存在的包</p>
<p><a href="02.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="02.png" class="lazyload"></a></p>
<h3 id="lerna-run"><a href="#lerna-run" class="headerlink" title="lerna run"></a>lerna run</h3><pre><code>lerna run < script > -- [..args] # 运行所有包里面的有这个script的命令
$ lerna run --scope my-component test</code></pre><h3 id="lerna-exec"><a href="#lerna-exec" class="headerlink" title="lerna exec"></a>lerna exec</h3><p>运行任意命令在每个包</p>
<pre><code>$ lerna exec -- < command > [..args] # runs the command in all packages
$ lerna exec -- rm -rf ./node_modules
$ lerna exec -- protractor conf.js
lerna exec --scope my-component -- ls -la</code></pre><h3 id="lerna-link"><a href="#lerna-link" class="headerlink" title="lerna link"></a>lerna link</h3><p>项目包建立软链，类似npm link</p>
<h3 id="lerna-clean"><a href="#lerna-clean" class="headerlink" title="lerna clean"></a>lerna clean</h3><p>删除所有包的node_modules目录<br><a href="03.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="03.png" class="lazyload"></a></p>
<h3 id="lerna-changed"><a href="#lerna-changed" class="headerlink" title="lerna changed"></a>lerna changed</h3><p>列出下次发版<code>lerna publish</code> 要更新的包。</p>
<p>原理：<br>需要先git add,git commit 提交。<br>然后内部会运行<code>git diff --name-only v版本号</code>，搜集改动的包，就是下次要发布的。并不是网上人说的所有包都是同一个版全发布。</p>
<pre><code>➜  lerna-repo git:(master) ✗ lerna changed                                     
info cli using local version of lerna
lerna notice cli v3.14.1
lerna info Looking for changed packages since v0.1.4
daybyday #只改过这一个 那下次publish将只上传这一个
lerna success found 1 package ready to publish</code></pre><h3 id="lerna-publish"><a href="#lerna-publish" class="headerlink" title="lerna publish"></a>lerna publish</h3><p>会打tag，上传git,上传npm。<br>如果你的包名是带scope的例如：<code>"name": "@gp0320/gpwebpack",</code><br>那需要在packages.json添加</p>
<pre><code> "publishConfig": {
    "access": "public"
  },
lerna publish 
lerna info current version 0.1.4
#这句意思是查找从v0.1.4到现在改动过的包
lerna info Looking for changed packages since v0.1.4 

? Select a new version (currently 0.1.4) Patch (0.1.5)

Changes:
 - daybyday: 0.1.3 => 0.1.5 #只改动过一个

...

Successfully published:
 - daybyday@0.1.5
lerna success published 1 package</code></pre></body></html>]]></content>
      <categories>
        <category>包管理（前端）</category>
      </categories>
      <tags>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title>H5移动端适配</title>
    <url>/2020/04/08/mobile-adpat-pixel/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="media-H5移动端屏幕适配"><a href="#media-H5移动端屏幕适配" class="headerlink" title="@media H5移动端屏幕适配"></a>@media H5移动端屏幕适配</h1><h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><pre><code>name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"</code></pre><blockquote>
<ul>
<li>viewport ：用户网页的可视区域.</li>
<li>width：控制viewport的大小，可以指定一个值，如600，或者特殊的值，如device-width为设备的宽度（单位为缩放100%时的CSS的像素）。</li>
<li>height：和 width 相对应，指定高度。</li>
<li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li>
<li>maximum-scale：允许用户缩放到的最大比例。</li>
<li>user-scalable：用户是否可以手动缩放。</li>
</ul>
</blockquote>
<h2 id="移动端手机尺寸"><a href="#移动端手机尺寸" class="headerlink" title="移动端手机尺寸"></a>移动端手机尺寸</h2><h3 id="1-phone4-iphone5-SE-width是一样"><a href="#1-phone4-iphone5-SE-width是一样" class="headerlink" title="1. phone4/iphone5/SE(width是一样)"></a>1. phone4/iphone5/SE(width是一样)</h3><pre><code class="scss">// 特殊场景，写法不一，比如：
1. @media screen and (max-width:320px ){}
2. @media screen and (max-height:480px ){}
3. @media screen and (max-width:320px ) and (max-height:480px ){}</code></pre>
<h3 id="2-iphone6-7-8"><a href="#2-iphone6-7-8" class="headerlink" title="2. iphone6/7/8"></a>2. iphone6/7/8</h3><pre><code class="scss">// 有时候我们只需要获取width 或者height 其中一个即可
1. @media screen and (max-width:375px ){}
2. @media screen and (max-height:667px ){}</code></pre>
<h3 id="3-iphone6-7-8-Plus"><a href="#3-iphone6-7-8-Plus" class="headerlink" title="3. iphone6/7/8 Plus"></a>3. iphone6/7/8 Plus</h3><pre><code class="scss">1. @media screen and (max-width:414px ){}
2. @media screen and (max-height:736px ){}</code></pre>
<h3 id="4-iPhone-XS-5-8-英寸"><a href="#4-iPhone-XS-5-8-英寸" class="headerlink" title="4. iPhone XS: 5.8 英寸"></a>4. iPhone XS: 5.8 英寸</h3><pre><code class="scss">@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3){}</code></pre>
<h3 id="5-iPhone-XR-6-1-英寸"><a href="#5-iPhone-XR-6-1-英寸" class="headerlink" title="5. iPhone XR: 6.1 英寸"></a>5. iPhone XR: 6.1 英寸</h3><pre><code class="css">@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2){}</code></pre>
<h3 id="6-iPhone-XS-Max-6-5-英寸"><a href="#6-iPhone-XS-Max-6-5-英寸" class="headerlink" title="6. iPhone XS Max: 6.5 英寸"></a>6. iPhone XS Max: 6.5 英寸</h3><pre><code class="css">@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3){}</code></pre>
<h2 id="获取屏幕尺寸"><a href="#获取屏幕尺寸" class="headerlink" title="获取屏幕尺寸"></a>获取屏幕尺寸</h2><pre><code class="dart">// 屏幕可以大小
screen.availWidth+"/"+screen.availHeight
// 屏幕分辨率
screen.width+"/"+screen.height
// 网页可见区域
document.body.clientWidth +"/"+ document.body.clientHeight
// 网页可见区域(包括边线的宽)
document.body.offsetWidth +"/"+ document.body.offsetHeight</code></pre>
</body></html>]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（三）</title>
    <url>/2020/04/03/Nest-Dev-03/</url>
    <content><![CDATA[<html lang="zh-CN"><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-指南（三）"><a href="#Nest-指南（三）" class="headerlink" title="Nest 指南（三）"></a>Nest 指南（三）</h1><h2 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h2><p>模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。</p>
<p><a href="https://docs.nestjs.com/modules" target="_blank" rel="noopener">NestModule</a></p>
<p><a href="https://www.itying.com/nestjs/statics/images/module.png" data-fancybox="group" data-caption="Nestjs中的模块" class="fancybox"><img alt="Nestjs中的模块" title="Nestjs中的模块" data-src="https://www.itying.com/nestjs/statics/images/module.png" class="lazyload"></a></p>
<p>每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。</p>
<p><strong>@module() 装饰器接受一个描述模块属性的对象：</strong></p>
<pre><code class="javascript">providers        由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享
controllers        必须创建的一组控制器
imports            导入模块的列表，这些模块导出了此模块中所需提供者
exports            由本模块提供并应在其他模块中可用的提供者的子集</code></pre>
<h3 id="1、创建模块"><a href="#1、创建模块" class="headerlink" title="1、创建模块"></a>1、创建模块</h3><pre><code class="shell">nest g module admin</code></pre>
<p><a href="https://www.itying.com/nestjs/statics/images/module2.png" data-fancybox="group" data-caption="Nestjs中的模块" class="fancybox"><img alt="Nestjs中的模块" title="Nestjs中的模块" data-src="https://www.itying.com/nestjs/statics/images/module2.png" class="lazyload"></a></p>
<h3 id="2、共享模块"><a href="#2、共享模块" class="headerlink" title="2、共享模块"></a>2、共享模块</h3><p>实际上，每个模块都是一个共享模块。一旦创建就能被任意模块重复使用。假设我们将在几个模块之间共享 CatsService 实例。 我们需要把 CatsService 放到 exports 数组中，如下所 示：</p>
<pre><code class="javascript">import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}</code></pre>
<h2 id="2、TypeORM操作Mysql数据库"><a href="#2、TypeORM操作Mysql数据库" class="headerlink" title="2、TypeORM操作Mysql数据库"></a>2、TypeORM操作Mysql数据库</h2><p>Nestjs中操作mysql数据库可以使用Nodejs封装的DB库，也可以使用TypeORM。下面我们主要给大家讲讲在Nestjs中使用TypeORM操作mysql数据库</p>
<h3 id="1、关于TypeORM"><a href="#1、关于TypeORM" class="headerlink" title="1、关于TypeORM"></a>1、关于TypeORM</h3><p>TypeORM是一个ORM框架，是一款比较成熟的对象关系映射器，它是由typescript写的。 支持 MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, WebSQL等数据库。</p>
<h3 id="2、安装TypeORM-操作Mysql模块"><a href="#2、安装TypeORM-操作Mysql模块" class="headerlink" title="2、安装TypeORM 操作Mysql模块"></a>2、安装TypeORM 操作Mysql模块</h3><p>Nest 操作Mysql<a href="https://docs.nestjs.com/techniques/database" target="_blank" rel="noopener">官方文档</a></p>
<pre><code class="shell">npm install --save @nestjs/typeorm typeorm mysql</code></pre>
<h3 id="3、配置数据库"><a href="#3、配置数据库" class="headerlink" title="3、配置数据库"></a>3、配置数据库</h3><p>在app.module.ts中配置数据库连接</p>
<pre><code class="typescript">      import { Module } from '@nestjs/common';
      import { TypeOrmModule } from '@nestjs/typeorm';
      @Module({
        imports: [
          TypeOrmModule.forRoot({
            type: 'mysql',
            host: 'localhost',
            port: 3306,
            username: 'root',
            password: 'root',
            database: 'test',
            entities: [__dirname + '/**/*.entity{.ts,.js}'],
            synchronize: true,
          }),
        ],
      })
      export class AppModule {}
</code></pre>
<h3 id="3、配置实体entity"><a href="#3、配置实体entity" class="headerlink" title="3、配置实体entity"></a>3、配置实体entity</h3><pre><code class="typescript">      import { PrimaryGeneratedColumn, Column, Entity } from "typeorm";
      @Entity()
      export class Nav {
        @PrimaryGeneratedColumn()
        id: number;

        @Column({length: 45})
        name: string;

        @Column({length:255})
        url: string;

        @Column('int')
        status: number;
      }
</code></pre>
<h3 id="4、在控制器对应的Module中配置Model"><a href="#4、在控制器对应的Module中配置Model" class="headerlink" title="4、在控制器对应的Module中配置Model"></a>4、在控制器对应的Module中配置Model</h3><pre><code class="typescript">      import { Module } from '@nestjs/common';
      import { UserController } from './controller/user/user.controller';
      import { NewsController } from './controller/news/news.controller';
      import { TypeOrmModule } from '@nestjs/typeorm';
      import {Nav} from '../../entity/nav.entity';
      import {Navinfo} from '../../entity/navinfo.entity';
      import { AppService } from '../../app.service';

      @Module({
        imports:[TypeOrmModule.forFeature([Nav,Navinfo])],
        controllers: [UserController, NewsController],
        providers:[AppService]
      })
      export class AdminModule {}

</code></pre>
<h3 id="5、在服务里面使用-InjectRepository获取数据库Model实现操作数据库"><a href="#5、在服务里面使用-InjectRepository获取数据库Model实现操作数据库" class="headerlink" title="5、在服务里面使用@InjectRepository获取数据库Model实现操作数据库"></a>5、在服务里面使用@InjectRepository获取数据库Model实现操作数据库</h3><pre><code class="typescript">      import { Injectable } from '@nestjs/common';
      import { InjectRepository } from '@nestjs/typeorm';
      import { Repository } from 'typeorm';
      import {Nav} from './entity/nav.entity';
      import {Navinfo} from './entity/navinfo.entity';
      @Injectable()
      export class AppService {
        constructor(
          //依赖注入
          @InjectRepository(Nav) private readonly navRepository: Repository,
          @InjectRepository(Navinfo) private readonly navinfoRepository: Repository,
        ) {}
        async findAll(){   
          return await this.navRepository.find();    
        }
      }
</code></pre>
<h2 id="3、Redis"><a href="#3、Redis" class="headerlink" title="3、Redis"></a>3、Redis</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><ul>
<li>Redis 字符串数据类型的相关命令用于管理 redis 字符串值。</li>
</ul>
<pre><code class="json">  基本语法：
  查看所有的key:         keys *
  普通设置：             set key value
  设置并加过期时间：     set key value EX 30           表示30秒后过期
  获取数据：             get key
  删除指定数据：         del key
  删除全部数据:          flushall 
  查看类型：             type key
  设置过期时间:          expire key  20              表示指定的key5秒后过期
</code></pre>
<ul>
<li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li>
</ul>
<pre><code class="json">基本语法：
列表右侧增加值：             rpush key value
列表左侧增加值：             lpush key value
右侧删除值：                 rpop key
左侧删除值：                 lpop key
获取数据：                   lrange key
删除指定数据：               del key
删除全部数据:                flushall 
查看类型：                   type key</code></pre>
<ul>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。它和列表的最主要区别就是没法增加重复值</li>
</ul>
<pre><code>基本语法：
给集合增数据：               sadd key value
删除集合中的一个值：         srem key value
获取数据：                   smembers key
删除指定数据：               del key
删除全部数据:                flushall </code></pre><ul>
<li>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li>
</ul>
<pre><code>  基本语法：
  设置值hmset ：               hmset zhangsan name "张三" age 20  sex “男”
  设置值hset ：                 hset zhangsan name "张三"
  获取数据：                     hgetall key
  删除指定数据：                 del key
  删除全部数据:                  flushall </code></pre><ul>
<li>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>
</ul>
<blockquote>
<p><strong>发布</strong></p>
</blockquote>
<pre><code class="typescript">  client.publish('testPublish', 'message from publish.js');</code></pre>
<blockquote>
<p><strong>订阅</strong></p>
</blockquote>
<pre><code class="typescript">client.subscribe('testPublish');
client.on('message', function(channel, msg){
    console.log('client.on message, channel:', channel, ' message:', msg);
});</code></pre>
<h3 id="2、Nest使用"><a href="#2、Nest使用" class="headerlink" title="2、Nest使用"></a>2、Nest使用</h3><p><a href="https://github.com/kyknow/nestjs-redis" target="_blank" rel="noopener">Nestjs Redis 官方文档</a></p>
<h4 id="1、安装redis"><a href="#1、安装redis" class="headerlink" title="1、安装redis"></a><strong>1、安装redis</strong></h4><pre><code class="shell">npm install nestjs-redis --save</code></pre>
<h4 id="2、用到redis的模块中注册RedisModule"><a href="#2、用到redis的模块中注册RedisModule" class="headerlink" title="2、用到redis的模块中注册RedisModule"></a><strong>2、用到redis的模块中注册RedisModule</strong></h4><p>options是一个对象，里面配置了连接redis服务器的信息</p>
<pre><code class="typescript">  import { RedisModule} from 'nestjs-redis'
  关于options
  let options={
          port: 6379,
          host: '127.0.0.1',
          password: '',
          db: 0
  }
   @Module({
      imports: [
          RedisModule.register(options)
      ],
  })</code></pre>
<h4 id="3、创建一个cache-service-ts-服务-封装操作redis的方法"><a href="#3、创建一个cache-service-ts-服务-封装操作redis的方法" class="headerlink" title="3、创建一个cache.service.ts 服务 封装操作redis的方法"></a><strong>3、创建一个cache.service.ts 服务 封装操作redis的方法</strong></h4><pre><code class="typescript">import { Injectable } from '@nestjs/common';
import { RedisService } from 'nestjs-redis';
@Injectable()
export class CacheService {    
    public client;
    constructor(private redisService: RedisService) {
        this.getClient();
    }
    async getClient() {
        this.client = await this.redisService.getClient()
    }

    //设置值的方法
    async set(key:string, value:any, seconds?:number) {
        value = JSON.stringify(value);
        if(!this.client){
            await this.getClient();
        }
        if (!seconds) {
            await this.client.set(key, value);
        } else {
            await this.client.set(key, value, 'EX', seconds);
        }
    }

    //获取值的方法
    async get(key:string) {
        if(!this.client){
            await this.getClient();
        }
        var data = await this.client.get(key);           
        if (!data) return;
        return JSON.parse(data);       
    }
}</code></pre>
<h4 id="4、调用cache-service-ts-里面封装的方法操作redis数据库"><a href="#4、调用cache-service-ts-里面封装的方法操作redis数据库" class="headerlink" title="4、调用cache.service.ts 里面封装的方法操作redis数据库"></a><strong>4、调用cache.service.ts 里面封装的方法操作redis数据库</strong></h4><pre><code class="typescript">await this.cache.set('username','李四');

await this.cache.get('username')</code></pre>
<h2 id="4、GraphQL"><a href="#4、GraphQL" class="headerlink" title="4、GraphQL"></a>4、GraphQL</h2><p>GraphQl是一种新的API 的查询语言，它提供了一种更高效、强大和灵活API 查询,下面给大家讲讲在Nestjs中使用Graphql</p>
<p>Nestjs中使用<a href="https://docs.nestjs.com/graphql/quick-start" target="_blank" rel="noopener">Graphql官方文档</a></p>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><pre><code class="shell"> $ npm i --save @nestjs/graphql graphql-tools graphql        </code></pre>
<h3 id="2、定义数据库Schema"><a href="#2、定义数据库Schema" class="headerlink" title="2、定义数据库Schema"></a>2、定义数据库Schema</h3><p>src目录下面新建app.graphql，Schema（数据映射模型）代码如下</p>
<pre><code class="typescript">type Query {
  hello: String
  findCat(id: ID): Cat
  cats: [Cat]
}

type Cat {
  id: Int
  name: String
  age: Int
}

type Mutation {
  addCat(cat: InputCat): Cat
}

input InputCat {
  name: String
  age: Int
}
</code></pre>
<h3 id="3、定义-resolvers-操作数据库的方法"><a href="#3、定义-resolvers-操作数据库的方法" class="headerlink" title="3、定义 resolvers 操作数据库的方法"></a>3、定义 resolvers 操作数据库的方法</h3><p>通过命令创建resolvers</p>
<pre><code class="shell">nest g resolver app</code></pre>
<p>这样会在src目录下面生成app.resolvers.ts ，然后配置如下代码</p>
<pre><code class="typescript">import { ParseIntPipe } from '@nestjs/common';
import { Query, Resolver, Args, Mutation } from '@nestjs/graphql';
import { AppService } from './app.service';

@Resolver()
export class AppResolver {
  constructor(private readonly appService: AppService) {}

  // query { hello }
  @Query()
  hello(): string {
    return this.appService.hello();
  }

  // query { findCat(id: 1) { name age } }
  // 网络传输过来的id会是字符串类型，而不是number
  @Query('findCat')
  findOneCat(@Args('id', ParseIntPipe) id: number) {
    return this.appService.findCat(id);
  }

  // query { cats { id name age } }
  @Query()
  cats() {
    return this.appService.findAll();
  }

  // mutation { addCat(cat: {name: "ajanuw", age: 12}) { id name age } }
  @Mutation()
  addCat(@Args('cat') args) {
    console.log(args);
    return this.appService.addCat(args)
  }
}
</code></pre>
<h3 id="4、定义-服务-app-service-ts"><a href="#4、定义-服务-app-service-ts" class="headerlink" title="4、定义 服务 app.service.ts"></a>4、定义 服务 app.service.ts</h3><pre><code class="typescript">import { Injectable } from '@nestjs/common';
import { Cat } from './graphql.schema';

@Injectable()
export class AppService {
  private readonly cats: Cat[] = [
    { id: 1, name: 'a', age: 1 },
    { id: 2, name: 'b', age: 2 },
  ];
  hello(): string {
    return 'Hello World!';
  }

  findCat(id: number): Cat {
    return this.cats.find(c => c.id === id);
  }

  findAll(): Cat[] {
    return this.cats;
  }

  addCat(cat: Cat): Cat {
    const newCat = { id: this.cats.length + 1, ...cat };
    console.log(newCat);
    this.cats.push(newCat);
    return newCat;
  }
}
</code></pre>
<h3 id="5、定义接口-graphql-schema-ts-（非必须）"><a href="#5、定义接口-graphql-schema-ts-（非必须）" class="headerlink" title="5、定义接口 graphql.schema.ts （非必须）"></a>5、定义接口 graphql.schema.ts （非必须）</h3><pre><code class="typescript">export class Cat {
  id: number;
  name: string;
  age: number;
}
</code></pre>
<h3 id="6、配置app-module-ts"><a href="#6、配置app-module-ts" class="headerlink" title="6、配置app.module.ts"></a>6、配置app.module.ts</h3><pre><code class="typescript">import { Module } from '@nestjs/common';
import { AppService } from './app.service';

import { GraphQLModule } from '@nestjs/graphql';
import { AppResolver } from './app.resolvers';

@Module({
  imports: [
    GraphQLModule.forRoot({
      typePaths: ['./**/*.graphql'],   //加载目录下面所有以graphql结尾的schema文件，当做固定写法
    }), 
  ],
  providers: [AppService, AppResolver],
})
export class AppModule {}
</code></pre>
<h3 id="7、操作graphql数据库"><a href="#7、操作graphql数据库" class="headerlink" title="7、操作graphql数据库"></a>7、操作graphql数据库</h3><pre><code class="typescript">// 发送
query { hello }

// 返回
{
  "data": {
    "hello": "hello nest.js"
  }
}</code></pre>
<h2 id="5、Websocket-socket-io实时通信"><a href="#5、Websocket-socket-io实时通信" class="headerlink" title="5、Websocket(socket.io实时通信)"></a>5、Websocket(socket.io实时通信)</h2><p>在 Nest 中，网关只是一个用 @WebSocketGateway() 装饰器注解的类。从技术上讲，网关与平台无关，这使得它们在创建适配器之后就可以与任何 WebSockets 库兼容。有两个开箱即用的WS平台:socket.io和ws。你可以选择最适合你需要的。另外，您可以按照本指南构建自己的适配器。</p>
<p><a href="https://docs.nestjs.com/websockets/gateways" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="1、安装-socketIo对应模块"><a href="#1、安装-socketIo对应模块" class="headerlink" title="1、安装 socketIo对应模块"></a>1、安装 socketIo对应模块</h3><pre><code class="shell">$ npm i --save @nestjs/websockets @nestjs/platform-socket.io
$ npm i --save-dev @types/socket.io      </code></pre>
<h3 id="2、生成gateway并配置socket"><a href="#2、生成gateway并配置socket" class="headerlink" title="2、生成gateway并配置socket"></a>2、生成gateway并配置socket</h3><pre><code class="shell">nest g gateway events  </code></pre>
<p>通过上面命令会在src目录下面生成events.gateway.js</p>
<p>这个里面可以自定义方法接受客户端广播</p>
<pre><code class="typescript">import { 
        SubscribeMessage, 
        WebSocketGateway, 
        WsResponse, 
        WebSocketServer 
        } from '@nestjs/websockets';
import { Observable, of } from 'rxjs';  //异步流数据处理框架
import { map } from 'rxjs/operators'
const l = console.log

@WebSocketGateway()
export class EventsGateway {
  @WebSocketServer() server;

  @SubscribeMessage('events')
  onEvent(client: any, payload: any): Observable> | any {
    // this.server.emit('resmsg', data);  // io.emit('resmsg', payload)
    let { name } = payload;
    if (name === 'ajanuw') {
      return of({
        event: 'events',
        data: {
          msg: 'hello ajanuw!'
        }
      })
    }
    if (name === 'alone') {
      return of('hi', '实打实')
        .pipe(
          map($_ =>
            ({
              event: 'events', data: {
                msg: $_
              }
            }))
        );
    }
    return of(payload);
  }

}
</code></pre>
<h3 id="3、app-module-ts"><a href="#3、app-module-ts" class="headerlink" title="3、app.module.ts"></a>3、app.module.ts</h3><pre><code class="typescript">app.module.ts
import { EventsGateway } from './events/events.gateway'
@Module({
  providers: [EventsGateway],
})
</code></pre>
<h3 id="4、socket客户端"><a href="#4、socket客户端" class="headerlink" title="4、socket客户端"></a>4、socket客户端</h3><pre><code class="javascript">    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
  <script>
    const l = console.log
    let socket = io('http://localhost:5000');
    socket.on('connect', function () {
      console.log('链接成功');
      // 发射
      socket.emit('events', {
        name: 'ajanuw'
      });
      // 发射
      socket.emit('events', {
        name: 'alone'
      });
      // 发射
      // socket.emit('identity', 0, (response) => console.log('Identity:', response));
    });
    // 监听
    socket.on('events', (data) => {
      l(data.msg)
    });
  </script>
</code></pre>
<h3 id="5、分组广播和监听进入离开事件"><a href="#5、分组广播和监听进入离开事件" class="headerlink" title="5、分组广播和监听进入离开事件"></a>5、分组广播和监听进入离开事件</h3><pre><code class="typescript">  import { SubscribeMessage, WebSocketGateway,WebSocketServer} from '@nestjs/websockets';
  import { of } from 'rxjs';
  import * as url from "url"

  @WebSocketGateway()
  export class EventsGateway {
    @WebSocketServer() server;

    private clientsArr:any[]=[];

    handleConnection(client: any,){

      console.log('有人链接了'+client.id);   

    }

    handleDisconnect(client:any){

    }

    @SubscribeMessage('addCart')
    addCart(client: any, payload: any) {
         console.log(payload) 

        var roomid=url.parse(client.request.url,true).query.roomid;   /*获取房间号 获取桌号*/
        client.join(roomid);
        // this.server.to(roomid).emit('addCart','Server AddCart Ok');    //广播所有人包含自己

        client.broadcast.to(roomid).emit('addCart','Server AddCart Ok');   //不包括自己


    }

  }  </code></pre>
<p><strong>客户端代码:</strong></p>
<pre><code class="typescript">


    <meta charset="UTF-8">
    <title>socket.io</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>


<h1>socket.io的多房间1111</h1>
<input type="button" value="加入购物车" onclick="addCart()"><br>





<script type="text/javascript">

    //和服务器建立长连接
    var socket = io.connect('http://localhost:3000?roomid=1');

    //接收服务器返回的信息
    socket.on('addCart',function(data){

        console.log(data);
    });

    function addCart(){
        socket.emit('addCart','addCart');
    }

</script></code></pre>
<h2 id="6、微服务"><a href="#6、微服务" class="headerlink" title="6、微服务"></a>6、微服务</h2><p>除了传统的(有时称为单片)应用程序架构之外，Nest 还支持微服务架构风格的开发。本文档中其他地方讨论的大多数概念，如依赖项注入、装饰器、异常过滤器、管道、保护和拦截器，都同样适用于微服务。Nest 会尽可能地抽象化实现细节，以便相同的组件可以跨基于 HTTP 的平台，WebSocket 和微服务运行。</p>
<p><a href="https://docs.nestjs.com/microservices/basics" target="_blank" rel="noopener">文档</a></p>
<p>Nest 支持几种内置的传输层实现，称为传输器，负责在不同的微服务实例之间传输消息。大多数传输器本机都支持请求 - 响应和基于事件的消息样式。Nest 在规范接口的后面抽象了每个传输器的实现细节，用于请求 - 响应和基于事件的消息传递。这样可以轻松地从一个传输层切换到另一层，例如，利用特定传输层的特定可靠性或性能功能，而不会影响您的应用程序代码。</p>
<p>通俗的讲:Nestjs中的管道可以将输入数据转换为所需的输出。此外，它也可以处理验证，当数据不正确时可能会抛出异常。</p>
<h3 id="1、安装-1"><a href="#1、安装-1" class="headerlink" title="1、安装"></a><strong>1、安装</strong></h3><pre><code class="shell">$ npm i --save @nestjs/microservices        </code></pre>
<blockquote>
<p><strong>main.ts</strong></p>
</blockquote>
<pre><code class="typescript">import { NestFactory } from '@nestjs/core';
import { Transport } from '@nestjs/microservices';

import { AppModule } from './app.module';

async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    app.connectMicroservice({
    transport: Transport.TCP,
    });

    await app.startAllMicroservicesAsync();
    await app.listen(5000);
}
bootstrap();</code></pre>
<blockquote>
<p><strong>app.controller.ts</strong></p>
</blockquote>
<pre><code class="typescript">import { Controller, Get, Query, UsePipes } from '@nestjs/common';
import {
  MessagePattern,
  Client,
  Transport,
  ClientProxy,
} from '@nestjs/microservices';
import { AppService } from './app.service';

import { Observable, from } from 'rxjs';

import { ValidationPipe } from './validation.pipe';

@Controller()
export class AppController {
  @Client({ transport: Transport.TCP })
  client: ClientProxy;

  constructor(private readonly appService: AppService) {}

  @UsePipes(new ValidationPipe())
  @Get()
  getHello(@Query('data') data): Observable {
    // const pattern = { cmd: 'sumObservable' };
    // const pattern = { cmd: 'sumAsync' };
    const pattern = { cmd: 'sum' };

    // 使用 send 调用微服务
    const r = this.client.send(pattern, data);
    return r;
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return data.reduce((acc, el) => acc + el);
  }

  // 返回promise异步响应
  @MessagePattern({ cmd: 'sumAsync' })
  sumAsync(data: number[]): Promise {
    const result = data.reduce((acc, el) => acc + el) + 1;
    return Promise.resolve(result);
  }

  // 程序将响应3次
  @MessagePattern({ cmd: 'sumObservable' })
  sumObservable(data: number[]): Observable {
    return from([1, 2, 3]);
  }
}</code></pre>
<blockquote>
<p><strong>validation.pipe.ts</strong></p>
</blockquote>
<pre><code class="typescript">import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  PayloadTooLargeException,
  BadRequestException,
} from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (metadata.type === 'query') {
      try {
        return JSON.parse(value);
      } catch (error) {
        throw new BadRequestException();
      }
    } else {
      throw new PayloadTooLargeException();
    }
  }
}</code></pre>
<blockquote>
<p><strong>输入：</strong></p>
</blockquote>
<pre><code class="typescript">http://localhost:5000/?data=[1,2, 3] // 6</code></pre>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（二）</title>
    <url>/2020/04/03/Nest-dev-02/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-6-x-快速指南"><a href="#Nest-6-x-快速指南" class="headerlink" title="Nest 6.x 快速指南"></a>Nest 6.x 快速指南</h1><h2 id="1、-路由-视图层"><a href="#1、-路由-视图层" class="headerlink" title="1、 路由/视图层"></a>1、 路由/视图层</h2><p>如果我们希望在Nest里面管理路由的跳转，即项目保持高耦合的前后端不分离架构，我们则需要对Nest配置模板引擎，针对目前的开发模式和要求，这种方式有很多限制，所以我推荐实行前后端分离的模式。Nest只是处理I/O，专注于提供数据接口。</p>
<h3 id="1、安装模板引擎-ejs-或者pugjs"><a href="#1、安装模板引擎-ejs-或者pugjs" class="headerlink" title="1、安装模板引擎 ejs(或者pugjs)"></a>1、安装模板引擎 ejs(或者pugjs)</h3><pre><code class="javascript">cnpm i ejs --save</code></pre>
<h3 id="2、配置模板引擎"><a href="#2、配置模板引擎" class="headerlink" title="2、配置模板引擎"></a>2、配置模板引擎</h3><pre><code class="javascript">app.setBaseViewsDir(join(__dirname, '..', 'views')) // 放视图的文件
app.setViewEngine('ejs');    </code></pre>
<h3 id="3、配置完整代码"><a href="#3、配置完整代码" class="headerlink" title="3、配置完整代码"></a>3、配置完整代码</h3><pre><code class="javascript">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import {join} from 'path';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // app.useStaticAssets('public'); 
  app.useStaticAssets(join(__dirname, '..', 'public'),{
    prefix: '/static/',   //设置虚拟路径---保证路径文件下文件安全性
 }); 

  app.setBaseViewsDir(join(__dirname, '..', 'views')) // 放视图的文件（模板浏览器渲染页面）
  app.setViewEngine('ejs');

  await app.listen(3000);
}
bootstrap();</code></pre>
<h3 id="3、渲染页面"><a href="#3、渲染页面" class="headerlink" title="3、渲染页面"></a>3、渲染页面</h3><p>Nestjs中 Render装饰器可以渲染模板</p>
<pre><code class="javascript">import { Get, Controller, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index') //跳转路由--指定到视图层（View）下具体存在的文件
  root() {
    return { message: 'Hello world!' };
  }
}</code></pre>
<h3 id="4、ejs"><a href="#4、ejs" class="headerlink" title="4、ejs"></a>4、ejs</h3><pre><code class="ejs"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    这是ejs演示代码
    <br>    
    <%=message%>
</body>
</html>
</code></pre>
<h2 id="2、-注解"><a href="#2、-注解" class="headerlink" title="2、 注解"></a>2、 注解</h2><p>注解：即为一个个单独的包装函数，含有特定的实现功能，和java里面Spring一样表示为“@functionName()”,并且多个注解之间没有影响，只是集成所有方法的功能。</p>
<h2 id="3、服务"><a href="#3、服务" class="headerlink" title="3、服务"></a>3、服务</h2><h3 id="1、创建服务"><a href="#1、创建服务" class="headerlink" title="1、创建服务"></a><strong>1、创建服务</strong></h3><pre><code class="shell">nest g service news</code></pre>
<p>创建好服务后就可以在服务中定义对应的方法</p>
<pre><code class="javascript">    import { Injectable } from '@nestjs/common';

    @Injectable()
    export class NewsService {    
        findAll(){    
            return [
                {"title":"新闻1"},
                {"title":"新闻2"},
            ];
        }
    }
</code></pre>
<h3 id="2、使用服务"><a href="#2、使用服务" class="headerlink" title="2、使用服务"></a><strong>2、使用服务</strong></h3><p>1、需要在根模块引入并配置</p>
<pre><code class="javascript">import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserController } from './user/user.controller';
import { NewsService } from './news/news.service';
import { NewsController } from './news/news.controller';
import { ArticleController } from './article/article.controller';

@Module({
  imports: [],
  controllers: [AppController, UserController, NewsController, ArticleController],
  providers: [AppService, NewsService],
})
export class AppModule {}</code></pre>
<p>2、在用到的地方引入并配置</p>
<pre><code class="javascript">    import { Controller, Get ,Render} from '@nestjs/common';

    import { NewsService } from './news.service';

    @Controller('news')
    export class NewsController {

        constructor(private newsServices:NewsService){}

        @Get()
        @Render('default/news')
        index(){
            return {
                newsList:this.newsServices.findAll()
            }
        }
    }
</code></pre>
<h2 id="4-、控制器"><a href="#4-、控制器" class="headerlink" title="4 、控制器"></a>4 、控制器</h2><p>控制器注解@Controller(),控制层负责处理传入的HTTP请求。在Nest中，控制器是一个带有<code>@Controller()</code>装饰器的类。</p>
<pre><code class="javascript">import { Controller, Get, Post, HttpStatus } from '@nestjs/common';

@Controller('users')
export class UsersController {
    @Get('')  // /user
    getAllUsers() {}

    @Get(':id') // user/01
    getUser() {}

    @Post('') // /user
    addUser() {}
}</code></pre>
<blockquote>
<p>获取传值注解</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Nest</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Request() / @Req()</td>
<td>req</td>
</tr>
<tr>
<td align="left">@Response() @Res()</td>
<td>res</td>
</tr>
<tr>
<td align="left">@Next()</td>
<td>next</td>
</tr>
<tr>
<td align="left">@Session()</td>
<td>res.session</td>
</tr>
<tr>
<td align="left">@Param(param?:string)</td>
<td>req.params[param]</td>
</tr>
<tr>
<td align="left">@Body(param?: string)</td>
<td>req.body[param]</td>
</tr>
<tr>
<td align="left">@Query(param?: string)</td>
<td>req.query[param]</td>
</tr>
<tr>
<td align="left">@Headers(param?: string)</td>
<td>req.headers[param]</td>
</tr>
</tbody></table>
<h2 id="5、Session"><a href="#5、Session" class="headerlink" title="5、Session"></a>5、Session</h2><p>session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中</p>
<h3 id="1、express-session-使用"><a href="#1、express-session-使用" class="headerlink" title="1、express-session 使用"></a>1、express-session 使用</h3><p><strong>1.安装 express-session</strong></p>
<pre><code class="shell">cnpm install express-session  --save</code></pre>
<p><strong>2.引入express-session</strong></p>
<pre><code class="shell">import * as session from 'express-session';</code></pre>
<p><strong>3.配置session中间件</strong></p>
<pre><code class="javascript"> app.use(session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}))</code></pre>
<p><strong>4.nestjs中使用session</strong></p>
<pre><code class="javascript">设置值 req.session.username = "张三";
获取值 req.session.username            </code></pre>
<h3 id="2、express-session参数"><a href="#2、express-session参数" class="headerlink" title="2、express-session参数"></a>2、express-session参数</h3><pre><code class="json">secret    一个String类型的字符串，作为服务器端生成session的签名。 
name    返回客户端的key的名称，默认为connect.sid,也可以自己设置。 
resave    强制保存session即使它并没有变化,。默认为true。建议设置成false。 don't save session if unmodified 
saveUninitialized    强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于
未初始化状态。在设定一个cookie前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）。建议手动添加。
cookie    设置返回到前端key的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
rolling    在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</code></pre>
<pre><code class="javascript">app.use(session({
  secret: '12345',
  name: 'name',
  cookie: {maxAge: 60000},
  resave: false,
  saveUninitialized: true
}));</code></pre>
<h3 id="3、express-session方法"><a href="#3、express-session方法" class="headerlink" title="3、express-session方法"></a>3、express-session方法</h3><pre><code class="javascript">req.session.destroy(function(err) {   /*销毁session*/})
req.session.username='张三';     //设置session
req.session.username            //获取session
req.session.cookie.maxAge=0;    //重新设置cookie的过期时间</code></pre>
<h2 id="6、文件上传"><a href="#6、文件上传" class="headerlink" title="6、文件上传"></a>6、文件上传</h2><p>Nestjs内置了文件上传的方法，Nestjs中通过file-upload可以实现单文件上传，多文件上传</p>
<p>Nestjs <a href="https://docs.nestjs.com/techniques/file-upload" target="_blank" rel="noopener">file-upload官方文档</a></p>
<h3 id="1、前端代码"><a href="#1、前端代码" class="headerlink" title="1、前端代码"></a><strong>1、前端代码</strong></h3><p>上传图片的时候From表单中需要配置<strong>enctype=”multipart/form-data”</strong></p>
<pre><code class="ejs">    <form action="user/add" method="post" enctype="multipart/form-data">    
        <input type="text" name="title1" id="" placeholder="新闻标题"/>    

        <input type="text" name="keywords" id="" placeholder="关键词"/>       

        <input type="text" name="author" id="" placeholder="作者" />

        <input type="file" name="pic" id="" />

        <input type="text" name="status" id="" placeholder="状态" />       

        <input type="submit" value="提交">        
    </form></code></pre>
<h3 id="2、后端代码"><a href="#2、后端代码" class="headerlink" title="2、后端代码"></a><strong>2、后端代码</strong></h3><pre><code class="javascript">import { 
        Controller, 
        Get, 
        Render, 
        Post,
        UseInterceptors,
        UploadedFile
        } from '@nestjs/common';
import { FileInterceptor,FilesInterceptor } from '@nestjs/platform-express';
@Post('doAdd')
@UseInterceptors(FileInterceptor('pic'))
addUser(@UploadedFile() file,@Body() body){
        console.log(body); 
        console.log(file);     
        const writeImage = createWriteStream(join(__dirname, '..','../public/upload', `${file.originalname}`))
        writeImage.write(file.buffer)
        return '上传成功';
}</code></pre>
<p><strong>3、nestjs多文件上传</strong></p>
<pre><code class="javascript">import { 
        Controller, 
        Get, 
        Render, 
        Post,
        UseInterceptors,
        UploadedFiles
        } from '@nestjs/common';
import { FileInterceptor,FilesInterceptor } from '@nestjs/platform-express';
@Post('doAddAll')
@UseInterceptors(FilesInterceptor('pic'))
addAllUser(@UploadedFiles() files,@Body() body){
for (const file of files) {
    const writeImage = 
createWriteStream(join(__dirname, '../../', 'public/upload', `${body.name}-${Date.now()}-${file.originalname}`));
    writeImage.write(file.buffer);
}
  return '上传成功';
}</code></pre>
<h2 id="7、中间件"><a href="#7、中间件" class="headerlink" title="7、中间件"></a>7、中间件</h2><h3 id="1、创建中间件"><a href="#1、创建中间件" class="headerlink" title="1、创建中间件"></a><strong>1、创建中间件</strong></h3><pre><code class="powershell">nest g middleware init</code></pre>
<pre><code class="javascript">
import { Injectable, NestMiddleware } from '@nestjs/common';
@Injectable()
export class InitMiddleware implements NestMiddleware {
  use(req: any, res: any, next: () => void) {
    console.log('init');
    next();
  }
}</code></pre>
<h3 id="2、配置单中间件"><a href="#2、配置单中间件" class="headerlink" title="2、配置单中间件"></a><strong>2、配置单中间件</strong></h3><p>在app.module.ts中继承NestModule然后配置中间件</p>
<pre><code class="javascript">export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        consumer
        .apply(InitMiddleware)
        .forRoutes({ path: '*', method: RequestMethod.ALL })
        .apply(NewsMiddleware)
        .forRoutes({ path: 'news', method: RequestMethod.ALL })
        .apply(UserMiddleware)
        .forRoutes(
            { path: 'user', method: RequestMethod.GET },                                
            { path: '', method: RequestMethod.GET });
    }
}</code></pre>
<h3 id="2、配置多中间件"><a href="#2、配置多中间件" class="headerlink" title="2、配置多中间件"></a>2、配置多中间件</h3><pre><code class="javascript">consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);</code></pre>
<h3 id="3、函数式中间件"><a href="#3、函数式中间件" class="headerlink" title="3、函数式中间件"></a>3、函数式中间件</h3><pre><code class="javascript">export function logger(req, res, next) {
    console.log(`Request...`);
    next();
};</code></pre>
<h3 id="4、全局中间件"><a href="#4、全局中间件" class="headerlink" title="4、全局中间件"></a>4、全局中间件</h3><pre><code class="javascript">const app = await NestFactory.create(ApplicationModule);
app.use(logger);
await app.listen(3000);</code></pre>
<h2 id="8、管道"><a href="#8、管道" class="headerlink" title="8、管道"></a>8、管道</h2><p>文档：<a href="https://docs.nestjs.com/pipes" target="_blank" rel="noopener">Nestjs-Pipe</a></p>
<p>通俗的讲:Nestjs中的管道可以将输入数据转换为所需的输出。此外，它也可以处理验证，当数据不正确时可能会抛出异常。也可以是过滤filters函数。</p>
<pre><code class="javascript">const data = {...}
const filterData = data.filter((item)=>return item typeof 'string')</code></pre>
<h3 id="1、创建管道"><a href="#1、创建管道" class="headerlink" title="1、创建管道"></a><strong>1、创建管道</strong></h3><pre><code class="shell">nest g pipe user  //ng g pipe  pip/user</code></pre>
<p>管道创建完成后生成如下代码：</p>
<pre><code class="javascript">import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
@Injectable()
export class UserPipe implements PipeTransform {
        transform(value: any, metadata: ArgumentMetadata) {
        //这个里面可以修改传入的值以及验证转入值的合法性
        return value;
    }
}</code></pre>
<h3 id="2、使用管道"><a href="#2、使用管道" class="headerlink" title="2、使用管道"></a><strong>2、使用管道</strong></h3><pre><code class="javascript">import { Controller,Get,UsePipes,Query} from '@nestjs/common';
import {UserPipe} from '../../user.pipe';
@Controller('user')
export class UserController {    
    @Get()
    index(){
        return '用户页面';
    }
    @Get('pipe')
    @UsePipes(new UserPipe())
    pipe(@Query() info){
        console.log(info);
        return `this is Pipe`;
    }
}</code></pre>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（一）</title>
    <url>/2020/04/03/Nest-Dev-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-6-x-快速指南"><a href="#Nest-6-x-快速指南" class="headerlink" title="Nest 6.x 快速指南"></a>Nest 6.x 快速指南</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Nest 是一个用于构建高效，可扩展的 <a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js</a> 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript</a>，结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。</p>
<h2 id="2、特征"><a href="#2、特征" class="headerlink" title="2、特征"></a>2、特征</h2><p>模块、控制器、组件</p>
<ul>
<li>框架</li>
</ul>
<p>Nest是一个渐进的Node.js框架，可以在TypeScript和JavaScript (ES6、ES7、ES8)之上构建高效、可伸缩的企业级服务器端应用程序。</p>
<ul>
<li>哲学</li>
</ul>
<p>Nest 提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</p>
<ul>
<li>平台无关</li>
</ul>
<p>技术上讲，Nest 可以在创建适配器后使用任何 Node HTTP 框架。 有两个支持开箱即用的 HTTP 平台：express 和 fastify。 您可以选择最适合您需求的产品。</p>
<ul>
<li>理念</li>
</ul>
<p>在设计上的很多灵感来自于 Angular，Angular 的很多模式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以我们也可以认为： Nest 是 Node.js 版的 Spring 框架。</p>
<h2 id="3、NestJS和Egg-js-的一些简单对比"><a href="#3、NestJS和Egg-js-的一些简单对比" class="headerlink" title="3、NestJS和Egg.js 的一些简单对比"></a>3、NestJS和Egg.js <strong>的一些简单对比</strong></h2><blockquote>
<ol>
<li>Egg.js 是和 Nest.js 都是为企业级框架和应用而生。 </li>
<li>Egg.js 和 Nest.js 都是非常优秀的 Nodejs 框架。Egg.js 基于 Koa，Nest.js 默认基于 </li>
<li>Express，nest 也可以基于其他框架 </li>
<li>Egg.j<strong>s</strong> 文档相比 <strong>Nestjs</strong> 优秀很多 </li>
<li>Express、Koa 是 Node.js 社区广泛使用的框架，简单且扩展性强，非常适合做个 </li>
<li>人项目。但框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 和 Nestjs </li>
<li>都是按照约定进行开发的。但是 Egg 相比 Nestjs 约定更标准。 </li>
<li>面向对象方面 Nestjs 优于 Egg.js，Nestjs 基于 TypeScript，如果你会 angular 或者 java </li>
<li>学习 Nestjs 非常容易。 </li>
</ol>
</blockquote>
<ul>
<li><p><strong>Egg.js</strong> <strong>的特性：</strong> </p>
<p>提供基于 Egg 定制上层框架的能力高度可扩展的插件机制 </p>
<p>内置多进程管理 </p>
<p>基于 Koa 开发，性能优异 </p>
<p>框架稳定，测试覆盖率高 </p>
<p>渐进式开发 </p>
</li>
</ul>
<p>  <strong>Nestjs</strong> <strong>的特性：</strong> </p>
<p>  依赖注入容器 </p>
<p>  模块化封装 </p>
<p>  可测试性 </p>
<p>  内置支持 TypeScript </p>
<p>  可基于 Express 或者 fastify</p>
<h2 id="3、创建项目"><a href="#3、创建项目" class="headerlink" title="3、创建项目"></a>3、创建项目</h2><p>首先，您可以使用 Nest CLI 构建项目，也可以克隆启动项目（两者都会产生相同的结果）。</p>
<p>要使用 Nest CLI 构建项目，请运行以下命令。这将创建一个新的项目目录，并生成 Nest 核心文件和支持模块，为您的项目创建传统的基础结构。建议初学者使用Nest CLI 创建新项目。我们将在<a href="https://www.bookstack.cn/read/nest-6/$6-firststeps?id=第一步" target="_blank" rel="noopener">第一步</a>继续使用这种方法。</p>
<ul>
<li><h4 id="使用-CLI-安装"><a href="#使用-CLI-安装" class="headerlink" title="使用 CLI 安装"></a>使用 CLI 安装</h4></li>
</ul>
<pre><code class="shell">$ npm i -g @nestjs/cli$ 
$ nest new project-name</code></pre>
<ul>
<li><h4 id="使用-Git-安装"><a href="#使用-Git-安装" class="headerlink" title="使用 Git 安装"></a><strong>使用 Git 安装</strong></h4></li>
</ul>
<pre><code class="shell">$ git clone https://github.com/nestjs/typescript-starter.git project
$ cd project
$ npm install
$ npm run start</code></pre>
<h2 id="4、常用命令"><a href="#4、常用命令" class="headerlink" title="4、常用命令"></a>4、常用命令</h2><p>基于nest-cli脚手架工具我们可以快速的创建项目所需要的组件，该命令与angulr-cli极其相似，大致命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nest  g  service   “路径/服务名称”</td>
<td>创建一个服务</td>
</tr>
<tr>
<td>nest  g  module   “路径/模块名称”</td>
<td>创建一个模块</td>
</tr>
<tr>
<td>nest  g  pip”路径/管道名称”</td>
<td>创建一个管道</td>
</tr>
<tr>
<td>nest  g  provider”路径/服务提供者名称”</td>
<td>创建一个服务提供者</td>
</tr>
<tr>
<td>nest  g  controller”路径/控制器名称”</td>
<td>创建一个控制器</td>
</tr>
<tr>
<td>···</td>
<td>···</td>
</tr>
</tbody></table>
<h2 id="5、工程解释"><a href="#5、工程解释" class="headerlink" title="5、工程解释"></a>5、工程解释</h2><blockquote>
<p>入口文件main.ts</p>
</blockquote>
<pre><code class="typescript">import { NestFactory } from '@nestjs/core';
import * as rateLimit from 'express-rate-limit';
import * as compression from 'compression';
import * as helmet from 'helmet';
import { TransformInterceptor } from './interceptors/transform.interceptor';
import { HttpExceptionFilter } from './filters/http-exception.filter';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
async function bootstrap() {
  const app = await NestFactory.create<nestexpressapplication>(AppModule);
  app.enableCors();
  app.setGlobalPrefix('/api'); //设置全局请求前置
  app.use(
    rateLimit({
      windowMs: 60 * 1000, // 1 minutes
      max: 1000, // limit each IP to 1000 requests per windowMs
    })
  );
  app.use(compression()); // 启用 gzip 压缩
  app.use(helmet());
  app.useGlobalInterceptors(new TransformInterceptor()); // 正常情况下，响应值统一
  app.useGlobalFilters(new HttpExceptionFilter()); // 异常情况下，响应值统一
  app.useStaticAssets('public') //配置静态资源访问地址
  // 配置swagger-ui接口文档
  const options = new DocumentBuilder()   //实例化swagger 文档
    .setTitle('网站后台管理系统与前端页面接口文档') //设置文档标题
    .setDescription('网站后台管理系统与前端页面接口文档') //设置文档描述
    .setVersion('1.0.0') //设置文档版本
    // .addTag('Next与Nest建站') //设置文档标签
    .build(); //执行构建
  const document = SwaggerModule.createDocument(app, options);
  SwaggerModule.setup('api-docs', app, document);   //设置本地访问地址
  await app.listen(4000);  //设置服务监听端口
}

bootstrap();</nestexpressapplication></code></pre>
<p>要创建一个 Nest 应用实例，我们使用了 <code>NestFactory</code> 核心类。<code>NestFactory</code> 暴露了一些静态方法用于创建应用实例。 <code>create()</code> 方法返回一个实现 <code>INestApplication</code> 接口的对象, 并提供一组可用的方法, 在后面的章节中将对此进行详细描述。 在上面的main.ts示例中，我们只是启动 HTTP 服务器，它允许应用程序等待入站 HTTP 请求。</p>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>愚人节？我们是认真的</title>
    <url>/2020/04/01/2020foolsday/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>  生活会有岁月静好，我也愿意为你负重前行；那一刻，这一刻，以后的每个时刻，是因为我而你感到幸福快乐。行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，爱过一个正当最好年龄的人。要和你闻闻新鲜的春天，感受阳关洒满肩头的夏天，整个世界涂满金色的秋天，充满童话飘雪纯白的冬天。“愚”你同在，陪你同行，我们是认真的～</p>
<!-- ![markdown](http://q7hgnfyvz.bkt.clouddn.com/avater.png) -->
<a href="./avater.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img align="center" width="60%" data-src="./avater.png" class="lazyload"></a></body></html>]]></content>
  </entry>
  <entry>
    <title>Flutter-Template开发规范(Flutter-go)</title>
    <url>/2020/03/30/flutter-dev-standard/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Flutter-Template开发规范-Flutter-go"><a href="#Flutter-Template开发规范-Flutter-go" class="headerlink" title="Flutter-Template开发规范(Flutter-go)"></a>Flutter-Template开发规范(Flutter-go)</h1><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="标识符三种类型"><a href="#标识符三种类型" class="headerlink" title="标识符三种类型"></a>标识符三种类型</h3><h4 id="大驼峰"><a href="#大驼峰" class="headerlink" title="大驼峰"></a>大驼峰</h4><p>类、枚举、typedef和类型参数</p>
<pre><code class="dart">  class SliderMenu { ... }

  class HttpRequest { ... }

  typedef Predicate = bool Function<t>(T value);</t></code></pre>
<p>包括用于元数据注释的类</p>
<pre><code class="dart">  class Foo {
    const Foo([arg]);
  }

  @Foo(anArg)
  class A { ... }

  @Foo()
  class B { ... }</code></pre>
<h4 id="使用小写加下划线来命名库和源文件"><a href="#使用小写加下划线来命名库和源文件" class="headerlink" title="使用小写加下划线来命名库和源文件"></a>使用小写加下划线来命名库和源文件</h4><pre><code class="dart">  library peg_parser.source_scanner;

  import 'file_system.dart';
  import 'slider_menu.dart';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  library pegparser.SourceScanner;

  import 'file-system.dart';
  import 'SliderMenu.dart';</code></pre>
<h4 id="使用小写加下划线来命名导入前缀"><a href="#使用小写加下划线来命名导入前缀" class="headerlink" title="使用小写加下划线来命名导入前缀"></a>使用小写加下划线来命名导入前缀</h4><pre><code class="dart">  import 'dart:math' as math;
  import 'package:angular_components/angular_components'
      as angular_components;
  import 'package:js/js.dart' as js;</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  import 'dart:math' as Math;
  import 'package:angular_components/angular_components'
      as angularComponents;
  import 'package:js/js.dart' as JS;</code></pre>
<h4 id="使用小驼峰法命名其他标识符"><a href="#使用小驼峰法命名其他标识符" class="headerlink" title="使用小驼峰法命名其他标识符"></a>使用小驼峰法命名其他标识符</h4><pre><code class="javascript">  var item;

  HttpRequest httpRequest;

  void align(bool clearItems) {
    // ...
  }</code></pre>
<h4 id="优先使用小驼峰法作为常量命名"><a href="#优先使用小驼峰法作为常量命名" class="headerlink" title="优先使用小驼峰法作为常量命名"></a>优先使用小驼峰法作为常量命名</h4><pre><code class="dart">  const pi = 3.14;
  const defaultTimeout = 1000;
  final urlScheme = RegExp('^([a-z]+):');

  class Dice {
    static final numberGenerator = Random();
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  const PI = 3.14;
  const DefaultTimeout = 1000;
  final URL_SCHEME = RegExp('^([a-z]+):');

  class Dice {
    static final NUMBER_GENERATOR = Random();
  }</code></pre>
<h4 id="不使用前缀字母"><a href="#不使用前缀字母" class="headerlink" title="不使用前缀字母"></a>不使用前缀字母</h4><p>因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。</p>
<pre><code class="javascript">  defaultTimeout</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="javascript">  kDefaultTimeout</code></pre>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p>
<h4 id="在其他引入之前引入所需的dart库"><a href="#在其他引入之前引入所需的dart库" class="headerlink" title="在其他引入之前引入所需的dart库"></a>在其他引入之前引入所需的dart库</h4><pre><code class="dart">  import 'dart:async';
  import 'dart:html';

  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';</code></pre>
<h4 id="在相对引入之前先引入在包中的库"><a href="#在相对引入之前先引入在包中的库" class="headerlink" title="在相对引入之前先引入在包中的库"></a>在相对引入之前先引入在包中的库</h4><pre><code class="dart">  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';

  import 'util.dart';</code></pre>
<h4 id="第三方包的导入先于其他包"><a href="#第三方包的导入先于其他包" class="headerlink" title="第三方包的导入先于其他包"></a>第三方包的导入先于其他包</h4><pre><code class="dart">  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';

  import 'package:my_package/util.dart';</code></pre>
<h4 id="在所有导入之后，在单独的部分中指定导出"><a href="#在所有导入之后，在单独的部分中指定导出" class="headerlink" title="在所有导入之后，在单独的部分中指定导出"></a>在所有导入之后，在单独的部分中指定导出</h4><pre><code class="dart">  import 'src/error.dart';
  import 'src/foo_bar.dart';

  export 'src/error.dart';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  import 'src/error.dart';
  export 'src/error.dart';
  import 'src/foo_bar.dart';</code></pre>
<h3 id="所有流控制结构，请使用大括号"><a href="#所有流控制结构，请使用大括号" class="headerlink" title="所有流控制结构，请使用大括号"></a>所有流控制结构，请使用大括号</h3><p>这样做可以避免悬浮的else问题</p>
<pre><code class="dart">  if (isWeekDay) {
    print('Bike to work!');
  } else {
    print('Go dancing or read a book!');
  }</code></pre>
<h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号</p>
<pre><code class="dart">  if (arg == null) return defaultValue;</code></pre>
<p>如果流程体超出了一行需要分划请使用大括号：</p>
<pre><code class="dart">  if (overflowChars != other.overflowChars) {
    return overflowChars < other.overflowChars;
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  if (overflowChars != other.overflowChars)
    return overflowChars < other.overflowChars;</code></pre>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="要像句子一样格式化"><a href="#要像句子一样格式化" class="headerlink" title="要像句子一样格式化"></a>要像句子一样格式化</h3><p>除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。</p>
<pre><code class="dart">  greet(name) {
    // Assume we have a valid name.
    print('Hi, $name!');
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  greet(name) {
    /* Assume we have a valid name. */
    print('Hi, $name!');
  }</code></pre>
<p>可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用//</p>
<h3 id="Doc注释"><a href="#Doc注释" class="headerlink" title="Doc注释"></a>Doc注释</h3><p>使用///文档注释来记录成员和类型。</p>
<p>使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。</p>
<pre><code class="dart">  /// The number of characters in this chunk when unsplit.
  int get length => ...</code></pre>
<blockquote>
<p>由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/<strong>…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/</strong>和<em>/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用</em>标记列表项的项目符号列表。</p>
</blockquote>
<h3 id="考虑为私有api编写文档注释"><a href="#考虑为私有api编写文档注释" class="headerlink" title="考虑为私有api编写文档注释"></a>考虑为私有api编写文档注释</h3><p>Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员</p>
<h4 id="用一句话总结开始doc注释"><a href="#用一句话总结开始doc注释" class="headerlink" title="用一句话总结开始doc注释"></a>用一句话总结开始doc注释</h4><p>以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。</p>
<pre><code class="dart">/// Deletes the file at [path] from the file system.
void delete(String path) {
  ...
}</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  /// Depending on the state of the file system and the user's permissions,
  /// certain operations may or may not be possible. If there is no file at
  /// [path] or it can't be accessed, this function throws either [IOError]
  /// or [PermissionError], respectively. Otherwise, this deletes the file.
  void delete(String path) {
    ...
  }</code></pre>
<h4 id="“doc注释”的第一句话分隔成自己的段落"><a href="#“doc注释”的第一句话分隔成自己的段落" class="headerlink" title="“doc注释”的第一句话分隔成自己的段落"></a>“doc注释”的第一句话分隔成自己的段落</h4><p>在第一个句子之后添加一个空行，把它分成自己的段落</p>
<pre><code class="dart">  /// Deletes the file at [path].
  ///
  /// Throws an [IOError] if the file could not be found. Throws a
  /// [PermissionError] if the file is present but could not be deleted.
  void delete(String path) {
    ...
  }</code></pre>
<h2 id="Flutter-Go-使用参考"><a href="#Flutter-Go-使用参考" class="headerlink" title="Flutter_Go 使用参考"></a>Flutter_Go 使用参考</h2><h3 id="库的引用"><a href="#库的引用" class="headerlink" title="库的引用"></a>库的引用</h3><p>flutter go 中，导入lib下文件库，统一指定包名，避免过多的<code>../../</code></p>
<pre><code class="dart">package:flutter_go/</code></pre>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="使用相邻字符串连接字符串文字"><a href="#使用相邻字符串连接字符串文字" class="headerlink" title="使用相邻字符串连接字符串文字"></a>使用相邻字符串连接字符串文字</h4><p>如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。</p>
<pre><code class="dart">raiseAlarm(
    'ERROR: Parts of the spaceship are on fire. Other '
    'parts are overrun by martians. Unclear which are which.');</code></pre>
<p>不推荐如下写法:</p>
<pre><code class="dart">raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' +
    'parts are overrun by martians. Unclear which are which.');</code></pre>
<h4 id="优先使用模板字符串"><a href="#优先使用模板字符串" class="headerlink" title="优先使用模板字符串"></a>优先使用模板字符串</h4><pre><code class="dart">'Hello, $name! You are ${year - birth} years old.';</code></pre>
<h4 id="在不需要的时候，避免使用花括号"><a href="#在不需要的时候，避免使用花括号" class="headerlink" title="在不需要的时候，避免使用花括号"></a>在不需要的时候，避免使用花括号</h4><pre><code class="dart">  'Hi, $name!'
  "Wear your wildest $decade's outfit."</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  'Hi, ${name}!'
  "Wear your wildest ${decade}'s outfit."</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="尽可能使用集合字面量"><a href="#尽可能使用集合字面量" class="headerlink" title="尽可能使用集合字面量"></a>尽可能使用集合字面量</h4><p>如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。</p>
<pre><code class="dart">  var points = [];
  var addresses = {};
  var lines = <lines>[];</lines></code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  var points = List();
  var addresses = Map();</code></pre>
<h4 id="不要使用-length查看集合是否为空"><a href="#不要使用-length查看集合是否为空" class="headerlink" title="不要使用.length查看集合是否为空"></a>不要使用.length查看集合是否为空</h4><pre><code class="dart">if (lunchBox.isEmpty) return 'so hungry...';
if (words.isNotEmpty) return words.join(' ');</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  if (lunchBox.length == 0) return 'so hungry...';
  if (!words.isEmpty) return words.join(' ');</code></pre>
<h4 id="考虑使用高阶方法转换序列"><a href="#考虑使用高阶方法转换序列" class="headerlink" title="考虑使用高阶方法转换序列"></a>考虑使用高阶方法转换序列</h4><p>如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性</p>
<pre><code class="dart">  var aquaticNames = animals
      .where((animal) => animal.isAquatic)
      .map((animal) => animal.name);</code></pre>
<h4 id="避免使用带有函数字面量的Iterable-forEach"><a href="#避免使用带有函数字面量的Iterable-forEach" class="headerlink" title="避免使用带有函数字面量的Iterable.forEach()"></a>避免使用带有函数字面量的Iterable.forEach()</h4><p>在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。</p>
<pre><code class="dart">for (var person in people) {
  ...
}</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  people.forEach((person) {
    ...
  });</code></pre>
<h4 id="不要使用List-from-，除非打算更改结果的类型"><a href="#不要使用List-from-，除非打算更改结果的类型" class="headerlink" title="不要使用List.from()，除非打算更改结果的类型"></a>不要使用List.from()，除非打算更改结果的类型</h4><p>给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表</p>
<pre><code class="dart">var copy1 = iterable.toList();
var copy2 = List.from(iterable);</code></pre>
<p>明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数</p>
<pre><code class="dart">// Creates a List<int>:
var iterable = [1, 2, 3];

// Prints "List<int>":
print(iterable.toList().runtimeType);</int></int></code></pre>
<pre><code class="dart">// Creates a List<int>:
var iterable = [1, 2, 3];

// Prints "List<dynamic>":
print(List.from(iterable).runtimeType);</dynamic></int></code></pre>
<h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><h4 id="使用-将命名参数与其默认值分割开"><a href="#使用-将命名参数与其默认值分割开" class="headerlink" title="使用=将命名参数与其默认值分割开"></a>使用=将命名参数与其默认值分割开</h4><p>由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。</p>
<pre><code class="dart">  void insert(Object item, {int at = 0}) { ... }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  void insert(Object item, {int at: 0}) { ... }</code></pre>
<h4 id="不要使用显式默认值null"><a href="#不要使用显式默认值null" class="headerlink" title="不要使用显式默认值null"></a>不要使用显式默认值null</h4><p>如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它</p>
<pre><code class="dart">void error([String message]) {
  stderr.write(message ?? '\n');
}</code></pre>
<p>不推荐如下写法:</p>
<pre><code class="dart">void error([String message = null]) {
  stderr.write(message ?? '\n');
}</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="不要显式地将变量初始化为空"><a href="#不要显式地将变量初始化为空" class="headerlink" title="不要显式地将变量初始化为空"></a>不要显式地将变量初始化为空</h4><p>在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null</p>
<pre><code class="dart">  int _nextId;

  class LazyId {
    int _id;

    int get id {
      if (_nextId == null) _nextId = 0;
      if (_id == null) _id = _nextId++;

      return _id;
    }
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  int _nextId = null;

  class LazyId {
    int _id = null;

    int get id {
      if (_nextId == null) _nextId = 0;
      if (_id == null) _id = _nextId++;

      return _id;
    }
  }</code></pre>
<h4 id="避免储存你能计算的东西"><a href="#避免储存你能计算的东西" class="headerlink" title="避免储存你能计算的东西"></a>避免储存你能计算的东西</h4><p>在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们:</p>
<p>应该避免的写法：</p>
<pre><code class="dart">  class Circle {
    num radius;
    num area;
    num circumference;

    Circle(num radius)
        : radius = radius,
          area = pi * radius * radius,
          circumference = pi * 2.0 * radius;
  }</code></pre>
<p>如上代码问题：</p>
<ul>
<li>浪费内存</li>
<li>缓存的问题是无效——如何知道何时缓存过期需要重新计算？</li>
</ul>
<p>推荐的写法如下：</p>
<pre><code class="dart">  class Circle {
    num radius;

    Circle(this.radius);

    num get area => pi * radius * radius;
    num get circumference => pi * 2.0 * radius;
  }</code></pre>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="不要把不必要地将字段包装在getter和setter中"><a href="#不要把不必要地将字段包装在getter和setter中" class="headerlink" title="不要把不必要地将字段包装在getter和setter中"></a>不要把不必要地将字段包装在getter和setter中</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var _contents;
    get contents => _contents;
    set contents(value) {
      _contents = value;
    }
  }</code></pre>
<h4 id="优先使用final字段来创建只读属性"><a href="#优先使用final字段来创建只读属性" class="headerlink" title="优先使用final字段来创建只读属性"></a>优先使用final字段来创建只读属性</h4><p>尤其对于 <code>StatelessWidget</code></p>
<h4 id="在不需要的时候不要用this"><a href="#在不需要的时候不要用this" class="headerlink" title="在不需要的时候不要用this"></a>在不需要的时候不要用this</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var value;

    void clear() {
      this.update(null);
    }

    void update(value) {
      this.value = value;
    }
  }</code></pre>
<p>推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var value;

    void clear() {
      update(null);
    }

    void update(value) {
      this.value = value;
    }
  }</code></pre>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="尽可能使用初始化的形式"><a href="#尽可能使用初始化的形式" class="headerlink" title="尽可能使用初始化的形式"></a>尽可能使用初始化的形式</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Point {
    num x, y;
    Point(num x, num y) {
      this.x = x;
      this.y = y;
    }
  }</code></pre>
<p>推荐如下写法：</p>
<pre><code class="dart">class Point {
  num x, y;
  Point(this.x, this.y);
}</code></pre>
<h4 id="不要使用new"><a href="#不要使用new" class="headerlink" title="不要使用new"></a>不要使用new</h4><p>Dart2使new 关键字可选</p>
<p>推荐写法：</p>
<pre><code class="dart">  Widget build(BuildContext context) {
    return Row(
      children: [
        RaisedButton(
          child: Text('Increment'),
        ),
        Text('Click!'),
      ],
    );
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  Widget build(BuildContext context) {
    return new Row(
      children: [
        new RaisedButton(
          child: new Text('Increment'),
        ),
        new Text('Click!'),
      ],
    );
  }</code></pre>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="优先使用async-await代替原始的futures"><a href="#优先使用async-await代替原始的futures" class="headerlink" title="优先使用async/await代替原始的futures"></a>优先使用async/await代替原始的futures</h4><p>async/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。</p>
<pre><code class="dart">  Future<int> countActivePlayers(String teamName) async {
    try {
      var team = await downloadTeam(teamName);
      if (team == null) return 0;

      var players = await team.roster;
      return players.where((player) => player.isActive).length;
    } catch (e) {
      log.error(e);
      return 0;
    }
  }</int></code></pre>
<h4 id="当异步没有任何用处时，不要使用它"><a href="#当异步没有任何用处时，不要使用它" class="headerlink" title="当异步没有任何用处时，不要使用它"></a>当异步没有任何用处时，不要使用它</h4><p>如果可以在不改变函数行为的情况下省略异步，那么就这样做。、</p>
<pre><code class="dart">  Future afterTwoThings(Future first, Future second) {
    return Future.wait([first, second]);
  }</code></pre>
<p>不推荐写法：</p>
<pre><code class="dart">  Future afterTwoThings(Future first, Future second) async {
    return Future.wait([first, second]);
  }</code></pre>
</body></html>]]></content>
  </entry>
  <entry>
    <title>前端骨架屏生成技术揭秘</title>
    <url>/2020/03/25/Front-End-Skeleton/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- # 前端骨架屏生成技术揭秘 -->

</head><body><h1 id="1-为什么要使用骨架屏"><a href="#1-为什么要使用骨架屏" class="headerlink" title="1. 为什么要使用骨架屏"></a>1. 为什么要使用骨架屏</h1><p>骨架屏就是在页面数据尚未加载前，先给用户展示出页面的大致结构（灰色占位图），直到请求数据返回后再渲染页面，补充进需要显示的数据内容，考拉H5购物车就使用了骨架屏技术：</p>
<p><a href="./1.gif" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="./1.gif" class="lazyload"></a></p>
<p>了解了骨架屏是什么，我们来看看为什么要使用骨架屏。 假如能在加载前把网页的大概轮廓预先显示，接着再逐渐加载真正内容，这样既降低了用户的焦灼情绪，又能使界面加载过程变得自然通畅，不会造成网页长时间白屏或者闪烁。骨架屏能给人一种页面内容“已经渲染出一部分”的感觉，相较于传统的 loading 效果，在一定程度上可<strong>提升用户体验</strong>。尤其在下面场景中，骨架屏技术能极大提高用户体验：</p>
<ul>
<li>网络较慢，需要长时间等待加载处理的情况下。</li>
<li>图文信息内容较多的列表/卡片中。</li>
<li>首屏加载数据量较大的时候。</li>
</ul>
<h1 id="2-骨架屏技术总览"><a href="#2-骨架屏技术总览" class="headerlink" title="2. 骨架屏技术总览"></a>2. 骨架屏技术总览</h1><p>目前主流的骨架屏生成技术主要包括以下三种：</p>
<ol>
<li>通过设计师给出的骨架屏图片。</li>
<li>通过 HTML+CSS 编写骨架屏代码。</li>
<li>非侵入式自动生成骨架屏代码。</li>
</ol>
<p>前两种情况由于变更成本和续维护成本高，且对业务代码有一定侵入性，不进行讨论。业界对于自动生成骨架屏有多种实践，但是存在一些问题，有些配置较少，生成效果较差；有些操作繁琐，项目集成成本高，且难以定制。</p>
<p>本文主要针对自动生成骨架屏技术进行了深入的探讨，并开发了 awesome-skeleton，支持多种配置，以及骨架屏定制功能，并提供骨架图生成和骨架图模板注入能力。</p>
<h1 id="3-自动生成骨架屏技术揭秘"><a href="#3-自动生成骨架屏技术揭秘" class="headerlink" title="3. 自动生成骨架屏技术揭秘"></a>3. 自动生成骨架屏技术揭秘</h1><p>谷歌浏览器在2017年自行开发了 Chrome Headless 特性，并与之同时推出了 Puppeteer。Puppeteer 是一个 Node库，提供了一组用来操纵 Chrome 的 API，默认 Headless 也就是无界面的chrome，俗称“无头浏览器”。我们在浏览器中完成的大多数操作都可以在 Puppeteer 中完成，比如截图、爬虫、自动化测试、性能分析等。</p>
<p>借助 Puppeteer，我们对自动生成骨架屏方案进行了如下设计：</p>
<ul>
<li>使用 Puppeteer 进行页面渲染，获取页面 DOM 结构；</li>
<li>命令行工具生成骨架屏代码，并支持第三方平台接入；</li>
<li>支持页面登录态、不同设备页面显示、列表重复渲染、骨架屏灰色块大小配置；</li>
<li>支持骨架屏图片压缩和代码自动生成；</li>
<li>通过 DOM 属性进行骨架屏细粒度的配置，指定节点配置，包括背景色、是否在骨架屏中显示等。</li>
</ul>
<p>我们可以通过传入页面地址，使用无头浏览器打开页面，对页面首屏图片和文本等节点进行灰色背景处理，然后对页面首屏进行截图，生成压缩后的 base64 png 图片，并注入 HTML + CSS，从而自动生成页面骨架屏。流程见下图：</p>
<p><a href="./2.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./2.jpg" class="lazyload"></a></p>
<h2 id="3-1-使用-Puppeteer-渲染页面"><a href="#3-1-使用-Puppeteer-渲染页面" class="headerlink" title="3.1 使用 Puppeteer 渲染页面"></a>3.1 使用 Puppeteer 渲染页面</h2><p>使用 Puppeteer 可以指定不同设备模拟器来渲染页面，从而获取页面的 DOM 结构。关键代码：</p>
<pre><code class="javascript">// 初始化无头浏览器
const browser = await puppeteer.launch({
  headless: !options.debug, // 是否打开无头浏览器
  args: [ '--no-sandbox', '--disable-setuid-sandbox' ],
});
// 打开新页面
const page = await browser.newPage();
// 指定设备模拟器
const device = devices[options.device] || desktopDevice;
await page.emulate(device);
// 打开指定页面
await page.goto(options.pageUrl);</code></pre>
<p>获取到页面 DOM 结构之后，需要对其进行处理，例如将图片转换为灰色色块，隐藏大小小于一定阈值的节点，这里我们通过向页面中动态插入一端 JavaScript 脚本，对页面节点进行处理，从而生成骨架屏。关键代码：</p>
<pre><code class="javascript">// 获取处理 DOM 节点的脚本代码
const scriptContent = await genScriptContent();
// 将代码插入到页面中
await page.addScriptTag({ content: scriptContent });</code></pre>
<h2 id="3-2-页面-DOM-处理"><a href="#3-2-页面-DOM-处理" class="headerlink" title="3.2 页面 DOM 处理"></a>3.2 页面 DOM 处理</h2><p>下面我们来重点看看如何对页面节点进行处理，主要包括以下内容：</p>
<p><a href="./3.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./3.jpg" class="lazyload"></a></p>
<h3 id="3-2-1-预处理"><a href="#3-2-1-预处理" class="headerlink" title="3.2.1 预处理"></a>3.2.1 预处理</h3><p>首先，对页面所有节点进行下列处理：</p>
<ul>
<li>置空所有大小小于指定阈值的节点</li>
<li>所有节点背景图设置为 none，并且将背景色设置为骨架屏主色调（灰色）</li>
<li>所有节点阴影、边框颜色设置为主色调</li>
<li>置空所有标签中含有 “data-skeleton-empty” 属性的节点</li>
<li>若节点设置了“data-skeleton-bgcolo”，则选取其属性值来设置背景色。### 文本处理 本文处理是所有节点中比较复杂的一种，需要考虑文本是一行还是多行、文本是位置是居中还是左对齐等，通过获取文本位置和样式，通过简单的计算来设置灰色色块位置。下面只列出了关键代码，全部代码见：text.js。</li>
</ul>
<pre><code class="javascript">// 获取行高
if (!/\d/.test(lineHeight)) {
  const fontSizeNum = parseInt(fontSize, 10) || 14;
  lineHeight = `${fontSizeNum * 1.4}px`;
}
// 获取行数
let lineCount = (height - parseFloat(paddingTop, 10) - parseFloat(paddingBottom, 10)) / parseFloat(lineHeight, 10) || 0;
lineCount = lineCount < 1.5 ? 1 : lineCount;
// 设置文本色块样式
ele.classList.add(SKELETON_TEXT_CLASS);
Object.assign(ele.style, {
  backgroundImage: `linear-gradient(
  transparent ${(1 - textHeightRatio) / 2 * 100}%,
  ${MAIN_COLOR} 0%,
  ${MAIN_COLOR} ${((1 - textHeightRatio) / 2 + textHeightRatio) * 100}%,
  transparent 0%
  )`,
  backgroundSize: `100% ${px2rem(parseInt(lineHeight) * 1.1)}`,
  position,
});
// 添加文本Mask
if (lineCount > 1) { // 多行情况特殊处理
  addTextMask(ele, Object.assign(JSON.parse(JSON.stringify(comStyle)), {
    lineHeight,
  }));
} else { // 单行文本处理
  const textWidthPercent = textWidth / (width - parseInt(paddingRight, 10) - parseInt(paddingLeft, 10));
  ele.style.backgroundSize = `${textWidthPercent * 100}% 100%`;
  switch (textAlign) {
    case 'left':
      break;
    case 'right':
      ele.style.backgroundPositionX = '100%';
      break;
    default: // center
      ele.style.backgroundPositionX = '50%';
      break;
  }
}</code></pre>
<h3 id="3-2-2-列表处理"><a href="#3-2-2-列表处理" class="headerlink" title="3.2.2 列表处理"></a>3.2.2 列表处理</h3><p>可以根据配置，对列表进行重复处理，也就是根据列表的第一项重复渲染其他项，关键代码：</p>
<pre><code class="javascript">const listHandler = (node, options) => {
  if (!options.openRepeatList || !node.children.length) return;
  const children = node.children;
  const len = Array.from(children).filter(child => LIST_ITEM_TAG.indexOf(child.tagName) > -1).length;
  if (len === 0) return false;
  const firstChild = children[0];
  // 若元素不是列表节点，则递归处理
  if (LIST_ITEM_TAG.indexOf(firstChild.tagName) === -1) {
    return listHandler(firstChild, options);
  }
  // 只保留第一个项目
  Array.from(children).forEach((li, index) => {
    if (index > 0) {
      removeElement(li);
    }
  });
  // 重复渲染剩余项
  for (let i = 1; i < len; i++) {
    node.appendChild(firstChild.cloneNode(true));
  }
};</code></pre>
<h3 id="3-2-3-其他节点"><a href="#3-2-3-其他节点" class="headerlink" title="3.2.3 其他节点"></a>3.2.3 其他节点</h3><p>其他节点的处理较为简单，有兴趣可以在 Github 上查看代码，这里有几个需要关注的点：</p>
<ul>
<li>a 标签需要移除 href 属性</li>
<li>button 标签需要设置宽高，保证在移除按钮文案后宽高不变</li>
<li>img 标签也需要设置宽高，并将 src 设置为 1px 的 base64</li>
<li>input 标签需要移除 placeholder</li>
<li>伪元素同样需要处理。</li>
</ul>
<h3 id="3-2-4-文本类型特殊处理"><a href="#3-2-4-文本类型特殊处理" class="headerlink" title="3.2.4 文本类型特殊处理"></a>3.2.4 文本类型特殊处理</h3><p>需要注意的是，对于文本节点，由于存在下面的情况，所以需要进行特殊处理：</p>
<pre><code class="html"><span>111<a>222</a></span> 文本中包含超链接
<span>111<a href="xx" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="xx" class="lazyload"></a></span> 文本中包含图片
111 文本没有使用标签包裹</code></pre>
<p>文本类型进行处理的关键代码：</p>
<pre><code class="javascript">handleText(node) {
  const tagName = node.tagName && node.tagName.toUpperCase();
  // 处理 <div>xxx</div> or <a>xxx</a>
  if (node.childNodes && node.childNodes.length === 1 && node.childNodes[0].nodeType === 3) {
    handler.text(node, this.options);
    return true;
  }
  // 处理 xxx，转换为 <i>xxx</i>
  if (node && node.nodeType === 3 && node.textContent) {
    const parent = node.parentNode;
    // Determine if it has been processed
    if (!parent.classList.contains(SKELETON_TEXT_CLASS)) {
      // It is plain text itself and needs to be replaced with a node
      const textContent = node.textContent.replace(/[\r\n]/g, '').trim();
      if (textContent) {
        const tmpNode = document.createElement('i');
        tmpNode.classList.add(SKELETON_TEXT_CLASS);
        tmpNode.innerText = textContent;
        node.parentNode.replaceChild(tmpNode, node);
        handler.text(tmpNode, this.options);
        return true;
      }
    }
  }
  // 处理 <span>111<a>222</a></span> <span>111<a href="xx" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="xx" class="lazyload"></a></span>
  if (tagName === 'SPAN' && node.innerHTML) {
    // Process image and background image first
    this.handleImages(node.childNodes);
    handler.text(node, this.options);
    return true;
  }
  return false;
}</code></pre>
<h3 id="3-2-5-处理页面节点入口函数"><a href="#3-2-5-处理页面节点入口函数" class="headerlink" title="3.2.5 处理页面节点入口函数"></a>3.2.5 处理页面节点入口函数</h3><p>有些上述单个节点的处理函数，我们可以遍历页面所有节点进行处理。关键代码：</p>
<pre><code class="javascript">handleNode(node) {
  if (!node) return;
  // Delete elements that are not in first screen, or marked for deletion
  if (!inViewPort(node) || hasAttr(node, 'data-skeleton-remove')) {
    return removeElement(node);
  }
  // Handling elements that are ignored by user tags -> End
  const ignore = hasAttr(node, 'data-skeleton-ignore') || node.tagName === 'STYLE';
  if (ignore) return;
  // Preprocessing some styles
  handler.before(node, this.options);
  // Preprocessing pseudo-class style
  handler.pseudo(node, this.options);
  const tagName = node.tagName && node.tagName.toUpperCase();
  const isBtn = tagName && (tagName === 'BUTTON' || /(btn)|(button)/g.test(node.getAttribute('class')));
  let isCompleted = false;
  switch (tagName) {
    case 'SCRIPT':
      handler.script(node);
      break;
    case 'IMG':
      handler.img(node);
      break;
    case 'SVG':
      handler.svg(node);
      break;
    case 'INPUT':
      handler.input(node);
      break;
    case 'BUTTON': // Button processing ends once
      handler.button(node);
      break;
    case 'UL':
    case 'OL':
    case 'DL':
      handler.list(node, this.options);
      break;
    case 'A': // A label processing is placed behind to prevent IMG from displaying an exception
      handler.a(node);
      break;
    default:
      break;
  }
  if (isBtn) {
    handler.button(node);
  } else {
    isCompleted = this.handleText(node);
  }
  // If it is a button and has not been processed by handleText, then the child node is processed
  if (!isBtn && !isCompleted) {
    this.handleNodes(node.childNodes); // 递归处理
  }
}</code></pre>
<h3 id="3-2-6-使用-rollup-打包脚本"><a href="#3-2-6-使用-rollup-打包脚本" class="headerlink" title="3.2.6 使用 rollup 打包脚本"></a>3.2.6 使用 rollup 打包脚本</h3><p>由于对页面节点处理的脚本使用 es6 语法编写， 我们需要在插入页面之前，进行编译：</p>
<pre><code class="javascript">// rollup.config.js
export default {
  input: 'src/script/main.js',
  output: {
    file: 'src/script/dist/index.js',
    format: 'iife',
    name: 'AwesomeSkeleton',
  },
};
</code></pre>
<p><strong>3.3 生成骨架屏代码</strong></p>
<p>生成处理页面节点脚本之后，插入到页面中，这个时候需要一些钩子来执行页面DOM的处理。我们定义一个全局对象 AwesomeSkeleton，其中包含 genSkeleton 方法，调用后会处理页面节点。</p>
<pre><code class="javascript">window.AwesomeSkeleton = {
  // Entry function
  async genSkeleton(options) {
    this.options = options;
    if (options.debug) {
      await this.debugGenSkeleton(options);
    } else {
      await this.startGenSkeleton(); // 生成骨架屏
    }
  },
  // Start generating the skeleton
  async startGenSkeleton() {
    this.init();
    try {
      this.handleNode(document.body);
    } catch (e) {
      console.log('==genSkeleton Error==\n', e.message, e.stack);
    }
  },
  ...
}</code></pre>
<p>在使用 puppeteer 打开页面之后，我们注入了 rollup 打包后的脚本，这时候我们需要执行脚本才能生成骨架屏：</p>
<pre><code class="javascript">await page.evaluate(async options => {
  await window.AwesomeSkeleton.genSkeleton(options);
}, options);</code></pre>
<p>生成骨架屏后，我们通过调用 puppeteer 的截图接口，生成骨架屏图片，并使用 images 包进行图片压缩，生成 base64，从而生成骨架屏代码。</p>
<pre><code class="javascript">// First screen skeleton screenshot
await page.screenshot({
  path: screenshotPath,
});
const imgWidth = options.device ? 375 : 1920;
// Use images for image compression
await images(screenshotPath).size(imgWidth).save(screenshotPath);
const skeletonImageBase64 = base64Img.base64Sync(screenshotPath);
// Inject the skeleton into the desired page
const result = insertSkeleton(skeletonImageBase64, options);</code></pre>
<p><strong>4. 使用 awesome-skeleton</strong></p>
<p>通过上述讨论的技术方案，我们实现了 awesome-skeleton 骨架屏生成工具。支持命令行生成骨架屏代码，同时也可以非常方便的在第三方平台接入。</p>
<h2 id="4-1-参数配置"><a href="#4-1-参数配置" class="headerlink" title="4.1 参数配置"></a>4.1 参数配置</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>必填</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pageUrl</td>
<td>是</td>
<td>-</td>
<td>页面地址（此地址必须可访问）</td>
</tr>
<tr>
<td>pageName</td>
<td>否</td>
<td>output</td>
<td>页面名称（仅限英文）</td>
</tr>
<tr>
<td>cookies</td>
<td>否</td>
<td></td>
<td>页面 Cookies，用来解决登录态问题</td>
</tr>
<tr>
<td>outputPath</td>
<td>否</td>
<td>skeleton-output</td>
<td>骨架图文件输出文件夹路径，默认到项目 skeleton-output 中</td>
</tr>
<tr>
<td>openRepeatList</td>
<td>否</td>
<td>true</td>
<td>默认会将每个列表的第一项进行复制</td>
</tr>
<tr>
<td>device</td>
<td>否</td>
<td>PC</td>
<td>参考 puppeteer/DeviceDescriptors.js，可以设置为 ‘iPhone 6 Plus’</td>
</tr>
<tr>
<td>debug</td>
<td>否</td>
<td>false</td>
<td>是否开启调试开关</td>
</tr>
<tr>
<td>debugTime</td>
<td>否</td>
<td>0</td>
<td>调试模式下，页面停留在骨架图的时间</td>
</tr>
<tr>
<td>minGrayBlockWidth</td>
<td>否</td>
<td>0</td>
<td>最小处理灰色块的宽度</td>
</tr>
<tr>
<td>minGrayPseudoWidth</td>
<td>否</td>
<td>0</td>
<td>最小处理伪类宽</td>
</tr>
</tbody></table>
<p>例如添加 skeleton.config.json，生成考拉首页在 iphone X 下的骨架屏。</p>
<pre><code class="json">{
  "pageName": "baidu",
  "pageUrl": "https://www.kaola.com",
  "openRepeatList": false,
  "device": "iPhone X",
  "minGrayBlockWidth": 80,
  "minGrayPseudoWidth": 10,
  "debug": true,
  "debugTime": 3000
}
</code></pre>
<h2 id="4-2-一键生成骨架屏"><a href="#4-2-一键生成骨架屏" class="headerlink" title="4.2 一键生成骨架屏"></a>4.2 一键生成骨架屏</h2><pre><code class="javascript">skeleton -c ./skeleton.config.json</code></pre>
<p>页面 DomReady 之后，会在页面顶部出现红色按钮：开始生成骨架屏。</p>
<p>生成完成后，会在运行目录生成 skeleton-output 文件件，里面包括骨架屏 png 图片、base64 文本、html 文件：</p>
<ul>
<li>base64-baidu.png # 骨架图图片</li>
<li>base64-baidu.txt # 骨架图 Base64 编码</li>
<li>base64-baidu.html # 最终生成 HTML</li>
</ul>
<p>其中 html 文件可以直接拿来用，复制下面位置：</p>
<pre><code class="html">
  
    <!--- 骨架屏代码 -->
  
</code></pre>
<p>注意：</p>
<ul>
<li>骨架图默认在 onload 事件后销毁。</li>
<li>手动销毁方式：<code>javascript window.SKELETON && SKELETON.destroy();</code> 当然，你也可以在项目中直接使用生成的 Base64 图片。</li>
</ul>
<h2 id="4-3-解决登录问题"><a href="#4-3-解决登录问题" class="headerlink" title="4.3 解决登录问题"></a>4.3 解决登录问题</h2><p>如果页面需要登录，则需要下载 Chrome 插件 EditThisCookie，将 Cookie 复制到配置参数中。Puppeteer 通过在打开页面的时候注入 Cookie 从而模拟登录态：</p>
<pre><code class="javascript">// Write cookies to solve the login status problem
if (options.cookies && options.cookies.length) {
  await page.setCookie(...options.cookies);
  await page.cookies(options.pageUrl);
  await sleep(1000);
}</code></pre>
<h2 id="4-4-DOM-节点配置"><a href="#4-4-DOM-节点配置" class="headerlink" title="4.4 DOM 节点配置"></a>4.4 DOM 节点配置</h2><p>这是获取优质骨架图的要点，通过设置以下几个 dom 节点属性，在骨架图中对某些节点进行移除、忽略和指定背景色的操作，去除冗余节点的干扰，从而使得骨架图效果达到最佳。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>data-skeleton-remove</td>
<td>指定进行移除的 dom 节点属性</td>
</tr>
<tr>
<td>data-skeleton-bgcolor</td>
<td>指定在某 dom 节点中添加的背景色</td>
</tr>
<tr>
<td>data-skeleton-ignore</td>
<td>指定忽略不进行任何处理的 dom 节点属性</td>
</tr>
<tr>
<td>data-skeleton-empty</td>
<td>将某dom的innerHTML置为空字符串</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code><div data-skeleton-remove>
    <span>abc</span>
</div>
<div data-skeleton-bgcolor="#EE00EE">
    <span>abc</span>
</div>
<div data-skeleton-ignore>
    <span>abc</span>
</div>
<div data-skeleton-empty>
    <span>abc</span>
</div></code></pre><h1 id="5-开发骨架屏生成平台"><a href="#5-开发骨架屏生成平台" class="headerlink" title="5. 开发骨架屏生成平台"></a>5. 开发骨架屏生成平台</h1><p>有了骨架屏生成工具，我们可以非常方便的接入第三方平台，例如我们使用 egg.js 开发骨架屏生成平台，用户输入页面链接，自动生成对应骨架屏。关键代码：</p>
<pre><code class="javascript">const getSkeleton = require('awesome-skeleton');
class SkeletonService extends Service {
  async generator(params) {
    try {
      const result = await getSkeleton(params);
      return {
        success: true,
        ...result,
      };
    } catch (e) {
            ...
    }
  }
}

</code></pre>
<p>页面效果：</p>
<p><a href="./4.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./4.jpg" class="lazyload"></a></p>
<p>骨架屏配置：</p>
<p><a href="./5.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./5.jpg" class="lazyload"></a></p>
<h1 id="6-参与贡献"><a href="#6-参与贡献" class="headerlink" title="6. 参与贡献"></a>6. 参与贡献</h1><p>Github：<a href="https://github.com/kaola-fed/awesome-skeleton" target="_blank" rel="noopener">https://github.com/kaola-fed/awesome-skeleton</a></p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>骨架屏</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>舒适访问对象深层次属性~</title>
    <url>/2020/03/24/TypeScript-GetObjectPrpos/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="舒适访问对象深层次属性"><a href="#舒适访问对象深层次属性" class="headerlink" title="舒适访问对象深层次属性~"></a>舒适访问对象深层次属性~</h2><h3 id="一、黑暗时代"><a href="#一、黑暗时代" class="headerlink" title="一、黑暗时代"></a>一、黑暗时代</h3><p>​        在前后端分离的系统中，前端页面一般通过调用 REST API 来获取服务端提供的与页面相关的数据。这里我们以获取用户基本信息的接口为例，假设该接口会返回以下数据：</p>
<pre><code>const apiResult = {
  code: 200,
  data: {
    name: "Semlinker",
    age: 30,
    address: {
      province: '福建',
      city: '厦门'
    }
  }
}</code></pre><p>如果页面中需要显示当前用户的地址信息，比如省、市信息。这时就可以通过以下方式来获取：</p>
<pre><code>const province = apiResult.data.address.province; // 福建
const city = apiResult.data.address.city; // 厦门</code></pre><p>上面的数据访问方式很直观，就是一层层的进行数据访问。然而这种方式会存在很大的隐患，比如有的用户可能未设置地址信息，那么这时候的返回的数据结构就可能是这样的：</p>
<pre><code>const apiResult = {
  code: 200,
  data: {
    name: "Semlinker",
    age: 30
  }
}</code></pre><p>这时如果我们还是使用 <code>apiResult.data.address.province</code> 的方式来访问 <code>province</code> 省份信息，页面就会抛出以下异常信息：</p>
<pre><code>Uncaught TypeError: Cannot read property 'province' of undefined</code></pre><p>针对这个问题，我们有以下几种解决方案：</p>
<p><strong>方案一：</strong></p>
<pre><code>const province =
  apiResult &&
  apiResult.data &&
  apiResult.data.address &&
  apiResult.data.address.province;</code></pre><p><strong>方案二：</strong></p>
<pre><code>const province = !apiResult
  ? undefined
  : !apiResult.data
    ? undefined
    : !apiResult.data.address
      ? undefined
      : apiResult.data.address.province;</code></pre><p><strong>方案三：</strong></p>
<pre><code>let province: string | undefined = undefined;
try {
  province = apiResult.data.address.province;
} catch (error) {
  // 执行异常处理程序
}</code></pre><p><strong>方案四：</strong></p>
<pre><code>import * as _ from 'lodash';
const province = _.get(apiResult, 'data.address.province', undefined);</code></pre><p>通过观察以上几种方案，我们发现处理多级嵌套对象的属性访问时，需要增加很多的判断逻辑，这对于我们开发者来说，是很令人抓狂的事情。值得庆幸的是，在 TypeScript 3.7 以后版本，我们就可以使用可选链（Optional Chaining）来优雅的解决上述问题。</p>
<h3 id="二、什么是可选链"><a href="#二、什么是可选链" class="headerlink" title="二、什么是可选链"></a>二、什么是可选链</h3><p>TypeScript 3.7 实现了呼声最高的 ECMAScript 功能之一：可选链（Optional Chaining）。有了可选链后，我们编写代码时如果遇到 <code>null</code> 或 <code>undefined</code> 就可以立即停止某些表达式的运行。可选链的核心是新的 <code>?.</code> 运算符，它支持以下语法：</p>
<blockquote>
<pre><code>obj?.prop
obj?.[expr]
arr?.[index]
func?.(args)</code></pre></blockquote>
<p>这里我们来举一个可选的属性访问的例子：</p>
<pre><code>const val = a?.b;</code></pre><p>为了更好的理解可选链，我们来看一下该 <code>const val = a?.b</code> 语句编译生成的 ES5 代码：</p>
<pre><code>var val = a === null || a === void 0 ? void 0 : a.b;</code></pre><p>上述的代码会自动检查对象 a 是否为 <code>null</code> 或 <code>undefined</code>，如果是的话就立即返回 <code>undefined</code>，这样就可以立即停止某些表达式的运行。介绍完可选链，前面获取省份的例子，就可以改写成以下方式：</p>
<pre><code>const province = apiResult?.data?.address?.province;</code></pre><p>同样，我们再来看一下该语句生成的 ES5 代码：</p>
<pre><code>var province = (_b = (_a = apiResult === null || apiResult === void 0 ? void 0 :
  apiResult.data) === null || _a === void 0 ? void 0 : _a.address) === null ||
    _b === void 0 ? void 0 : _b.province;</code></pre><p>对比编译前的 TypeScript 代码和编译后的 JavaScript 代码，你是不是感受到了可选链是多么的给力。</p>
<h3 id="三、-与-amp-amp-的区别"><a href="#三、-与-amp-amp-的区别" class="headerlink" title="三、?. 与 && 的区别"></a>三、?. 与 && 的区别</h3><p>你可能已经发现你可以使用 <code>?.</code> 来替代很多使用 <code>&&</code> 执行空检查的代码：</p>
<pre><code>if(a && a.b) { }

if(a?.b){ }
/**
* if(a?.b){ } 编译后的ES5代码
*
* if(
*  a === null || a === void 0
*  ? void 0 : a.b) {
* }
*/</code></pre><p>但需要注意的是，<code>?.</code> 与 <code>&&</code> 运算符行为略有不同，<code>&&</code> 专门用于检测 <code>falsy</code>值，比如空字符串、0、NaN、null 和 false 等。而 <code>?.</code> 只会验证对象是否为<code>null</code> 或 <code>undefined</code>，对于 0 或空字符串来说，并不会出现 “短路”。</p>
<h3 id="四、可选元素访问"><a href="#四、可选元素访问" class="headerlink" title="四、可选元素访问"></a>四、可选元素访问</h3><p>可选链除了支持可选属性的访问之外，它还支持可选元素的访问，它的行为类似于可选属性的访问，只是可选元素的访问允许我们访问非标识符的属性，比如任意字符串、数字索引和 Symbol：</p>
<pre><code>function tryGetArrayElement<t>(arr?: T[], index: number = 0) {
    return arr?.[index];
}</t></code></pre><p>以上代码经过编译后会生成以下 ES5 代码：</p>
<pre><code>function tryGetArrayElement(arr, index) {
    if (index === void 0) { index = 0; }
    return arr === null || arr === void 0 ? void 0 : arr[index];
}</code></pre><p>通过观察生成的 ES5 代码，很明显在 <code>tryGetArrayElement</code> 方法中会自动检测输入参数 arr 的值是否为 <code>null</code> 和 <code>undefined</code>，从而保证了我们代码的健壮性。最后我们来介绍一下可选链与函数调用。</p>
<h3 id="五、可选链与函数调用"><a href="#五、可选链与函数调用" class="headerlink" title="五、可选链与函数调用"></a>五、可选链与函数调用</h3><p>当尝试调用一个可能不存在的方法时也可以使用可选链。在实际开发过程中，这是很有用的。系统中某个方法不可用，有可能是由于版本不一致或者用户设备兼容性问题导致的。函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回 <code>undefined</code> 而不是抛出一个异常。</p>
<p>可选调用使用起来也很简单，比如：</p>
<pre><code>let result = obj.customMethod?.();</code></pre><p>该 TypeScript 代码编译生成的 ES5 代码如下：</p>
<pre><code>var result = (_a = obj.customMethod) === null
  || _a === void 0 ? void 0 : _a.call(obj);</code></pre><p>另外在使用可选调用的时候，我们要注意以下两个注意事项：</p>
<ol>
<li>如果存在一个属性名且该属性名对应的值不是函数类型，使用 <code>?.</code> 仍然会产生一个<code>TypeError</code> 异常。</li>
<li>可选链的运算行为被局限在属性的访问、调用以及元素的访问 —— 它不会沿伸到后续的表达式中，也就是说可选调用不会阻止 <code>a?.b / someMethod()</code> 表达式中的除法运算或 <code>someMethod</code> 的方法调用。</li>
</ol>
<h3 id="六、参考资源"><a href="#六、参考资源" class="headerlink" title="六、参考资源"></a>六、参考资源</h3><ul>
<li>Using Optional Chaining in TypeScript and JavaScript</li>
<li>optional-chaining-in-typescript</li>
<li>深入理解 TypeScript</li>
<li>重磅！TypeScript 3.7 RC 发布，备受瞩目的 Optional Chaining 来了</li>
<li>MDN - 可选链</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ts</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>瞎说“进程，线程，异步协程”</title>
    <url>/2020/03/23/Back-End-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="进程，线程，异步协程"><a href="#进程，线程，异步协程" class="headerlink" title="进程，线程，异步协程"></a>进程，线程，异步协程</h1><p>本文记录一下自己对线程，进程，协程的理解。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><pre><code>狭义的进程可以代表一个应用程序的执行过程，比如我们打开任务管理器，可以看到很多程序在运行，这些都可以都可以说是一个个进程。

广义的进程指的是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</code></pre><blockquote>
<p>进程的概念主要有两点</p>
</blockquote>
<ul>
<li>进程是一个实体，每一个进程都有其自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。</li>
<li>进程是”执行中的程序”，一个程序不运行就是个空壳，只有经过运行，让处理器赋予其地址，给其生命，它才是一个实体，也就是一个进程。</li>
</ul>
<blockquote>
<p>进程的状态</p>
</blockquote>
<ul>
<li>就绪，指其获取了除CPU之外的所有资源，只要CPU分配资源就可以运行。</li>
<li>运行，也就是就绪之后获得了CPU分配的资源，可以执行操作</li>
<li>阻塞，当条件不足（比如说缺少某些插件，资源之类）此时称为阻塞态。</li>
</ul>
<blockquote>
<p>进程的特征</p>
</blockquote>
<ul>
<li>动态性，进程是程序的一次执行，有其生命期，不是永生的<br>并发行，任何进程都可以和其他进程一起执行（一个健壮的程序不止一个进程，只能同时运行一个程序的电脑和板砖有什么区别）</li>
<li>独立性，进程是系统进行资源分配和调度的一个独立单位</li>
<li>进程由程序、数据和进程控制块三部分组成。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
</blockquote>
<ul>
<li>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。<br>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了，于是就发明了线程。</li>
</ul>
<blockquote>
<p>线程特征：</p>
</blockquote>
<ul>
<li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；<br>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</li>
</ul>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>通常程序至少一个进程，一个进程最少一个线程，进程是分配资源的最小单位，线程是CPU调度的最小单位。</li>
<li>资源（内存、寄存器等）分配给进程，进程在执行过程拥有独立的内存空间，而同一进程下的所有线程共享所有资源，从而提高程序的运行效率；</li>
<li>处理机分配给线程，即处理机真正运行的是线程；</li>
<li>线程在执行过程中，需要协作同步。不同线程间的要利用通信协议来实现同步。</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote>
<p>协程，使用一个线程去完成多个任务，可以理解成微线程。</p>
</blockquote>
<p>  协程的调度完全由用户控制，相对独立，有自己的上下文。一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被阻塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非阻塞的且没有相互依赖，协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高。</p>
<blockquote>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程</p>
</blockquote>
<p>注：协程不是真正的多线程。</p>
<h2 id="多进程？多线程？"><a href="#多进程？多线程？" class="headerlink" title="多进程？多线程？"></a>多进程？多线程？</h2><p>  前文说到，进程是操作系统进行资源分配的最小单位，那么在同一时间，同一设备，运行至少两个的进程，这就是多任务操作系统（不然怎么满足大众需求）<br>  那么这里就出现问题了，我们人不能一心二用，而一直模仿人类的计算机显然也不可以，原则上一个CPU只能分配资源给一个进程，但我们常用的电脑都是单CPU,怎么实现多进程的呢，这就是“并发”。具体理论很复杂，可以理解为轮流使用CPU,每个进程只占用几毫秒，以人类的反应速度是无法感觉出来，实现一种很多进程同时运行的假象，但同一时间只有一个进程获得了CPU的使用权，多核CPU可以实现同时运行多个进程即——并行。但显然我们电脑的CPU数目远远小于我们运行的任务数，那么——并发还需仔细研究。</p>
<p>  在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。<br>  但由于共享资源，如果多个线程同时运行，而且访问同一个资源，那么就会报错。所以就有了所谓的“锁”，线程运行时将资源锁定，执行结束再释放，使其他线程来使用这部分资源，所以多线程的程序可以充分的利用CPU的资源，大大减少响应的时间，使得运行效率大大提高，而且由于使用统一的内存，减少了数据的传送困难，方便不同任务的协调操作和运行，数据交互问题会更容易解决。</p>
<p>  多进程和多线程，是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p>
<ul>
<li><p>要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。      </p>
</li>
<li><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
</li>
<li><p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
</li>
<li><p>多进程 优点 是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
</li>
<li><p>多进程 缺点 是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。还有一个不足之处，多进程下程序与各进程之间的通信和数据共享不方便；</p>
</li>
<li><p>多线程 优点 通常比多进程快一点，但是也快不到哪去，开销小！</p>
</li>
<li><p>多线程主要是为了节约CPU时间，为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率！</p>
</li>
<li><p>多线程 缺点 任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
</li>
</ul>
<p>  多任务操作系统(如Windows)的基本原理是：操作系统将CPU的时间片分配给多个线程，每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的)。操作系统不断的从一个线程的执行切换到另一个线程的执行，如此往复，宏观上看来,就好像是多个线程在一起执行。由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务。</p>
<p>  那么多任务并发，可以充分发挥CPU资源，那么是不是并发量越大越好。当然不是，因为切换任务需要一定的消耗，少的时候看不出来，当达到某个临界值，那么卡顿就伴随而来。</p>
<ul>
<li>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</li>
</ul>
<h2 id="I-O-以及同步异步"><a href="#I-O-以及同步异步" class="headerlink" title="I/O 以及同步异步"></a>I/O 以及同步异步</h2><blockquote>
<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。但由于硬件等的差距，两者的运行效率是不一样的，甚至差距很大，这时有两种方式。</p>
</blockquote>
<ul>
<li>同步，即CPU等待程序完成任务，再继续其他操作</li>
<li>异步，即把当前任务挂载，CPU去执行其他任务</li>
</ul>
<p>   显然异步很优秀，但异步编程模型相对复杂，异步IO复杂度远远高于同步</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><blockquote>
<p>同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。<br>    按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。<br>    但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。<br>    最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对处理完消息之前，这个函数不返回。<br>    当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p>
</blockquote>
<h3 id="异步的概念和同步相对"><a href="#异步的概念和同步相对" class="headerlink" title="异步的概念和同步相对"></a>异步的概念和同步相对</h3><blockquote>
<p> 当一个异步过程调用发出后，调用者不会立刻得到结果。<br>    实际处理这个调用的部件是在调用发出后，<br>    通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
</blockquote>
<pre><code>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。

现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。

对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</code></pre><h2 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h2><p>  这是程序等待消息时的状态，不妨想一下同步异步是什么。<br>  阻塞调用是指结果返回之前，进程会被挂起，函数得到结果后才能返回（注，阻塞不等同于同步）<br>  非阻塞就是未得到结果之前，该函数不会阻塞当前进程，而立即返回<br>其实他们还可以结合</p>
<ul>
<li>同步阻塞</li>
</ul>
<p>效率最低，拿排队来说，就是你专心排队，什么事都不能做。（同步-排队这个进程，阻塞-未排到自己事件不返回）</p>
<ul>
<li>异步阻塞</li>
</ul>
<p>即排队领号之后的人，它不能离开太远也就是被阻塞在这个任务，因为你要等待被叫号（即等待消息解除阻塞状态）</p>
<ul>
<li>同步非阻塞</li>
</ul>
<p>效率也不高，还是排队，这次你可以做别的事了，比如玩个手机，但你要是不是注意是否排到了自己，两种行为切换很多次。</p>
<ul>
<li>异步非阻塞</li>
</ul>
<p>效率最高，你可以任意做其他事（异步），然后坐等柜台通知你去办理业务（非阻塞，未被阻塞在等待的操作上）。</p>
</body></html>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>重go吧!</title>
    <url>/2020/03/22/Java-Standard-Restructure/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h1><p>重构不止是代码整理，它提供了一种高效且受控的代码整理技术。</p>
<h2 id="（一）重构原则"><a href="#（一）重构原则" class="headerlink" title="（一）重构原则"></a>（一）重构原则</h2><h3 id="1、何谓重构"><a href="#1、何谓重构" class="headerlink" title="1、何谓重构"></a>1、何谓重构</h3><p>对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p>
<p>另一种解释是：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<h3 id="2、为何重构"><a href="#2、为何重构" class="headerlink" title="2、为何重构"></a>2、为何重构</h3><p>改进软件设计：如果没有重构，程序的设计会逐渐变质，重构很像是在整理代码，你所做的就是让所有的东西回到应处的位置上。<br>帮助找到bug：对代码进行重构，可以深入理解代码的作为，在搞清楚程序结构的同时，想不把bug揪出来都难。<br>提高编程速度：良好的设计是快速开发的根本，改善设计、提高可读性，减少错误，这些都是提高质量。</p>
<h3 id="3、何时重构"><a href="#3、何时重构" class="headerlink" title="3、何时重构"></a>3、何时重构</h3><p>任何情况下我都反对专门拨出时间进行重构。重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行。</p>
<ul>
<li>三次法则</li>
</ul>
<p>第一次做某件事情是只管去做；第二次做类似的事情会产生反感；第三次再做类似的事，你就应该重构</p>
<p>最常见的重构时机是想给软件添加新特性的时候；</p>
<p>重构的另个一原动力是：代码的设计无法帮助我轻松的添加所需要的特性</p>
<p>修改错误的时候，review代码的时重构</p>
<ul>
<li>间接层和重构</li>
</ul>
<p>计算机科学是这样一门科学：它相信所有的问题都可以通过增加一个间接层来解决。</p>
<p>大多数重构都为程序引入了更多的间接层，重构往往把大型的对象拆成多个小型的对象，把大型的函数拆成多个小型的函数。但是，间接层是一把双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一个对象，程序会愈加难以阅读。</p>
<p>何时不该重构：有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。</p>
<p>重写而非重构的一个清楚讯号是：现有代码根本不能正常运作。</p>
<h2 id="（二）代码的坏味道"><a href="#（二）代码的坏味道" class="headerlink" title="（二）代码的坏味道"></a>（二）代码的坏味道</h2><ul>
<li>1、重复代码</li>
</ul>
<p>如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合二为一，程序会变得更好 。</p>
<p>同一个类中有相同的表达式：提炼出重复的代码，然后让两个地方都调用被提炼出来的那一段代码；</p>
<p>两个互为兄弟的子类内含有相同的表达式：提炼出相同代码，将它推入超类内；</p>
<p>两个毫不相干的类中出现：将重复的代码提炼到一个独立的类中。</p>
<ul>
<li>2、过长的类</li>
</ul>
<p>拥有短函数的对象活得比较好、比较长。间接层所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。</p>
<p>每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。</p>
<p>如何确定提炼哪一段代码？寻找注释是一个很好的技巧。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是提醒你：可以将这段代码替换成一个函数。</p>
<p>条件表达式和循环常常也是提炼的信号。</p>
<ul>
<li>3、过大的类</li>
</ul>
<p>如果想利用单个类做太多的事情，其内往往就会出现太多实力变量。<br>类内如果有太多代码，也是代码重复、混乱病最终走向死亡的源头。</p>
<ul>
<li>4、过长参数列</li>
</ul>
<p>太长的参数列难以理解，太多的参数会造成前后不一致、不容易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要。</p>
<ul>
<li>5、发散式变化</li>
</ul>
<p>如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因为一种变化而需要修改。</p>
<ul>
<li>6、散弹式修改</li>
</ul>
<p>如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。</p>
<p>把所有需要修改的代码放进同一个类中，如果眼下没有合适的类可以安置这些代码就创造一个。</p>
<ul>
<li>7、依恋情结</li>
</ul>
<p>对象技术的要点在于：将数据和对数据的操作行为包装在一起.有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。</p>
<p>一个函数往往会用到几个类的功能，那么它该置于何处？我们的原则是：判断哪个类拥有最大被此函数使用的数据，然后就把这个函数和那些数据放在一起。</p>
<ul>
<li>8、数据泥团</li>
</ul>
<p>很多地方看到相同的三四项数据一起出现。这些总是绑在一起出现的数据应该拥有属于他们自己的对象。</p>
<p>首先找到这些数据以字段形式出现的地方，将它们提炼到一个独立的对象中。这么做的直接好处是可以将很多参数列缩短简化函数调用。</p>
<ul>
<li>9、基本类型偏执</li>
</ul>
<p>对象的一个极大价值在于：它们模糊了横旦与基本数据和体积较大的类之间的界限</p>
<p>对象技术的新手通常不愿意在小任务上运用小对象——结合数值和比重的money类、有一个起始值和一个结束值组成的range类。将原本单独存在的数值替换成对象，从而走出传统的洞窟，进入炙手可热的对象世界。</p>
<ul>
<li>10、switch惊悚现身</li>
</ul>
<p>面向对象的一个最明显的特征是：少用switch语句一看到switch语句，就应该考虑以多态来替换它。</p>
<p>如果只是在单一函数中有些选择实例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。</p>
<ul>
<li>11、平行集成体系</li>
</ul>
<p>每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。<br>消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。</p>
<ul>
<li>12、冗余类</li>
</ul>
<p>某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作，这个时候请让这个类庄严赴义吧。</p>
<ul>
<li>13、夸夸其谈未来性</li>
</ul>
<p>企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种怀味道就出现了。如果用到了那就值得去做，如果用不到那就不值得，只会挡你的路，所以把它挪开吧。</p>
<p>如果你的某个抽象类其实没有起到太大的作用，函数上的某些参数未被使用…可以移除它们了。</p>
<ul>
<li>14、令人迷惑的暂时字段</li>
</ul>
<p>某个实例变量仅为某种特定的情况而设。这样的代码让人不易理解。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。</p>
<ul>
<li>15、过度耦合消息链</li>
</ul>
<p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另个一对象……..这就是消息链。采用这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。</p>
<ul>
<li>16、中间人</li>
</ul>
<p>封装往往伴随着委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。</p>
<ul>
<li>17、狎昵关系</li>
</ul>
<p>有时会看到两个类过于亲密，话费太多的时间去探究彼此的private成分。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。<br>继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让孩子独立生活了，让他离开继承。</p>
<ul>
<li>18、异曲同工的类</li>
</ul>
<p>两个函数做同一件事，却有着不同的签名。</p>
<ul>
<li>19、不完美的类库</li>
</ul>
<p>类库函数构造的不够好，又不能修改它们：</p>
<p>如果只想修改类的一两个函数，可以引入外加函数。如果想要添加一大堆额外行为，建立一个新类包含这些额外行为，让其成为子类。</p>
<ul>
<li>20、纯稚的数据类</li>
</ul>
<p>纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。</p>
<p>封装public字段;<br>恰当封装容器类字段;<br>移除不应修改的字段的设置函数;<br>提炼调用函数以隐藏取值/设值函数;</p>
<ul>
<li>21、被拒绝的遗赠</li>
</ul>
<p>子类只运用了父类的一部分函数和数据。为子类建立一个兄弟类,将所有用不到的字段/函数下移至兄弟类,保证超类的纯粹;</p>
<ul>
<li>22、过多的注释</li>
</ul>
<p>注释之所以存在是因为代码很糟糕 。注释的最高境界——代码即注释。</p>
<p>当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。</p>
<h2 id="（三）重新组织函数"><a href="#（三）重新组织函数" class="headerlink" title="（三）重新组织函数"></a>（三）重新组织函数</h2><ul>
<li>1、提炼函数</li>
</ul>
<p>动机：看到一个过长的函数或者一段需要注释才能让人理解用途的代码，将这段代码放一个独立的函数中；<br>做法：</p>
<p>创造一个新函数，根据这个函数的意图来命名它；</p>
<p>只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果想不到一个更有意义的名称就别动</p>
<p>将提炼的代码从原函数复制到新建的目标函数中；<br>将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；<br>在源函数中，将被提炼代码段替换为目标函数调用。</p>
<ul>
<li>2、内联函数</li>
</ul>
<p>一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。<br>动机：</p>
<p>一群组织不甚合理的函数。你可以将它们都内联到一个大函数中，再从中提炼出组织合理的小型函数。<br>使用的太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在委托动作之间晕头转向。</p>
<blockquote>
<p>做法：<br>1、检查函数，确定不具备多态；<br>如果子类继承了这个函数，就不要将此函数内联，因为子类无法复写一个根本不存在的函数。<br>2、找出这个函数的所有调用点；<br>3、将这个函数的所有调用点都替换成函数本体。</p>
</blockquote>
<ul>
<li>3、内联临时变量</li>
</ul>
<p>有一个临时变量，只被一个简单的表达是赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身</p>
<pre><code>double basePrice = anOrder.basePrice();
return (base > 10000 );</code></pre><p>替换为：</p>
<pre><code>return (anOrder.basePrice > 1000);
</code></pre><ul>
<li>4、以查询取代临时变量</li>
</ul>
<p>你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立的函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</p>
<pre><code>double basePrice = quantity * timePrice;
if(basePrice > 1000){
   return basePrice * 09.5;
} else {
   return basePrice * 0.98;
}</code></pre><p>替换为：</p>
<pre><code>if(basePrice() > 1000){
   return basePrice * 09.5;
} else {
   return basePrice * 0.98;
}
double basePrice(){
   return quantity * timePrice;
}</code></pre><p>临时变量只在所属的函数中可见，如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个份信息，这将带给你极大的帮助，使你能够为这个类编写更清晰的代码。</p>
<ul>
<li>5、引入注释性变量</li>
</ul>
<p>你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p>
<pre><code>if ((platform.toUpperCase().indexOf("MAC") > -1) && (browser.toUpperCase().indexOf("IE") > -1) && wasInitialized() && resize >0){
   //do smothing
}</code></pre><p>替换为：</p>
<pre><code>final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize >0;
if(isMacOs && isIEBrowser && wasInitialized() && wasResized){
   //do smothing
}</code></pre><p>表达式有可能非常复杂难以理解。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。</p>
<p>在条件逻辑中，你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。另一种情况是：在较长的算法中，可以运用临时变量来解释每一步运算的意义。</p>
<ul>
<li>6、分解临时变量</li>
</ul>
<p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。</p>
<pre><code>double temp = 2 * (height + width);
System.out.println(temp);
temp = height * width;
System.out.println(temp);</code></pre><p>替换为：</p>
<pre><code>double perimeter = 2 * (height + width);
System.out.println(perimeter);
double area = height * width;
System.out.println(area);</code></pre><p>如果临时变量被赋值超过一次，就意味着它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换为多个临时变量。每个变量只承担一个责任，同一个临时变量承担两件不同的事情会令代码阅读者糊涂</p>
<ul>
<li>7、移除对参数的赋值</li>
</ul>
<p>代码对一个参数进行复制。以一个临时变量取代该参数的位置。</p>
<pre><code>int discount (int inputVal, int quantity, int yearToData){
   if(inputVal > 50) inputVal -= 2;
}</code></pre><p>替换为：</p>
<pre><code>int discount (int inputVal, int quantity, int yearToData){
   int result = inputVal;
   if(inputVal > 50) result -= 2;
}</code></pre><p>如果代码的语义是按引用传递的，请在调用段检查调用后是否还使用了这个参数。</p>
<ul>
<li>8、替换算法</li>
</ul>
<p>想要把某个算法替换为另一个更清晰的算法。将函数本体替换成为另一个算法。</p>
<pre><code>String foundPerson(String[] people){
   for(int i = 0;i < people.length; i++){
       if(people[i].equals("Don")){
           return "Don";
       }
       if(people[i].equals("John")){
           return "John";
       }
       if(people[i].equals("Kent")){
           return "Kent";
       }
   }
   return "";
}</code></pre><p>替换为：</p>
<pre><code>String foundPerson(String[] people){
   List candidates = Arrays.asList(new String[]{"Don", "John", "Kent"});
   for(int i = 0;i < people.length; i++){
       if(candidates.contains(people[i])){
           return prople[i];
       }
   }
   return "";
}</code></pre><h2 id="（四）在对象之间搬移特性"><a href="#（四）在对象之间搬移特性" class="headerlink" title="（四）在对象之间搬移特性"></a>（四）在对象之间搬移特性</h2><p>在对象设计过程中，决定把责任放在哪儿是即使不是最重要的事，也是最重要的事之一。</p>
<p>常常只使用搬移函数和搬移字段简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会首先使用搬移字段，再使用搬移方法。</p>
<p>如果一个类承担了太多责任而变得臃肿不堪，这种情况下会使用提炼类将一部分责任分离出去。如果一个类变得太不负责任，使用将类内联化将它融入到另一个类中。</p>
<ul>
<li>1、搬移函数</li>
</ul>
<p>你的程序中，有个函数与其所驻类之外的另个一类进行跟过的交流：调用后者或被后者调用。在该函数最长引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。<br>如果一个类有太多行为，或如果一个类与另一个类有太多合作而高度耦合，就需要搬移函数。可以是系统中的类更简单</p>
<ul>
<li>2、搬移字段</li>
</ul>
<p>程序中，某个字段被其所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改原字段的所有用户，令他们改用新字段</p>
<ul>
<li>3、提炼类</li>
</ul>
<p>某个类做了应该由两个类做的事。建立一个新类，将相关字段和函数从就类搬到新类。</p>
<ul>
<li>4、将类内联化</li>
</ul>
<p>某个类没有做太多的事情，不在承担足够责任，不再有的那单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<ul>
<li>5、隐藏“委托关系”</li>
</ul>
<p>客户通过一个委托类来调用另一个对象。在服务类上建立客户所需要的所有函数，用来隐藏委托关系。</p>
<p>封装意味每个对象都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的对象就会比较少。</p>
<p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数。那么客户就必须知晓这一层委托关系。万一委托关系变化，客户也要相应变化。</p>
<ul>
<li>6、移除中间人</li>
</ul>
<p>某个类做了过多的简单委托。让客户直接调用委托类。<br>每当客户要使用手委托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受委托类的特性越来越多，这一过程会让你很痛苦。</p>
<ul>
<li>7、引入外加函数</li>
</ul>
<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p>
<pre><code>Date newStart = new Date(year, month, date + 1);</code></pre><p>替换为：</p>
<pre><code>Date newStart = nextDay(nowDate);
private static Date nextDay(Date arg){
   retrun new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
}</code></pre><p>如果可以修改源码，你可以自行添加一个新函数；如果不能，你就得在客户端编码，补足你要的那个函数</p>
<ul>
<li>8、引入本地扩展</li>
</ul>
<p>你需要为服务类踢狗一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</p>
<h2 id="（五）重新组织数据"><a href="#（五）重新组织数据" class="headerlink" title="（五）重新组织数据"></a>（五）重新组织数据</h2><ul>
<li>1、自封装字段</li>
</ul>
<p>直接访问一个字段。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。</p>
<pre><code>private int low, high;
boolean includes(int arg){
   retrun arg >= low && arg <= high;
}</code></pre><p>替换为：</p>
<pre><code>private int low, high;
boolean includes(int arg){
   retrun arg >= getLow() && arg <= getHigh();
}
int getLow(){
   retrun low;
}
int getHigh(){
   return high;
}</code></pre><p>在“字段访问方式”这个问题上，存在两种截然不同的观点：</p>
<p>在该变量定义所在的类中，你可以自由的访问。<br>即使在这个类中你也应该只使用访问函数间接访问。<br>*间接访问的好处是：子类可以通过复写一个函数而改变获取数据的途径；它支持更灵活的数据管理方式，例如延迟初始化。</p>
<ul>
<li>2、以对象取代数据值</li>
</ul>
<p>你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象。</p>
<p>一开始你肯能会用一个字符串来表示“电话号码”概念，但是随后你会发现，电话号码需要“格式化”、“区号”之类的行为。这时候就需要为带替换的数值新建一个类。</p>
<ul>
<li>3、将值对象改为引用对象</li>
</ul>
<p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。</p>
<ul>
<li>4、将引用对象改为值对象</li>
</ul>
<p>你有一个引用对象，很小且不可改变，而且不易管理。将它变成一个值对象。</p>
<ul>
<li>5、以对象取代数组</li>
</ul>
<p>你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示</p>
<ul>
<li>6、复制“被监视数据”</li>
</ul>
<p>你有一些领域数据置身GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p>
<ul>
<li>7、将单向关联改为双向关联</li>
</ul>
<p>两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。</p>
<ul>
<li>8、将双向关联改为单向关联</li>
</ul>
<p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。</p>
<ul>
<li>9、以字面常量取代魔数</li>
</ul>
<p>你有一个字面数值，带有特别含义。创造一个常量，根据其意义为它命名，并将上述的字面数值替换为常量。</p>
<ul>
<li>10、封装字段</li>
</ul>
<p>你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。</p>
<ul>
<li>11、封装集合</li>
</ul>
<p>有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</p>
<h2 id="（六）简化条件表达式"><a href="#（六）简化条件表达式" class="headerlink" title="（六）简化条件表达式"></a>（六）简化条件表达式</h2><ul>
<li>1、分解条件表达式</li>
</ul>
<p>有一复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。</p>
<ul>
<li>2、合并表达式</li>
</ul>
<p>你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数。</p>
<ul>
<li>3、合并重复的条件代码</li>
</ul>
<p>在表达式的每个分支上都执行了相同的一段代码。将这段重复代码搬移到条件表达式之外。</p>
<ul>
<li>4、移除控制标记</li>
</ul>
<p>在一系列布尔表达式中,某个变量带有”控制标记”的作用。以break/return语句取代控制标记。</p>
<ul>
<li>5、以多态取代条件表达式</li>
</ul>
<p>有个条件表达式根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</p>
<h2 id="（七）简化函数调用"><a href="#（七）简化函数调用" class="headerlink" title="（七）简化函数调用"></a>（七）简化函数调用</h2><ul>
<li>1、函数改名</li>
</ul>
<p>函数的名称未能揭示其用途。修改函数名称。</p>
<ul>
<li>2、添加参数</li>
</ul>
<p>某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带仅函数所需信息。</p>
<ul>
<li>3、移除参数</li>
</ul>
<p>函数本体不再需要某个参数。去除参数。</p>
<ul>
<li>4、分离查询函数和修改函数</li>
</ul>
<p>某个函数既返回对象状态值，又修改对象值。建立两个不同函数,其中一个负责查询,另一个负责修改。</p>
<ul>
<li>5、令函数携带参数</li>
</ul>
<p>若干函数做了类似的工作，但在函数本体中包含了不同的值。建立单一函数,以参数表达那些不同的值。<br>有这样两个函数：它们做着类似的工作，但因少数几个值致使行为略有不同。在这种情况下，你可以将这些各自分离的函数同一起来，并通过参数来处理那些变化情况，用以简化问题。</p>
<ul>
<li>6、以明确函数取代参数</li>
</ul>
<p>你有一个函数，其中完全取决于参数值而采用不同行为。针对该参数的每一个可能值，建立一个独立函数。<br>如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应该使用本项重构。</p>
<ul>
<li>7、保持对象完整</li>
</ul>
<p>从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。</p>
<ul>
<li>8、以函数取代参数</li>
</ul>
<p>对象调用某个函数，并将所得结果作为参数，传递给另一函数，而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该参数，直接调用前一个函数。</p>
<ul>
<li>9、引入参数对象</li>
</ul>
<p>某些参数总是很自然的同时出现。以一个对象取代这些参数。</p>
<ul>
<li>10、移除设值函数</li>
</ul>
<p>类中某个字段在对象创建时被设值，然后不再改变。去掉该字段的所有设值函数。</p>
<ul>
<li>11、隐藏函数</li>
</ul>
<p>某个函数，从来没有被其他任何类用到 。将函数修改为private。</p>
<ul>
<li>12 、以工厂函数取代构造函数</li>
</ul>
<p>希望在创建对象时不仅仅是做简单的建构动作 。将构造函数替换为工厂函数。</p>
<h2 id="（八）处理概括关系"><a href="#（八）处理概括关系" class="headerlink" title="（八）处理概括关系"></a>（八）处理概括关系</h2><ul>
<li>1、字段上移</li>
</ul>
<p>两个子类拥有相同的字段。将该字段移至超类。</p>
<ul>
<li>2 、函数上移</li>
</ul>
<p>有些函数在各子类中产生完全相同的结果。将该函数移至超类。</p>
<ul>
<li>3 、构造函数本体上移</li>
</ul>
<p>各个子类中有一些构造函数本体几乎完全一致 。在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<ul>
<li>4、函数下移</li>
</ul>
<p>超类中的某个函数只与部分(而非全部)子类用到。将函数移到相关的子类中。</p>
<ul>
<li>5、字段下移</li>
</ul>
<p>超类中的某个字段只被部分(而非全部)子类用到。将字段移到需要它的子类中。</p>
<ul>
<li>6、提炼子类</li>
</ul>
<p>类中的某些特性只被某些(而非全部)实例用到。新建一个子类，将上述部分的特性移到子类中。</p>
<ul>
<li>7、提炼超类</li>
</ul>
<p>两个类有相似特性。为这两个类建立一个超类,将相同特性移至超类。</p>
<ul>
<li>8、提炼接口</li>
</ul>
<p>若干客户使用类接口中的同一子集，或两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。</p>
<ul>
<li>9、折叠继承体系</li>
</ul>
<p>超类和子类之间无太大区别。将它们合为一体。</p>
<ul>
<li>10、塑造模板函数</li>
</ul>
<p>子类中某些函数以相同顺序执行类似操作，但各操作细节略有不同。将操作放进独立函数(保持签名相同)，然后将它们移至超类。</p>
<ul>
<li>11、以委托取代继承</li>
</ul>
<p>某个子类只使用超类接口中的一部分或根本不需要继承而来的数据。子类新建字段保存超类，调整子类函数为委托超类，取消继承关系。</p>
<ul>
<li>12、以继承取代委托</li>
</ul>
<p>你在两个类中使用委托关系，并经常为整个接口编写许多极简单的委托函数。`让委托类继承受托类。</p>
</body></html>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>代码</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫(二)</title>
    <url>/2020/03/21/Py-GovSpace-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="国家统计局统计用区划代码和城乡划分代码爬虫-二-–实现"><a href="#国家统计局统计用区划代码和城乡划分代码爬虫-二-–实现" class="headerlink" title="国家统计局统计用区划代码和城乡划分代码爬虫 (二)–实现"></a>国家统计局统计用区划代码和城乡划分代码爬虫 (二)–实现</h2><p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。</p>
<h2 id="一、总体思路说明"><a href="#一、总体思路说明" class="headerlink" title="一、总体思路说明"></a>一、总体思路说明</h2><p>首先我定义了一个网页爬取函数，然后依次定义省级代码获取函数、市级代码获取函数、区级代码获取函数、街道代码获取函数、居委会代码获取函数，这些函数都会调用网页爬取函数。其中区级代码获取函数、街道代码获取函数、居委会代码获取函数这三个函数都是多线程实现爬取的。最后我将爬取得到的数据输出为 csv 格式文件。</p>
<h3 id="1、库函数导入"><a href="#1、库函数导入" class="headerlink" title="1、库函数导入"></a>1、库函数导入</h3><pre><code class="python">import requests
from lxml import etree
import csv
import time
import pandas as pd
from queue import Queue
from threading import Thread
from fake_useragent import UserAgent</code></pre>
<h3 id="2、网页爬取函数"><a href="#2、网页爬取函数" class="headerlink" title="2、网页爬取函数"></a>2、网页爬取函数</h3><pre><code class="python"># 下面加入了num_retries这个参数，经过测试网络正常一般最多retry一次就能获得结果
def getUrl(url,num_retries = 5):
    ua = UserAgent()
    headers = {'User-Agent':ua.random}
    try:
        response = requests.get(url,headers = headers)
        response.encoding = response.apparent_encoding
        data = response.text
        return data
    except Exception as e:
        if num_retries > 0:
            time.sleep(10)
            print(url)
            print("requests fail, retry!")
            return getUrl(url,num_retries-1) #递归调用
        else:
            print("retry fail!")
            print("error: %s" % e + " " + url)
            return #返回空值，程序运行报错</code></pre>
<h3 id="3、获取省级代码函数"><a href="#3、获取省级代码函数" class="headerlink" title="3、获取省级代码函数"></a>3、获取省级代码函数</h3><pre><code class="python">def getProvince(url):
    province = []
    data = getUrl(url)
    selector = etree.HTML(data)
    provinceList = selector.xpath('//tr[@class="provincetr"]')
    for i in provinceList:
        provinceName = i.xpath('td/a/text()') #这里如果采用//a/text()路径会出现问题！！
        provinceLink = i.xpath('td/a/@href')
        for j in range(len(provinceLink)):
            provinceURL = url[:-10] + provinceLink[j] #根据获取到的每个省的链接进行补全，得到真实的URL。
            province.append({'name':provinceName[j],'link':provinceURL})
    return province
pro = getProvince("http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html")
df_province = pd.DataFrame(pro)
df_province['link']
0     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
1     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
2     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
3     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
4     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
5     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
6     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
7     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
8     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
9     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
10    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
11    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
12    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
13    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
14    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
15    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
16    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
17    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
18    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
19    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
20    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
21    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
22    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
23    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
24    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
25    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
26    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
27    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
28    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
29    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
30    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
Name: link, dtype: object</code></pre>
<h4 id="信息写入-csv-文件"><a href="#信息写入-csv-文件" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_province.to_csv('province.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="4、获取市级代码函数"><a href="#4、获取市级代码函数" class="headerlink" title="4、获取市级代码函数"></a>4、获取市级代码函数</h3><pre><code class="python">def getCity(url_list):
    city_all = []
    for url in url_list:
        data = getUrl(url)
        selector = etree.HTML(data)
        cityList = selector.xpath('//tr[@class="citytr"]')
        #下面是抓取每一个城市的代码、URL
        city = []
        for i in cityList:
            cityCode = i.xpath('td[1]/a/text()')
            cityLink = i.xpath('td[1]/a/@href')
            cityName = i.xpath('td[2]/a/text()')
            for j in range(len(cityLink)):
                cityURL = url[:-7] + cityLink[j]
                city.append({'name':cityName[j],'code':cityCode[j],'link':cityURL})
        city_all.extend(city) #所有省的城市信息合并在一起
    return city_all
city = getCity(df_province['link'])
df_city = pd.DataFrame(city)
df_city</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">110100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">市辖区</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">120100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">市辖区</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石家庄市</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">唐山市</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">秦皇岛市</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">邯郸市</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">邢台市</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">保定市</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">张家口市</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">承德市</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沧州市</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">131000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">廊坊市</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">131100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">衡水市</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">139000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">省直辖县级行政区划</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">140100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">太原市</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">140200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">大同市</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">140300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阳泉市</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">140400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">长治市</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">140500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">晋城市</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">140600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">朔州市</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">140700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">晋中市</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">140800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">运城市</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">140900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">忻州市</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">141000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">临汾市</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">141100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吕梁市</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">150100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">呼和浩特市</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">150200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">包头市</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">150300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌海市</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">150400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">赤峰市</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">150500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">通辽市</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">314</td>
<td align="left">622900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">临夏回族自治州</td>
</tr>
<tr>
<td align="left">315</td>
<td align="left">623000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">甘南藏族自治州</td>
</tr>
<tr>
<td align="left">316</td>
<td align="left">630100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">西宁市</td>
</tr>
<tr>
<td align="left">317</td>
<td align="left">630200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海东市</td>
</tr>
<tr>
<td align="left">318</td>
<td align="left">632200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海北藏族自治州</td>
</tr>
<tr>
<td align="left">319</td>
<td align="left">632300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">黄南藏族自治州</td>
</tr>
<tr>
<td align="left">320</td>
<td align="left">632500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海南藏族自治州</td>
</tr>
<tr>
<td align="left">321</td>
<td align="left">632600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">果洛藏族自治州</td>
</tr>
<tr>
<td align="left">322</td>
<td align="left">632700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">玉树藏族自治州</td>
</tr>
<tr>
<td align="left">323</td>
<td align="left">632800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海西蒙古族藏族自治州</td>
</tr>
<tr>
<td align="left">324</td>
<td align="left">640100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">银川市</td>
</tr>
<tr>
<td align="left">325</td>
<td align="left">640200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石嘴山市</td>
</tr>
<tr>
<td align="left">326</td>
<td align="left">640300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吴忠市</td>
</tr>
<tr>
<td align="left">327</td>
<td align="left">640400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">固原市</td>
</tr>
<tr>
<td align="left">328</td>
<td align="left">640500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">中卫市</td>
</tr>
<tr>
<td align="left">329</td>
<td align="left">650100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌鲁木齐市</td>
</tr>
<tr>
<td align="left">330</td>
<td align="left">650200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">克拉玛依市</td>
</tr>
<tr>
<td align="left">331</td>
<td align="left">650400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吐鲁番市</td>
</tr>
<tr>
<td align="left">332</td>
<td align="left">650500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">哈密市</td>
</tr>
<tr>
<td align="left">333</td>
<td align="left">652300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">昌吉回族自治州</td>
</tr>
<tr>
<td align="left">334</td>
<td align="left">652700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">博尔塔拉蒙古自治州</td>
</tr>
<tr>
<td align="left">335</td>
<td align="left">652800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴音郭楞蒙古自治州</td>
</tr>
<tr>
<td align="left">336</td>
<td align="left">652900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏地区</td>
</tr>
<tr>
<td align="left">337</td>
<td align="left">653000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">克孜勒苏柯尔克孜自治州</td>
</tr>
<tr>
<td align="left">338</td>
<td align="left">653100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">喀什地区</td>
</tr>
<tr>
<td align="left">339</td>
<td align="left">653200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">和田地区</td>
</tr>
<tr>
<td align="left">340</td>
<td align="left">654000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">伊犁哈萨克自治州</td>
</tr>
<tr>
<td align="left">341</td>
<td align="left">654200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔城地区</td>
</tr>
<tr>
<td align="left">342</td>
<td align="left">654300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿勒泰地区</td>
</tr>
<tr>
<td align="left">343</td>
<td align="left">659000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">自治区直辖县级行政区划</td>
</tr>
</tbody></table>
<h4 id="信息写入-csv-文件-1"><a href="#信息写入-csv-文件-1" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_city.to_csv('city.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="5、获取区级代码函数-—-多线程实现"><a href="#5、获取区级代码函数-—-多线程实现" class="headerlink" title="5、获取区级代码函数 — 多线程实现"></a>5、获取区级代码函数 — 多线程实现</h3><pre><code class="python">def getCounty(url_list):
    queue_county = Queue() #队列
    thread_num = 10 #进程数
    county = [] #记录区级信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_county.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_county.empty(): # 保证url遍历结束后能退出线程
            url = queue_county.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            countyList = selector.xpath('//tr[@class="countytr"]')
            #下面是爬取每个区的代码、URL
            for i in countyList:
                countyCode = i.xpath('td[1]/a/text()')
                countyLink = i.xpath('td[1]/a/@href')
                countyName = i.xpath('td[2]/a/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(countyLink)):
                    countyURL = url[:-9] + countyLink[j]
                    county.append({'code':countyCode[j],'link':countyURL,'name':countyName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return county
county = getCounty(df_city['link'])
df_county = pd.DataFrame(county)
df_county</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">130702000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">桥东区</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">130703000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">桥西区</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130705000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">宣化区</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130706000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">下花园区</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130708000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">万全区</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130709000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">崇礼区</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130722000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">张北县</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130723000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">康保县</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130724000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沽源县</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130725000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">尚义县</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130726000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">蔚县</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">130727000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阳原县</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">130602000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">竞秀区</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">130606000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">莲池区</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">130607000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">满城区</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">130608000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">清苑区</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">130609000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">徐水区</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">130623000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞水县</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">130624000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阜平县</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">130626000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定兴县</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">130627000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">唐县</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">130628000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">高阳县</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">130629000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">容城县</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">130630000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞源县</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">130631000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">望都县</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">130632000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">安新县</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">130633000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">易县</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">130634000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">曲阳县</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">130635000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">蠡县</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">130636000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">顺平县</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2822</td>
<td align="left">653128000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">岳普湖县</td>
</tr>
<tr>
<td align="left">2823</td>
<td align="left">653129000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">伽师县</td>
</tr>
<tr>
<td align="left">2824</td>
<td align="left">654221000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">额敏县</td>
</tr>
<tr>
<td align="left">2825</td>
<td align="left">652901000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏市</td>
</tr>
<tr>
<td align="left">2826</td>
<td align="left">654223000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙湾县</td>
</tr>
<tr>
<td align="left">2827</td>
<td align="left">652922000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">温宿县</td>
</tr>
<tr>
<td align="left">2828</td>
<td align="left">653130000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴楚县</td>
</tr>
<tr>
<td align="left">2829</td>
<td align="left">654224000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">托里县</td>
</tr>
<tr>
<td align="left">2830</td>
<td align="left">652923000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">库车县</td>
</tr>
<tr>
<td align="left">2831</td>
<td align="left">654225000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">裕民县</td>
</tr>
<tr>
<td align="left">2832</td>
<td align="left">653131000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔什库尔干塔吉克自治县</td>
</tr>
<tr>
<td align="left">2833</td>
<td align="left">654226000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">和布克赛尔蒙古自治县</td>
</tr>
<tr>
<td align="left">2834</td>
<td align="left">652924000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙雅县</td>
</tr>
<tr>
<td align="left">2835</td>
<td align="left">652925000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">新和县</td>
</tr>
<tr>
<td align="left">2836</td>
<td align="left">652926000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">拜城县</td>
</tr>
<tr>
<td align="left">2837</td>
<td align="left">652927000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌什县</td>
</tr>
<tr>
<td align="left">2838</td>
<td align="left">652928000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿瓦提县</td>
</tr>
<tr>
<td align="left">2839</td>
<td align="left">652929000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">柯坪县</td>
</tr>
<tr>
<td align="left">2840</td>
<td align="left">659001000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石河子市</td>
</tr>
<tr>
<td align="left">2841</td>
<td align="left">659002000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿拉尔市</td>
</tr>
<tr>
<td align="left">2842</td>
<td align="left">659003000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">图木舒克市</td>
</tr>
<tr>
<td align="left">2843</td>
<td align="left">659004000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">五家渠市</td>
</tr>
<tr>
<td align="left">2844</td>
<td align="left">659006000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">铁门关市</td>
</tr>
<tr>
<td align="left">2845</td>
<td align="left">654301000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿勒泰市</td>
</tr>
<tr>
<td align="left">2846</td>
<td align="left">654321000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">布尔津县</td>
</tr>
<tr>
<td align="left">2847</td>
<td align="left">654322000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">富蕴县</td>
</tr>
<tr>
<td align="left">2848</td>
<td align="left">654323000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">福海县</td>
</tr>
<tr>
<td align="left">2849</td>
<td align="left">654324000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">哈巴河县</td>
</tr>
<tr>
<td align="left">2850</td>
<td align="left">654325000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">青河县</td>
</tr>
<tr>
<td align="left">2851</td>
<td align="left">654326000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吉木乃县</td>
</tr>
</tbody></table>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照区代码进行 “升序” 排序。</p>
<pre><code class="python">df_county_sorted = df_county.sort_values(by = ['code']) #按1列进行升序排序</code></pre>
<h4 id="信息写入-csv-文件-2"><a href="#信息写入-csv-文件-2" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_county_sorted.to_csv('county.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="6、获取街道代码函数-—-多线程实现"><a href="#6、获取街道代码函数-—-多线程实现" class="headerlink" title="6、获取街道代码函数 — 多线程实现"></a>6、获取街道代码函数 — 多线程实现</h3><pre><code class="python">def getTown(url_list):
    queue_town = Queue() #队列
    thread_num = 50 #进程数
    town = [] #记录街道信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_town.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_town.empty(): # 保证url遍历结束后能退出线程
            url = queue_town.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            townList = selector.xpath('//tr[@class="towntr"]')
            #下面是爬取每个区的代码、URL
            for i in townList:
                townCode = i.xpath('td[1]/a/text()')
                townLink = i.xpath('td[1]/a/@href')
                townName = i.xpath('td[2]/a/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(townLink)):
                    townURL = url[:-11] + townLink[j]
                    town.append({'code':townCode[j],'link':townURL,'name':townName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return town
town = getTown(df_county['link'])
df_town = pd.DataFrame(town)
df_town</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">130706001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城镇街道办事处</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">130706002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">煤矿街道办事处</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130706200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">花园乡</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130706201000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">辛庄子乡</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130706202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定方水乡</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130706203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">段家堡乡</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130702001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">红旗楼街道办事处</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130702002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">胜利北路街道办事处</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130702003000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">五一路街道办事处</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130702004000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">花园街街道办事处</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130702005000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">工业路街道办事处</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">130702101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">姚家庄镇</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">130623001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城区社区管理办公室街道办事处</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">130624100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阜平镇</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">130624101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">龙泉关镇</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">130626100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定兴镇</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">130623100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞水镇</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">130624102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平阳镇</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">130624103000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城南庄镇</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">130624104000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">天生桥镇</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">130624105000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">王林口镇</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">130624202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">台峪乡</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">130624203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">大台乡</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">130624204000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">史家寨乡</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">130624205000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">砂窝乡</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">130724100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平定堡镇</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">130724101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">小厂镇</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">130724102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">黄盖淖镇</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">130724103000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">九连城镇</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">130724200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">高山堡乡</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">42532</td>
<td align="left">659002509000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团十六团</td>
</tr>
<tr>
<td align="left">42533</td>
<td align="left">659002511000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师水利水电工程处</td>
</tr>
<tr>
<td align="left">42534</td>
<td align="left">659002512000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师塔里木灌区水利管理处</td>
</tr>
<tr>
<td align="left">42535</td>
<td align="left">659002513000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿拉尔农场</td>
</tr>
<tr>
<td align="left">42536</td>
<td align="left">659002514000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师幸福农场</td>
</tr>
<tr>
<td align="left">42537</td>
<td align="left">659002515000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">中心监狱</td>
</tr>
<tr>
<td align="left">42538</td>
<td align="left">659002516000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团一团</td>
</tr>
<tr>
<td align="left">42539</td>
<td align="left">659002517000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团农一师沙井子水利管理处</td>
</tr>
<tr>
<td align="left">42540</td>
<td align="left">659002518000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">西工业园区管理委员会</td>
</tr>
<tr>
<td align="left">42541</td>
<td align="left">659002519000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团二团</td>
</tr>
<tr>
<td align="left">42542</td>
<td align="left">659002520000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团三团</td>
</tr>
<tr>
<td align="left">42543</td>
<td align="left">522701001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">广惠街道办事处</td>
</tr>
<tr>
<td align="left">42544</td>
<td align="left">522701002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">文峰街道办事处</td>
</tr>
<tr>
<td align="left">42545</td>
<td align="left">522701004000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">小围寨街道办事处</td>
</tr>
<tr>
<td align="left">42546</td>
<td align="left">522701005000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙包堡街道办事处</td>
</tr>
<tr>
<td align="left">42547</td>
<td align="left">522701006000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">绿茵湖街道办事处</td>
</tr>
<tr>
<td align="left">42548</td>
<td align="left">522701106000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">墨冲镇</td>
</tr>
<tr>
<td align="left">42549</td>
<td align="left">522701107000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平浪镇</td>
</tr>
<tr>
<td align="left">42550</td>
<td align="left">522701110000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">毛尖镇</td>
</tr>
<tr>
<td align="left">42551</td>
<td align="left">522701111000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">匀东镇</td>
</tr>
<tr>
<td align="left">42552</td>
<td align="left">522701208000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">归兰水族乡</td>
</tr>
<tr>
<td align="left">42553</td>
<td align="left">652928100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿瓦提镇</td>
</tr>
<tr>
<td align="left">42554</td>
<td align="left">652928101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌鲁却勒镇</td>
</tr>
<tr>
<td align="left">42555</td>
<td align="left">652928102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">拜什艾日克镇</td>
</tr>
<tr>
<td align="left">42556</td>
<td align="left">652928200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿依巴格乡</td>
</tr>
<tr>
<td align="left">42557</td>
<td align="left">652928201000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔木托格拉克乡</td>
</tr>
<tr>
<td align="left">42558</td>
<td align="left">652928202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">英艾日克乡</td>
</tr>
<tr>
<td align="left">42559</td>
<td align="left">652928203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">多浪乡</td>
</tr>
<tr>
<td align="left">42560</td>
<td align="left">652928204000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴格托格拉克乡</td>
</tr>
<tr>
<td align="left">42561</td>
<td align="left">652928405000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏监狱</td>
</tr>
</tbody></table>
<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照街道代码进行 “升序” 排序。</p>
<pre><code class="python">df_town_sorted = df_town.sort_values(by = ['code']) #按1列进行升序排序</code></pre>
<h4 id="信息写入-csv-文件-3"><a href="#信息写入-csv-文件-3" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_town_sorted.to_csv('town.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="7、获取居委会代码函数-—-多线程实现"><a href="#7、获取居委会代码函数-—-多线程实现" class="headerlink" title="7、获取居委会代码函数 — 多线程实现"></a>7、获取居委会代码函数 — 多线程实现</h3><pre><code class="python">def getVillage(url_list):
    queue_village = Queue() #队列
    thread_num = 200 #进程数
    town = [] #记录街道信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_village.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_village.empty(): # 保证url遍历结束后能退出线程
            url = queue_village.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            villageList = selector.xpath('//tr[@class="villagetr"]')
            #下面是爬取每个区的代码、URL
            for i in villageList:
                villageCode = i.xpath('td[1]/text()')
                UrbanRuralCode = i.xpath('td[2]/text()')
                villageName = i.xpath('td[3]/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(villageCode)):
                    town.append({'code':villageCode[j],'UrbanRuralCode':UrbanRuralCode[j],'name':villageName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return town
village = getVillage(df_town['link'])
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/24/140724204.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/27/140727400.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/10/29/141029204.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/04/150104008.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981102.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/02/150102001.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981210.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/21/150421202.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/25/150425100.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/22/150422401.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/02/150402402.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/30/150430207.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/21/150121105.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/07/22/150722105.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/25/26/152526103.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/21/210421209.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/22/210422108.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502002.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/06/03/210603007.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502010.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/03/210503005.html
requests fail, retry!</code></pre>
<p>由于数据量很大，所以这里我没有爬取完毕。</p>
</body></html>]]></content>
      <categories>
        <category>码爬</category>
      </categories>
      <tags>
        <tag>码爬</tag>
      </tags>
  </entry>
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫(一)</title>
    <url>/2020/03/21/Py-GovSpace-02/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="国家统计局统计用区划代码和城乡划分代码爬虫-一-–分析"><a href="#国家统计局统计用区划代码和城乡划分代码爬虫-一-–分析" class="headerlink" title="国家统计局统计用区划代码和城乡划分代码爬虫 (一)–分析"></a>国家统计局统计用区划代码和城乡划分代码爬虫 (一)–分析</h2><p>这里我就拿 2016 年的页面做下分析：<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html" target="_blank" rel="noopener">2016 年统计用区划代码和城乡划分代码 (截止 2016 年 07 月 31 日)</a>。</p>
<h2 id="一、省级页面分析"><a href="#一、省级页面分析" class="headerlink" title="一、省级页面分析"></a>一、省级页面分析</h2><h3 id="1、省级信息提取"><a href="#1、省级信息提取" class="headerlink" title="1、省级信息提取"></a>1、省级信息提取</h3><p>我们进入到 <a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html" target="_blank" rel="noopener">2016 年统计用区划代码和城乡划分代码 (截止 2016 年 07 月 31 日)</a> 这个页面，然后用 chrome 的 “检查” 工具看下我们要找的信息在哪。</p>
<p>这里我们需要爬取省级名称、省内市级信息的子链接这两个参数。</p>
<p>我们从图中可以发现，左边页面每一行对应的 XPath 路径为：</p>
<pre><code class="python">//tr[@class="provincetr"]</code></pre>
<p>然后一行中每个省的信息在下一级的 td 标签内：</p>
<pre><code class="python">td/a/text()
td/a/@href</code></pre>
<p><a href="https://tding.top/archives/a4d70246/%E7%9C%81%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="省级页面分析" class="fancybox"><img alt="省级页面分析" title="省级页面分析" data-src="https://tding.top/archives/a4d70246/%E7%9C%81%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取"><a href="#2、下级链接获取" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>省级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html</code></pre>
<p>下级页面的 URL（我这里以<code>浙江省</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html</code></pre>
<p>页面中提取到的信息（我这里以<code>浙江省</code>为例）：</p>
<pre><code class="python">33.html</code></pre>
<p>所以我们可以通过如下方式获取真实的 URL 保存到一个列表中：</p>
<pre><code class="python">url = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"
# provinceLink = "33.html"
provinceURL = url[:-10] + provinceLink</code></pre>
<h2 id="二、市级页面分析"><a href="#二、市级页面分析" class="headerlink" title="二、市级页面分析"></a>二、市级页面分析</h2><h3 id="1、市级信息提取"><a href="#1、市级信息提取" class="headerlink" title="1、市级信息提取"></a>1、市级信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html" target="_blank" rel="noopener">浙江省</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是市级页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%B8%82%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="市级页面分析" class="fancybox"><img alt="市级页面分析" title="市级页面分析" data-src="https://tding.top/archives/a4d70246/%E5%B8%82%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-1"><a href="#2、下级链接获取-1" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>市级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html</code></pre>
<p>下级页面的 URL（我这里以<code>杭州市</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html</code></pre>
<p>页面中提取到的信息（我这里以<code>杭州市</code>为例）：</p>
<pre><code class="python">33/3301.html</code></pre>
<h2 id="三、区级页面分析"><a href="#三、区级页面分析" class="headerlink" title="三、区级页面分析"></a>三、区级页面分析</h2><h3 id="1、区级信息提取"><a href="#1、区级信息提取" class="headerlink" title="1、区级信息提取"></a>1、区级信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html" target="_blank" rel="noopener">杭州市</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是区级页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%8C%BA%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="区级页面分析" class="fancybox"><img alt="区级页面分析" title="区级页面分析" data-src="https://tding.top/archives/a4d70246/%E5%8C%BA%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-2"><a href="#2、下级链接获取-2" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>区级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html</code></pre>
<p>下级页面的 URL（我这里以<code>上城区</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html</code></pre>
<p>页面中提取到的信息（我这里以<code>上城区</code>为例）：</p>
<pre><code class="python">01/330102.html</code></pre>
<h2 id="四、街道页面分析"><a href="#四、街道页面分析" class="headerlink" title="四、街道页面分析"></a>四、街道页面分析</h2><h3 id="1、街道信息提取"><a href="#1、街道信息提取" class="headerlink" title="1、街道信息提取"></a>1、街道信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html" target="_blank" rel="noopener">上城区</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是街道页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E8%A1%97%E9%81%93%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="街道页面分析" class="fancybox"><img alt="街道页面分析" title="街道页面分析" data-src="https://tding.top/archives/a4d70246/%E8%A1%97%E9%81%93%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-3"><a href="#2、下级链接获取-3" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>街道页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html</code></pre>
<p>街道页面的 URL（我这里以<code>湖滨街道</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html</code></pre>
<p>页面中提取到的信息（我这里以<code>湖滨街道</code>为例）：</p>
<pre><code class="python">02/330102003.html</code></pre>
<h2 id="五、居委会页面分析"><a href="#五、居委会页面分析" class="headerlink" title="五、居委会页面分析"></a>五、居委会页面分析</h2><h3 id="1、居委会信息提取"><a href="#1、居委会信息提取" class="headerlink" title="1、居委会信息提取"></a>1、居委会信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html" target="_blank" rel="noopener">湖滨街道</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是居委会页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%B1%85%E5%A7%94%E4%BC%9A%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="居委会页面分析" class="fancybox"><img alt="居委会页面分析" title="居委会页面分析" data-src="https://tding.top/archives/a4d70246/%E5%B1%85%E5%A7%94%E4%BC%9A%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<p>这里已经到了最底层，没有下级链接了。</p>
</body></html>]]></content>
      <categories>
        <category>码爬</category>
      </categories>
      <tags>
        <tag>码爬</tag>
      </tags>
  </entry>
  <entry>
    <title>初识微信公众号开发</title>
    <url>/2020/03/21/Wechat-Dev-Sub/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>现如今，微信已经不再只承担着交流沟通、娱乐大众的功能，微信公众号的推出将微信逐渐转变成个人、商家、企业单位用来营销的重要工具。而微信推出的公众号开发功能，为我们码农带来很大的方便，让我们创造出更多的可能性。</p>
<h2 id="第一章：开始开发-准备阶段"><a href="#第一章：开始开发-准备阶段" class="headerlink" title="第一章：开始开发(准备阶段)"></a><strong>第一章：开始开发(准备阶段)</strong></h2><h3 id="1、-接入指南"><a href="#1、-接入指南" class="headerlink" title="1、 接入指南"></a><strong>1、 接入指南</strong></h3><p>接入微信公众平台开发，开发者需要按照如下步骤完成：</p>
<p><strong>·</strong>填写服务器配置</p>
<p><a href="./wechat-01.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-01.png" class="lazyload"></a></p>
<p><em>说明：URL是开发者用来接收微信消息和事件的接口URL，该接口尽量写成两个请求方式，1:get请求，用于验证如下地址有效性，2:post请求, 用于接收消息和事件，Token 可以随便定义用于验证接口签名有效性, EncodingAESKey是加密的密钥，下面加密方式选兼容模式或者安全模式的时候开发者可根据该密钥对数据进行加解密</em></p>
<p><strong>·</strong>验证如上URL服务器地址的有效性</p>
<p>根据官方文档的说明，微信验证接口会带下面几个参数</p>
<p><a href="./wechat-02.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-02.png" class="lazyload"></a></p>
<p>端接口接收到这些参数后进行签名验证，如下代码：</p>
<pre><code class="js">exports.check = function (req, res, next) {
// 在这里验证签名
var signature = req.query['signature'],
timestamp = req.query['timestamp'],
nonce = req.query['nonce'],
echostr = req.query['echostr'];
var sha1 = crypto.createHash('sha1'),
sha1Str = sha1.update([config.weixin.token, timestamp, nonce].sort().join('')).digest('hex');
res.writeHead(200, {'Content-Type': 'text/plain'});
res.end((sha1Str === signature) ? echostr : '');
return res;
};</code></pre>
<p><strong>·</strong>依据接口文档实现业务逻辑</p>
<p>这里就是根据业务需求，进行接口调用的编程了，下面我会一一介绍</p>
<h3 id="2、获取access-token"><a href="#2、获取access-token" class="headerlink" title="2、获取access_token"></a><strong>2、获取access_token</strong></h3><p> access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。该接口一天只能请求2000次，开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p>如下代码事例：</p>
<pre><code class="js">exports.get_token = function (fn) {
redis.get(weixin_token, function (err, token_str) {
if (token_str) {
return fn(err, JSON.parse(token_str));
} else {
request.get("https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=" + app_id + "&secret=" + app_secret, function (err, response, body) {
if (JSON.parse(body).errcode == 45009) {
return fn(err)
} else {
redis.set(weixin_token, body, function (err) {
redis.expire(weixin_token, 7000, function () {
return fn(err, JSON.parse(body));
};</code></pre>
<p>上面的事例代码中，首先我会从redis中获取到access_token，因为我最初获取access_token的时候写入到redis中了，官方给的有效时间是7200秒，我放在redis中的有效时间是7000秒，所以我这里的token不会过期，过期后会重新调用接口获取并写入redis</p>
<h2 id="第二章：自定义菜单"><a href="#第二章：自定义菜单" class="headerlink" title="第二章：自定义菜单"></a><strong>第二章：自定义菜单</strong></h2><p>实例代码中只写入创建接口的调用，查询和删除就不举例了。</p>
<h3 id="·1、自定义菜单创建接口"><a href="#·1、自定义菜单创建接口" class="headerlink" title="·1、自定义菜单创建接口"></a>·<strong>1、自定义菜单创建接口</strong></h3><p>如下代码事例以及说明：</p>
<pre><code class="js">get_token(function(err, obj){
var access_token = obj.access_token;
request.post({
url: "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=" + access_token,
json: {
"button":[
{
"type":"view",
"name":"工作台",
"url":"http://worktile.com"
},
{
"name":"解决方案",
"sub_button": [
{
"type":"view",
"name":"研发",
"url":"https://pro.worktile.com/solution/dev"
}
{
"type":"view",
"name":"最佳实践",
"url":"https://worktile.com/can"
}
{
"name":"更多",
"sub_button":[
{
"type":"view",
"name":"下载应用",
"url":"http://a.app.qq.com/o/simple.jsp?pkgname=com.worktile"
},
{
"type":"click",
"name":"合作",
"key":"work_together"
}]
}, function(err, res, body){
console.log(body)
})

</code></pre>
<p>这里get_token方法就是上面第一章中＃获取access_token ，而且我这里是作为脚本执行的，这样方便以后随便修改自定义菜单内容</p>
<h3 id="2、自定义菜单查询接口"><a href="#2、自定义菜单查询接口" class="headerlink" title="2、自定义菜单查询接口"></a>2、自定义菜单查询接口</h3><p>http请求方式：GET</p>
<p><a href="https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN</a></p>
<h3 id="3、自定义菜单删除接口"><a href="#3、自定义菜单删除接口" class="headerlink" title="**3、自定义菜单删除接口"></a>**3、自定义菜单删除接口</h3><p>http请求方式：GET</p>
<p><a href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN</a></p>
<h2 id="第三章：消息管理"><a href="#第三章：消息管理" class="headerlink" title="第三章：消息管理"></a><strong>第三章：消息管理</strong></h2><h3 id="1、接收消息"><a href="#1、接收消息" class="headerlink" title="1、接收消息"></a>1、接收消息</h3><p>接收的消息分为普通消息和事件消息，统一有第一章中接入指南填写的RUL接口来接收处理</p>
<blockquote>
<p>微信消息里面消息的接收和返回都是已XMl格式交互的</p>
</blockquote>
<pre><code class="js">exports.receive = function (req, res, next) {
// 在这接收消息
var xml = '';
req.setEncoding('utf8');
req.on('data', function (chunk) {
xml += chunk;
});
req.on('end', function () {
toJSON(xml, res);
});

};</code></pre>
<p>说明：receive方法就是接收用户发给公众号的消息，内容格式是xml，toJSON就是我解析xml为json的方法，如下</p>
<blockquote>
<p>xml转换json可以运用第三方工具库“xml2json”快捷进行转换</p>
</blockquote>
<pre><code class="js">//解析器
var toJSON = function (xml, res) {
var msg = {};
xml2js.parseString(xml, function (err, result) {
var data = result.xml;
msg.ToUserName = data.ToUserName[0];
msg.FromUserName = data.FromUserName[0];
msg.CreateTime = data.CreateTime[0];
msg.MsgType = data.MsgType[0];
switch (msg.MsgType) {
case 'text' :
    msg.Content = data.Content[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
    return handle_text(msg, res);
break;
case 'image' :
    msg.PicUrl = data.PicUrl[0];
    msg.MsgId = data.MsgId[0];
    msg.MediaId = data.MediaId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'voice' :
    msg.MediaId = data.MediaId[0];
    msg.Format = data.Format[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;

case 'video' :
    msg.MediaId = data.MediaId[0];
    msg.ThumbMediaId = data.ThumbMediaId[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'location' :
    msg.Location_X = data.Location_X[0];
    msg.Location_Y = data.Location_Y[0];
    msg.Scale = data.Scale[0];
    msg.Label = data.Label[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'link' :
    msg.Title = data.Title[0];
    msg.Description = data.Description[0];
    msg.Url = data.Url[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'event' :
    msg.Event = data.Event[0];
    if (data.EventKey && _.isArray(data.EventKey) && data.EventKey.length > 0) {
        msg.EventKey = data.EventKey[0];
        return handle_event(msg, res);
    }
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
}
});
};</code></pre>
<p><em>说明：这里我用户发过来的消息xml解释称json数据msg, 根据不同的类型做不同的处理，如上文本，图片，音频，视频，链接，事件等消息</em></p>
<pre><code class="js">var handle_text = function (msg, res) {
var text = msg.Content;
if(text.trim() == "研发"){
    var data = {
    "touser":msg.FromUserName,
    "msgtype":"news",
    "news":{
    "articles": [
    {
    "title":"重磅！Worktile 推出研发管理解决方案",
    "description":"项目进度清晰掌握，快速跟进产品Bug，多维度统计报表，文件文档有序管理",
    "url":"https://pro.worktile.com/solution/dev",
    "picurl":"https://wt-prj.oss.aliyuncs.com/b327e3a5666048279583e8e026ac6b87/4bb6e53c-8516-4466-b278-4f3b596e46db.png"
    sendMessageToUser(data);
}else if(text.trim() == "电商"){
    var data = {
    "touser":msg.FromUserName,
    "msgtype":"news",
    "news":{},
    "articles": [
    {
    "title":"Worktile 『电商解决方案』上线！",
    "description":"降低运营成本，提高团队效率。日常运营、大促筹备、售后跟踪、研发管理……尽在掌握。",
    "url":"https://pro.worktile.com/solution/ecommerce",
    "picurl":"https://cdn.worktile.com/solution/ecommerce.png"
    }]
    sendMessageToUser(data);
}
*说明：这是对文本消息的处理，如上，如果接收到 研发 字样的消息，公众号会给该用户发送一条新闻消息*

var handle_event = function (msg, res) {
    console.log("weixin receive message ===", msg)
if (msg.Event == 'CLICK' && msg.EventKey == 'work_together') {
    var text = "Hello，谢谢对 Worktile 的关注啦，请访问worktile官方网站了解。。。。。";
    var data = {
        touser : msg.FromUserName,
        msgtype: "text",
        text  : {
        content: text
sendMessageToUser(data);</code></pre>
<p><em>说明：这是对事件消息的处理，如上，如果接收到 msg.Event == ‘CLICK’ && msg.EventKey == ‘work_together’ 事件的消息，公众号会给该用户发送一条文本消息，当然事件消息有很多，如：subscribe关注公众号消息，unsubscribe取消关注，扫描带参数二维码事件，还有如上说的自定义菜单事件， 上报地理位置事件等</em></p>
<pre><code class="js">var sendMessageToUser = function ( data) {
    get_token(function (err, obj) {
        request.post({
            url  : "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token="             +obj.access_token,
            headers: {"Content-Type": "application/json"},
            json  : data
        }, function (err, res, body) {
        console.log("sendmessage....", body)
        })
    }
</code></pre>
<p><em>这个发放就是调用微信接口给用户发送消息，那接下来咱们就看下发送消息</em></p>
<h3 id="2、发送消息"><a href="#2、发送消息" class="headerlink" title="2、发送消息"></a><strong>2、发送消息</strong></h3><p>发送消息分为，发送被动消息，发送客服消息，发送模版消息</p>
<ul>
<li>被动消息如上接收消息后根据消息判断发送给用户的消息即是被动消息</li>
<li>客服消息，是公众号收到用户来的消息客服根据内容回复给用户的消息</li>
</ul>
<p>如果用户并没有给公众号发消息，此时客服是无法给用户发送消息的，这是微信做的一个限制</p>
<p>如下代码：</p>
<pre><code class="js">
wtutil.get_token(function (err, obj) {
//var text = "你好，这是一条消息，多谢支持...";
//var data = {
//  touser : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
//  msgtype: "text",
//  text  : {
//    content: text
//  }
//};
var data = {
touser : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
msgtype: "image",
"image":
{
    "media_id":"ZqQGrsR6ivb273zLApNfkEdAP3UI8nHJTJ9ekelfJ8OhKUF6UG-o6YbOBv4uWf4R"
}
};
request.post({
    url  : "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=" + obj.access_token,
    headers: {"Content-Type": "application/json"},
    json  : data
}, function (err, res, body) {
    console.log(body);
    })
});</code></pre>
<p>msgtype: 是消息类型，上面注释掉的是文本消息，下面是个图片消息，touser是用户的openid，这里我只是取过来直接使用的，这里跟上面接收消息后处理给用户发消息有写重复，就不多介绍了</p>
<h3 id="3、模版消息"><a href="#3、模版消息" class="headerlink" title="3、模版消息"></a><strong>3、模版消息</strong></h3><p>模版消息大家肯定很熟悉，比如Worktile的微信公众号接收任务消息通知，这样的消息就是模版消息</p>
<p><a href="./wechat-03.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-03.png" class="lazyload"></a></p>
<p>模版消息相对来说复杂一下，首先要从公众号添加或者申请消息模版，如下图</p>
<p><a href="./wechat-04.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-04.png" class="lazyload"></a></p>
<p>那么有了消息模版之后就可以拿到模版ID，然后给用户发送模版消息了</p>
<pre><code class="js">get_token(function (err, obj) {
    var data = {
        "touser"   : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
        "template_id": "z6yV_lOIAM-LQbsrG-B3hTQvwt8_4Y3wVU2PH9UW16c",
        "url"    : "https://worktile.com",
        "topcolor"  : "#FF00FF",
        "data"    : {
            "first"  : {
                "value": "测试哈哈哈，颜色可以自定义",
                "color": "#33FF00"
            },
            "one": {
                "value": "one",
                "color": "#173177"
            },
            "two": {
                "value": "two",
                "color": "#FF0033"
            },
            "three": {
                "value": "three",
                "color": "#173177"
            },
            "remark" : {
                "value": "remark，了解更多详情，关注我。。。。",
                "color": "#33FF00"
            }
        }
request.post({
    url  : "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=" + obj.access_token,
    headers: {"Content-Type": "application/json"},
    json  : data
    }, function (err, res, body) {
        console.log(body, "----")
    })
});
</code></pre>
<p>需要说明的是参数中data里面的key(first, one, two,three, remark)是模版中定义的，这里需要根据模版内容来写，还有可以设置每个字段的颜色值等属性</p>
<h2 id="第四章：微信网页开发"><a href="#第四章：微信网页开发" class="headerlink" title="第四章：微信网页开发"></a><strong>第四章：微信网页开发</strong></h2><p>这个章节跟前面几章不同，前面几章介绍的是公众号开发的一些东西，这个章节介绍的是网页开发，主要针对h5应用或者是页面的开发，Worktile微信版就是微信网页开发完成的，下面咱们一步步的介绍。</p>
<h3 id="·微信网页授权"><a href="#·微信网页授权" class="headerlink" title="·微信网页授权"></a><strong>·微信网页授权</strong></h3><p>微信网页授权采用的是Oauth2.0的授权方式：</p>
<p><strong>第一步：访问如下链接获取code</strong></p>
<p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect</a></p>
<p>redirect_uri是你h5地址，授权成功后会把code加入到地址上，类似于：<a href="https://weixin.worktile.com?code=xxx这样" target="_blank" rel="noopener">https://weixin.worktile.com?code=xxx这样</a></p>
<p><strong>第二步：通过code换取网页授权access_token</strong></p>
<p>请求接口（get请求）</p>
<p><a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code</a></p>
<p>返回的结果如下</p>
<pre><code class="json">{ 
    "access_token":"ACCESS_TOKEN",
    "expires_in":7200,
    "refresh_token":"REFRESH_TOKEN",
    "openid":"OPENID",
    "scope":"SCOPE" 
}</code></pre>
<p><em>access_token是用户授权的token，openid是用户对于该公众号的唯一标示，refresh_token：可以调用刷新token的接口获取最新的token</em></p>
<p><strong>第三步：获取用户信息(需scope为 snsapi_userinfo)</strong></p>
<p>请求接口(get请求)</p>
<p><a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN</a></p>
<p>通过以上3个步骤就可以获取用户的信息，进行用户的管理操作了</p>
<h3 id="·微信JS-SDK"><a href="#·微信JS-SDK" class="headerlink" title="·微信JS-SDK"></a><strong>·微信JS-SDK</strong></h3><p>网页开发中，有时候我们会自定义分享的内容，图片，音频，视频的上传，下载，地理位置，摇一摇周边，扫码，支付等的功能，这时候就需要js-sdk的开发了，下面简单介绍下js-sdk的使用，读者还可以查看官方开发文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842&token=&lang=zh_CN</a></p>
<h3 id="·绑定域名"><a href="#·绑定域名" class="headerlink" title="·绑定域名"></a><strong>·绑定域名</strong></h3><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p>
<h3 id="·引入JS文件"><a href="#·引入JS文件" class="headerlink" title="·引入JS文件"></a><strong>·引入JS文件</strong></h3><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.0.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.0.0.js</a></p>
<p>如需使用摇一摇周边功能，请引入<a href="http://res.wx.qq.com/open/js/jweixin-1.1.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.1.0.js</a></p>
<h3 id="·通过config接口注入权限验证配置"><a href="#·通过config接口注入权限验证配置" class="headerlink" title="·通过config接口注入权限验证配置"></a><strong>·通过config接口注入权限验证配置</strong></h3><p>如下代码需要在网页中配置</p>
<pre><code class="js">wx.config({
debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打                开，参数信息会通过log打出，仅在pc端时才会打印。
appId: '', // 必填，公众号的唯一标识
timestamp: , // 必填，生成签名的时间戳
nonceStr: '', // 必填，生成签名的随机串
signature: '',// 必填，签名，见附录1
jsApiList: [] // 必填，需要使用的JS接口列表
});</code></pre>
<blockquote>
<p>如上代码中的timestamp, nonceStr, signature需要服务端做好签名返回给页面，这里可以使用异步调用的方式，如下为服务端签名代码</p>
</blockquote>
<pre><code class="js">
var sign = function (jsapi_ticket, url) {
var ret = {
jsapi_ticket: jsapi_ticket,
nonceStr: createNonceStr(),
timestamp: createTimestamp(),
url: url
};
var string = raw(ret);
jsSHA = require('jssha');
shaObj = new jsSHA(string, 'TEXT');
ret.signature = shaObj.getHash('SHA-1', 'HEX');
return ret;
};</code></pre>
<p><em>ret就是我们需要的签名结果，其中jsapi_ticket是调用ticket接口获取的，官方文档中也有说明<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=</a> access_token&type=jsapi, rul是获取签名的当前网页地址, nonceStr:随机字符串，timestamp：当前10位时间戳</em></p>
<pre><code class="js">var raw = function (args) {
var keys = Object.keys(args);
keys = keys.sort()
var newArgs = {};
keys.forEach(function (key) {
newArgs[key.toLowerCase()] = args[key];
});
var string = '';
for (var k in newArgs) {
string += '&' + k + '=' + newArgs[k];
}
string = string.substr(1);
return string;
};</code></pre>
<p><em>这个方法是对签名对象的一个字符串格式化算法</em></p>
<h3 id="·通过ready接口处理成功验证"><a href="#·通过ready接口处理成功验证" class="headerlink" title="·通过ready接口处理成功验证"></a><strong>·通过ready接口处理成功验证</strong></h3><blockquote>
<p>wx.ready(function(){</p>
<p>// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</p>
</blockquote>
<p>});</p>
<h3 id="·调用接口"><a href="#·调用接口" class="headerlink" title="·调用接口"></a><strong>·调用接口</strong></h3><p>根据config里面 jsApiList的配置可以调用js-sdk的接口，如分享朋友圈，分享微信好友等。</p>
<pre><code class="js">wx.onMenuShareTimeline({
title: '', // 分享标题
link: '', // 分享链接
imgUrl: '', // 分享图标
success: function () {
// 用户确认分享后执行的回调函数
},
cancel: function () {
// 用户取消分享后执行的回调函数
}
});</code></pre>
<p>这是一个分享到朋友圈的接口，可以自定义标题，自定义链接，自定义图标</p>
<p>如果想调用更多的js-sdk的接口可以参考官方文档进行开发：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115&token=&lang=zh_CN</a></p>
<h3 id="·微信网页开发样式库"><a href="#·微信网页开发样式库" class="headerlink" title="·微信网页开发样式库"></a><strong>·微信网页开发样式库</strong></h3><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784134&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784134&token=&lang=zh_CN</a></p>
<h3 id="·微信web开发者工具"><a href="#·微信web开发者工具" class="headerlink" title="·微信web开发者工具"></a><strong>·微信web开发者工具</strong></h3><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784140&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784140&token=&lang=zh_CN</a></p>
<p>以上就是微信公众号开发的一些内容，算是入门篇。其实关于微信的开发还有很多可以做的事情，而且随着需求越来越多，技术越来越完善.</p>
</body></html>]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker环境下的前后端分离部署与运维</title>
    <url>/2020/03/20/Docker-Introduction/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Docker环境下的前后端分离部署与运维"><a href="#Docker环境下的前后端分离部署与运维" class="headerlink" title="Docker环境下的前后端分离部署与运维"></a>Docker环境下的前后端分离部署与运维</h1><h2 id="Docker-虚拟机常用命令"><a href="#Docker-虚拟机常用命令" class="headerlink" title="Docker 虚拟机常用命令"></a>Docker 虚拟机常用命令</h2><ol>
<li><p>先更新软件包</p>
<pre><code class="shell">yum -y update</code></pre>
</li>
<li><p>安装 Docker 虚拟机</p>
<pre><code class="shell">yum install -y docker</code></pre>
</li>
<li><p>运行、重启、关闭 Docker 虚拟机</p>
<pre><code class="shell">service docker start
service docker start
service docker stop</code></pre>
</li>
<li><p>搜索镜像</p>
<pre><code class="shell">docker search 镜像名称</code></pre>
</li>
<li><p>下载镜像</p>
<pre><code class="shell">docker pull 镜像名称</code></pre>
</li>
<li><p>查看镜像</p>
<pre><code class="shell">docker images</code></pre>
</li>
<li><p>删除镜像</p>
<pre><code class="shell">docker rmi 镜像名称</code></pre>
</li>
<li><p>运行容器</p>
<pre><code class="shell">docker run 启动参数  镜像名称</code></pre>
</li>
<li><p>查看容器列表</p>
<pre><code class="shell">docker ps -a</code></pre>
</li>
<li><p>停止、挂起、恢复容器</p>
<pre><code class="shell">docker stop 容器ID
docker pause 容器ID
docker unpase 容器ID</code></pre>
</li>
<li><p>查看容器信息</p>
<pre><code class="shell">docker inspect 容器ID</code></pre>
</li>
<li><p>删除容器</p>
<pre><code class="shell">docker rm 容器ID</code></pre>
</li>
<li><p>数据卷管理</p>
<pre><code class="shell">docker volume create 数据卷名称  #创建数据卷
docker volume rm 数据卷名称  #删除数据卷
docker volume inspect 数据卷名称  #查看数据卷</code></pre>
</li>
<li><p>网络管理</p>
<pre><code class="shell">docker network ls 查看网络信息
docker network create --subnet=网段 网络名称
docker network rm 网络名称</code></pre>
</li>
<li><p>避免 VM 虚拟机挂起恢复之后，Docker 虚拟机断网</p>
<pre><code class="shell">vi /etc/sysctl.conf</code></pre>
<p>文件中添加<code>net.ipv4.ip_forward=1</code>这个配置</p>
<pre><code> #重启网络服务
 systemctl  restart network</code></pre></li>
</ol>
<h2 id="安装-PXC-集群，负载均衡，双机热备"><a href="#安装-PXC-集群，负载均衡，双机热备" class="headerlink" title="安装 PXC 集群，负载均衡，双机热备"></a>安装 PXC 集群，负载均衡，双机热备</h2><ol>
<li><p>安装 PXC 镜像</p>
<pre><code class="shell">docker pull percona/percona-xtradb-cluster</code></pre>
</li>
<li><p>为 PXC 镜像改名</p>
<pre><code class="shell">docker tag percona/percona-xtradb-cluster pxc</code></pre>
</li>
<li><p>创建 net1 网段</p>
<pre><code class="shell">docker network create --subnet=172.18.0.0/16 net1</code></pre>
</li>
<li><p>创建 5 个数据卷</p>
<pre><code class="shell">docker volume create --name v1
docker volume create --name v2
docker volume create --name v3
docker volume create --name v4
docker volume create --name v5</code></pre>
</li>
<li><p>创建备份数据卷（用于热备份数据）</p>
<pre><code class="shell">docker volume create --name backup</code></pre>
</li>
<li><p>创建 5 节点的 PXC 集群</p>
<p>注意，每个 MySQL 容器创建之后，因为要执行 PXC 的初始化和加入集群等工作，耐心等待 1 分钟左右再用客户端连接 MySQL。另外，必须第 1 个 MySQL 节点启动成功，用 MySQL 客户端能连接上之后，再去创建其他 MySQL 节点。</p>
<pre><code class="shell">#创建第1个MySQL节点
docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc
#创建第2个MySQL节点
docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc
#创建第3个MySQL节点
docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc
#创建第4个MySQL节点
docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc
#创建第5个MySQL节点
docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</code></pre>
</li>
<li><p>安装 Haproxy 镜像</p>
<pre><code class="shell">docker pull haproxy</code></pre>
</li>
<li><p>宿主机上编写 Haproxy 配置文件</p>
<pre><code class="shell">vi /home/soft/haproxy.cfg</code></pre>
<p>配置文件如下：</p>
<pre><code class="properties">global
    #工作目录
    chroot /usr/local/etc/haproxy
    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info
    log 127.0.0.1 local5 info
    #守护进程运行
    daemon

defaults
    log    global
    mode    http
    #日志格式
    option    httplog
    #日志中不记录负载均衡的心跳检测记录
    option    dontlognull
    #连接超时（毫秒）
    timeout connect 5000
    #客户端超时（毫秒）
    timeout client  50000
    #服务器超时（毫秒）
    timeout server  50000

#监控界面
listen  admin_stats
    #监控界面的访问的IP和端口
    bind  0.0.0.0:8888
    #访问协议
    mode        http
    #URI相对地址
    stats uri   /dbs
    #统计报告格式
    stats realm     Global\ statistics
    #登陆帐户信息
    stats auth  admin:abc123456
#数据库负载均衡
listen  proxy-mysql
    #访问的IP和端口
    bind  0.0.0.0:3306
    #网络协议
    mode  tcp
    #负载均衡算法（轮询算法）
    #轮询算法：roundrobin
    #权重算法：static-rr
    #最少连接算法：leastconn
    #请求源IP算法：source
    balance  roundrobin
    #日志格式
    option  tcplog
    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测
    option  mysql-check user haproxy
    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000
    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000
    server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000
    server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000
    server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000
    #使用keepalive检测死链
    option  tcpka</code></pre>
</li>
<li><p>创建两个 Haproxy 容器</p>
<pre><code class="shell">#创建第1个Haproxy负载均衡服务器
docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy
#进入h1容器，启动Haproxy
docker exec -it h1 bash
haproxy -f /usr/local/etc/haproxy/haproxy.cfg
#创建第2个Haproxy负载均衡服务器
docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy
#进入h2容器，启动Haproxy
docker exec -it h2 bash
haproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre>
</li>
<li><p>Haproxy 容器内安装 Keepalived，设置虚拟 IP</p>
<pre><code class="shell">#进入h1容器
docker exec -it h1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件（参考下方配置文件）
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start
#宿主机执行ping命令
ping 172.18.0.201</code></pre>
<p>配置文件内容如下：</p>
<pre><code>vrrp_instance  VI_1 {
    state  MASTER
    interface  eth0
    virtual_router_id  51
    priority  100
    advert_int  1
    authentication {
        auth_type  PASS
        auth_pass  123456
    }
    virtual_ipaddress {
        172.18.0.201
    }
}</code></pre><pre><code class="shell">#进入h2容器
docker exec -it h2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start
#宿主机执行ping命令
ping 172.18.0.201</code></pre>
<p>配置文件内容如下：</p>
<pre><code class="shell">vrrp_instance  VI_1 {
    state  MASTER
    interface  eth0
    virtual_router_id  51
    priority  100
    advert_int  1
    authentication {
        auth_type  PASS
        auth_pass  123456
    }
    virtual_ipaddress {
        172.18.0.201
    }
}</code></pre>
</li>
<li><p>宿主机安装 Keepalived，实现双击热备</p>
<pre><code class="shell">#宿主机执行安装Keepalived
yum -y install keepalived
#修改Keepalived配置文件
vi /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<p>Keepalived 配置文件如下：</p>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
           192.168.99.150
    }
}

virtual_server 192.168.99.150 8888 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 172.18.0.201 8888 {
        weight 1
    }
}

virtual_server 192.168.99.150 3306 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 172.18.0.201 3306 {
        weight 1
    }
}</code></pre>
</li>
<li><p>热备份数据</p>
<pre><code class="shell">#进入node1容器
docker exec -it node1 bash
#更新软件包
apt-get update
#安装热备工具
apt-get install percona-xtrabackup-24
#全量热备
innobackupex --user=root --password=abc123456 /data/backup/full</code></pre>
</li>
<li><p>冷还原数据<br>停止其余 4 个节点，并删除节点</p>
<pre><code class="shell">docker stop node2
docker stop node3
docker stop node4
docker stop node5
docker rm node2
docker rm node3
docker rm node4
docker rm node5</code></pre>
<p>node1 容器中删除 MySQL 的数据</p>
<pre><code class="shell">#删除数据
rm -rf /var/lib/mysql/*
#清空事务
innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/
#还原数据
innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</code></pre>
<p>重新创建其余 4 个节点，组件 PXC 集群</p>
</li>
</ol>
<h2 id="安装-Redis，配置-RedisCluster-集群"><a href="#安装-Redis，配置-RedisCluster-集群" class="headerlink" title="安装 Redis，配置 RedisCluster 集群"></a>安装 Redis，配置 RedisCluster 集群</h2><ol>
<li><p>安装 Redis 镜像</p>
<pre><code class="shell">docker pull yyyyttttwwww/redis</code></pre>
</li>
<li><p>创建 net2 网段</p>
<pre><code class="shell">docker network create --subnet=172.19.0.0/16 net2</code></pre>
</li>
<li><p>创建 6 节点 Redis 容器</p>
<pre><code class="shell">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bash
docker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bash
docker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bash
docker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bash
docker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</code></pre>
</li>
<li><p>启动 6 节点 Redis 服务器</p>
<pre><code class="shell">#进入r1节点
docker exec -it r1 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r2节点
docker exec -it r2 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r3节点
docker exec -it r3 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r4节点
docker exec -it r4 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r5节点
docker exec -it r5 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r6节点
docker exec -it r6 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf</code></pre>
</li>
<li><p>创建 Cluster 集群</p>
<pre><code class="shell">#在r1节点上执行下面的指令
cd /usr/redis/src
mkdir -p ../cluster
cp redis-trib.rb ../cluster/
cd ../cluster
#创建Cluster集群
./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre>
</li>
</ol>
<h2 id="打包部署后端项目"><a href="#打包部署后端项目" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol>
<li><p>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个 JAR 文件）</p>
<pre><code class="shell">mvn clean install -Dmaven.test.skip=true</code></pre>
</li>
<li><p>安装 Java 镜像</p>
<pre><code class="shell">docker pull java</code></pre>
</li>
<li><p>创建 3 节点 Java 容器</p>
<pre><code class="shell">#创建数据卷，上传JAR文件
docker volume create j1
#启动容器
docker run -it -d --name j1 -v j1:/home/soft --net=host java
#进入j1容器
docker exec -it j1 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar

#创建数据卷，上传JAR文件
docker volume create j2
#启动容器
docker run -it -d --name j2 -v j2:/home/soft --net=host java
#进入j1容器
docker exec -it j2 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar

#创建数据卷，上传JAR文件
docker volume create j3
#启动容器
docker run -it -d --name j3 -v j3:/home/soft --net=host java
#进入j1容器
docker exec -it j3 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar</code></pre>
</li>
<li><p>安装 Nginx 镜像</p>
<pre><code class="shell">docker pull nginx</code></pre>
</li>
<li><p>创建 Nginx 容器，配置负载均衡</p>
<p>宿主机上/home/n1/nginx.conf 配置文件内容如下：</p>
<pre><code class="properties">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream tomcat {
        server 192.168.99.104:6001;
        server 192.168.99.104:6002;
        server 192.168.99.104:6003;
    }
    server {
        listen       6101;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://tomcat;
            index  index.html index.htm;
        }
    }
}</code></pre>
<p>创建第 1 个 Nginx 节点</p>
<pre><code class="shell">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx
</code></pre>
<p>宿主机上/home/n2/nginx.conf 配置文件内容如下：</p>
<pre><code class="properties">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream tomcat {
        server 192.168.99.104:6001;
        server 192.168.99.104:6002;
        server 192.168.99.104:6003;
    }
    server {
        listen       6102;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://tomcat;
            index  index.html index.htm;
        }
    }
}</code></pre>
<p>创建第 2 个 Nginx 节点</p>
<pre><code class="shell">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
</li>
<li><p>在 Nginx 容器安装 Keepalived</p>
<pre><code class="shell">#进入n1节点
docker exec -it n1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code>vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.151
    }
}
virtual_server 192.168.99.151 6201 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6101 {
        weight 1
    }
}</code></pre><pre><code class="shell">#进入n1节点
docker exec -it n2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.151
    }
}
virtual_server 192.168.99.151 6201 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6102 {
        weight 1
    }
}</code></pre>
</li>
</ol>
<h2 id="打包部署后端项目-1"><a href="#打包部署后端项目-1" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol>
<li><p>在前端项目路径下执行打包指令</p>
<pre><code class="shell">npm run build</code></pre>
</li>
<li><p>build 目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue 的目录下面</p>
</li>
<li><p>创建 3 节点的 Nginx，部署前端项目</p>
<p>宿主机/home/fn1/nginx.conf 的配置文件</p>
<pre><code>user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6501;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn1/renren-vue;
            index  index.html;
        }
    }
}</code></pre><pre><code class="shell">#启动第fn1节点
docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre>
<p>宿主机/home/fn2/nginx.conf 的配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6502;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn2/renren-vue;
            index  index.html;
        }
    }
}</code></pre>
<pre><code class="shell">#启动第fn2节点
docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</code></pre>
<p>宿主机/home/fn3/nginx.conf 的配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6503;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn3/renren-vue;
            index  index.html;
        }
    }
}</code></pre>
<p>启动 fn3 节点</p>
<pre><code class="shell">#启动第fn3节点
docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</code></pre>
</li>
<li><p>配置负载均衡</p>
<p>宿主机/home/ff1/nginx.conf 配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream fn {
        server 192.168.99.104:6501;
        server 192.168.99.104:6502;
        server 192.168.99.104:6503;
    }
    server {
        listen       6601;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://fn;
            index  index.html index.htm;
        }
    }
}</code></pre>
<pre><code class="shell">#启动ff1节点
docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
<p>宿主机/home/ff2/nginx.conf 配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream fn {
        server 192.168.99.104:6501;
        server 192.168.99.104:6502;
        server 192.168.99.104:6503;
    }
    server {
        listen       6602;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://fn;
            index  index.html index.htm;
        }
    }
}</code></pre>
<pre><code class="shell">#启动ff2节点
docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
</li>
<li><p>配置双机热备</p>
<pre><code class="shell">#进入ff1节点
docker exec -it ff1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.152
    }
}
virtual_server 192.168.99.151 6701 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6601 {
        weight 1
    }
}</code></pre>
<pre><code class="shell">#进入ff1节点
docker exec -it ff2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.152
    }
}
virtual_server 192.168.99.151 6701 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6602 {
        weight 1
    }
}</code></pre>
<p>​</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA-Cache</title>
    <url>/2020/03/19/PWA-Cache/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="PWA-CacheStorage-API"><a href="#PWA-CacheStorage-API" class="headerlink" title="PWA-CacheStorage API"></a>PWA-CacheStorage API</h1><blockquote>
<p>Progressive Web App （PWA）是渐进增强 Web App，它能让我们在不可靠的网络上也能快速加载、能够接收桌面通知、具有桌面图标，并且可采用顶层全屏体验的方式加载。</p>
</blockquote>
<p><a href="http://cdn.semlinker.com/cache-storage-api.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/cache-storage-api.png" class="lazyload"></a></p>
<p>  在 PWA 学习笔记之 fetch API 这篇文章中，我们介绍 fetch API 相关的一些基础知识，在该文章末尾我们还介绍了它在 PWA 应用中的使用场景，在具体的使用示例中，我们应用了 CacheStorage API。CacheStorage API（缓存存储应用程序接口），顾名思义是用来实现资源存储。该接口提供缓存 Request /Response 对象对的存储机制，尽管它被定义在 service worker 的标准中，但它不一定要配合 service worker 使用，接下来我们就来会一会 CacheStorage API。<br>  首先我们来回顾一下 fetch API 文章中使用的示例：</p>
<pre><code>self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 若缓存不存在，则使用fetch API从网上获取，然后利用Cache API缓存资源。
      return response || fetch(event.request).then((response) => {
          return caches.open('v1').then((cache) => {
            cache.put(event.request, response.clone());
            return response;
          });
     }); 
   })
  );
});</code></pre><p>  这个示例中，我们监听页面的 fetch 事件，对页面请求事件进行拦截，然后使用 event.respondWith 设置响应对象。在设置响应对象时，我们会优先从缓存中获取，若请求命中，则直接从缓存中获取已缓存的对象，直接返回。若请求未命中，则通过 fetch API 从远程获取对应的资源，当资源请求成功时，我们通过 open 方法获取 v1 版本的 CacheStorage 实例，然后调用该实例的 put 方法，进行资源缓存。<br>  这里需要注意的是，在使用 cache对象的 put 方法保存资源时，我们调用 response 对象的 clone 方法，而不是直接保存 response 对象。为什么需要克隆响应对象呢？这是因为 Request 和 Response 的 body （响应体）只能被读取一次！它们有一个属性叫 bodyUsed，读取一次之后设置为 true，就不能再读取了。<br>  通过上面的示例，我们简单介绍了 CacheStorage API 中的一些常用方法。接下来我们趁热打铁，来系统地了解一下目前 CacheStorage 已有的 API。</p>
<h2 id="1-CacheStorage-API-简介"><a href="#1-CacheStorage-API-简介" class="headerlink" title="1.CacheStorage API 简介"></a>1.CacheStorage API 简介</h2><blockquote>
<p>CacheStorage.match()：返回一个 Promise 对象，用于判断给定的请求对象是否已被缓存。若匹配则返回已缓存的对象。</p>
</blockquote>
<pre><code>caches.match(request, options).then(function(response) {
  // Do something with the response
});</code></pre><blockquote>
<p>CacheStorage.has()：返回一个 Promise 对象，用于判断 cacheName 对应的 Cache 对象是否存在。若 cacheName 对应的 Cache 对象存在，则返回 true 否则返回 false。</p>
</blockquote>
<pre><code>caches.has(cacheName).then(function(boolean) {
  // true: 缓存存在
});</code></pre><blockquote>
<p>CacheStorage.open()：返回一个 Promise 对象，用于获取 cacheName 对应的 Cache 对象。若 cacheName 对应的 Cache 存在则返回对应的 Cache 对象，若不存在的话，则会创建一个新的 Cache 对象。</p>
</blockquote>
<pre><code>caches.open(cacheName).then(function(cache) {
  // Do something with your cache
});</code></pre><blockquote>
<p>CacheStorage.delete()：返回一个 Promise 对象，用于删除 cacheName 对应的 Cache 对象。若 cacheName 对应的 Cache 对象存在且被成功删除，则返回 true，否则返回 false。</p>
</blockquote>
<pre><code>caches.delete(cacheName).then(function(true) {
  //your cache is now deleted
});</code></pre><blockquote>
<p>CacheStorage.keys()：返回一个 Promise 对象，用于获取 CacheStorage 对象中已存在的缓存名称列表。</p>
</blockquote>
<pre><code>caches.keys().then(function(keyList) {
  //do something with your keyList
});</code></pre><blockquote>
<p>CacheStorage API 使用示例</p>
</blockquote>
<pre><code>CacheStorage.match()
caches.match(event.request).then(function(response) {
  return response || fetch(event.request).then(function(r) {
    caches.open('v1').then(function(cache) {
      cache.put(event.request, r);
    });
    return r.clone();
  });
}).catch(function() {
  return caches.match('/sw-test/gallery/myLittleVader.jpg');
});
CacheStorage.has()
caches.has('v1').then(function(hasCache) {
  if (!hasCache) { // v1对应的Cache对象不存在
    someCacheSetupfunction();
  } else {
    caches.open('v1').then(function(cache) {
      return cache.addAll(myAssets);
    });
  }
}).catch(function() {
  // 处理异常
});
CacheStorage.open()
var cachedResponse = caches.match(event.request)
 .catch(function() {
    return fetch(event.request);
  }).then(function(response) {
    caches.open('v1').then(function(cache) {
      cache.put(event.request, response);
  });
  return response.clone();
}).catch(function() {
  return caches.match('/sw-test/gallery/myLittleVader.jpg');
});
CacheStorage.delete() & caches.keys()
this.addEventListener('activate', function(event) {
  var cacheWhitelist = ['v2']; // 缓存的白名单
  event.waitUntil(
    caches.keys().then(function(keyList) { // 返回已缓存的缓存名称列表
      return Promise.all(keyList.map(function(key) {
        if (cacheWhitelist.indexOf(key) === -1) { // 删除不含有v2的缓存对象
          return caches.delete(key);
        }
      }));
    })
  );
});</code></pre><p>  以上 CacheStorage API 相关示例来源于 MDN - CacheStorage 缓存存储。一口气分析完了 CacheStorage 相关的 API，不知道小伙伴有没有疑问。感觉对刚了解 PWA 的小伙伴们来说，会对示例中所使用的 fetch 或 activate 事件感到疑惑，这个不用着急。后续的文章我们会来揭开它们神秘的面纱。</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><p>  本文介绍了 CacheStorage API 的相关基础知识，最后我们来介绍一个小知识 —— 如何查看已缓存的资源？其实这个很简单，容我偷个懒，这里只介绍 Chrome 浏览器如何查看。准备好了么？Follow Me！</p>
<blockquote>
<ol>
<li>打开 Chrome 浏览器；</li>
<li>打开开发者工具；</li>
<li>切换到 Application Tab 页；</li>
<li>选择左侧 Cache 菜单下的 CacheStorage 选项。</li>
<li>初探 CacheStorage API 到此结束，下一篇就是介绍我们的 Service Workers 了，它可是 PWA 的核心 “人物 ” 哟。目前刚开始学习 PWA，有误之处，请小伙伴们多多指教。</li>
</ol>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA-Fetch</title>
    <url>/2020/03/19/PWA-Fetch/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="PWA-fetch-API"><a href="#PWA-fetch-API" class="headerlink" title="PWA-fetch API"></a>PWA-fetch API</h1><blockquote>
<p>Progressive Web App （PWA）是渐进增强 Web App，它能让我们在不可靠的网络上也能快速加载、能够接收桌面通知、具有桌面图标，并且可采用顶层全屏体验的方式加载。</p>
</blockquote>
<p><a href="http://cdn.semlinker.com/pwa-fetch-api.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/pwa-fetch-api.png" class="lazyload"></a></p>
<h2 id="1-PWA-简介"><a href="#1-PWA-简介" class="headerlink" title="1. PWA 简介"></a>1. PWA 简介</h2><p>Progressive Web App 具有的以下主要特点：</p>
<ul>
<li>渐进式 - 适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</li>
<li>自适应 - 适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。</li>
<li>持续更新 - 在服务工作线程更新进程的作用下时刻保持最新状态。</li>
<li>安全 - 通过 HTTPS 提供，以防止窥探和确保内容不被篡改。</li>
<li>可安装 - 用户可免去使用应用商店的麻烦，直接将对其最有用的应用“保留”在主屏幕上。</li>
<li>可链接 - 可通过网址轻松分享，无需复杂的安装。</li>
</ul>
<p>  PWA 基于很多新的 API 和新的技术，如 fetch API、CacheStorage API、Background Sync、Service Worker 和 IndexedDB 等。然而要想真正了解并掌握 PWA，就必须了解它背后基于的技术。因此后续的文章，我们将逐一介绍 PWA 的相关技术。有兴趣的小伙伴们赶紧上车，我们将从 fetch API 开始，开启 PWA 的学习旅程。</p>
<h2 id="2-fetch-API"><a href="#2-fetch-API" class="headerlink" title="2.fetch API"></a>2.fetch API</h2><p>  fetch 中文的意思为获取，即通过它我们可以用来获取资源。在前端的日常工作中，我们通常需要从 API 获取数据，然后对数据进行处理或展示。在与服务器交互过程中使用的数据格式一般是 JSON，接下来我们先来体验一下，利用 fetch API 获取 angular 项目的团队的前五位成员，实现代码如下：</p>
<pre><code>if("fetch" in this) {
  fetch("https://api.github.com/orgs/angular/members?page=1&per_page=5")
    .then(res => res.json())
    .then(console.dir)
}</code></pre><p>  要实现同样的功能，我们当然也可以使用 XMLHttpRequest 对象，实现代码如下：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', "https://api.github.com/orgs/angular/members?page=1&per_page=5");
xhr.responseType = 'json';
xhr.onload = function() {
  console.dir(xhr.response);
};
xhr.send();</code></pre><p>  是不是感觉使用 fetch 简单很多，然而我们并不能随心所欲的使用它，因为它有兼容性问题，具体如下下图所示 （详细信息可浏览  <a href="https://www.caniuse.com" target="_blank" rel="noopener" ">can i use</a>- fetch）：</p>
<p><a href="http://cdn.semlinker.com/can-i-use-fetch-api.jpg" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/can-i-use-fetch-api.jpg" class="lazyload"></a></p>
<p>  对于大多数小伙伴来说，应该更熟悉 jQuery.ajax()，fetch 规范与 jQuery.ajax() 的主要区别如下：<br>  当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject。<br>  默认情况下, fetch 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置credentials 选项）。<br>  除了使用 fetch API 来获取 JSON 数据，我们也可以使用它来获取其它资源，比如普通文本、图片资源等。下面我们来看一下如何使用 fetch API 来获取图片资源，并在页面中显示。</p>
<pre><code>if ("fetch" in this) {
  let myImage = document.querySelector('img');
  fetch('https://mdn.github.io/dom-examples/streams/grayscale-png/tortoise.png')
    .then(function(response) {
       return response.blob();
    })
    .then(function(myBlob) {
       let objectURL = URL.createObjectURL(myBlob);
       myImage.src = objectURL;
    });
}</code></pre><p>  前面的两个示例中，我们通过 fetch 方法分别实现 JSON 数据的读取和图片的资源的获取功能。fetch 方法是 Fetch API 的核心方法，同时定义在 window 和 WorkerGlobalScope 环境中，因此我们可以在 Service Worker 环境中使用它。</p>
<blockquote>
<p>在 Fetch 标准 中该方法的声明如下：</p>
</blockquote>
<pre><code>partial interface WindowOrWorkerGlobalScope {
  [NewObject] Promise<response> fetch(RequestInfo input, optional RequestInit init);
};</response></code></pre><p>  通过观察上面的方法签名，我们可以知道 fetch 方法支持两个参数，调用后返回一个 Promise 对象。第二个参数是一个参数对象，用来初始化 Request。该参数对象有几个重要的属性：</p>
<ul>
<li>method：请求方法，可取 “GET”, “POST” 等，默认为 “GET”。</li>
<li>mode：请求模式，可取 “no-cors”, “cors”, “same-origin”。</li>
<li>credentials：是否携带 Cookie，可取：”omit”, “same-origin”,”include”。</li>
<li>cache: 缓存模式，可取: default, no-store, reload, no-cache, force-cache, only-if-cached。</li>
</ul>
<blockquote>
<p>了解详细的信息，请阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch。" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch。</a></p>
</blockquote>
<p>  在 PWA 应用中，fetch API 的用武之地在于资源（比如图片、脚本文件或样式文件等）的获取。为了能够保证用户的离线体验，我们可以在获取资源时，对资源进行缓存。<br>具体示例如下：</p>
<pre><code>self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 若缓存不存在，则使用fetch API从网上获取，然后利用Cache API缓存资源。
      return response || fetch(event.request).then((response) => {
          return caches.open('v1').then((cache) => {
            cache.put(event.request, response.clone());
            return response;
          });
     }); 
   })
  );
});</code></pre><p>  对于 Cache API，我们下一篇会介绍。这里需要注意的是，在使用 cache.put() 保存资源时，我们调用 response 对象的 clone() 方法，而不是直接保存 response 对象。为什么需要克隆响应对象呢？这是因为 Request 和 Response 的 body （响应体）只能被读取一次！它们有一个属性叫 bodyUsed，读取一次之后设置为 true，就不能再读取了。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本文只是简单介绍了 fetch API，其实 fetch API 还有很多东西需要进一步了解，如设置请求头、处理 Text/HTML 资源、表单提交、Cookies 与 CORS 处理等。这里就不再展开了，有兴趣的小伙伴，请自行查阅相关资料。</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>初谈软件架构与前端架构演进</title>
    <url>/2020/03/03/Front-End-Construct/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="初谈软件架构及前端架构演进"><a href="#初谈软件架构及前端架构演进" class="headerlink" title="初谈软件架构及前端架构演进"></a>初谈软件架构及前端架构演进</h1><h2 id="1、什么是软件架构？"><a href="#1、什么是软件架构？" class="headerlink" title="1、什么是软件架构？"></a>1、什么是软件架构？</h2><a href="https://goss3.cfp.cn/creative/vcg/nowarter800/version2/168582954.jpg?x-oss-process=image/format,webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img align="center" max-width="400" data-src="https://goss3.cfp.cn/creative/vcg/nowarter800/version2/168582954.jpg?x-oss-process=image/format,webp" class="lazyload"></a>
  人人都在说软件架构，但人们并不能给出一个准确的定义，就像Martin Folwer在《Making Architecture Matter》上分享说的，<font color="red">Architecture is about the important stuff. Whatever that is</font>。

<p>  软件界的人们长期以来一直在争论架构的定义。对于某些人来说，这就像是系统的基本结构，或者是将最高级别的组件连接在一起的方式。但Martin认为没有客观的方法来定义基本的或高级的组件，软件架构的更多是专家开发人员对于系统的设计的共同理解。</p>
<p>  架构的第二种常见定义是，它是“需要在项目早期就做出的设计决策”，但是Martin觉得更像是在项目开发过程中你期望能够早日做出的正确决策。</p>
<p>  因此，软件架构是关于软件开发中重要的事情。思考软件架构其实就是思考哪些是最重要的事情，并且要保持这些部分始终运行在良好的状态下。<br><a href="img/02.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/02.jpg" class="lazyload"></a><br><font color="red">软件架构通常涵盖三个部分：</font></p>
<blockquote>
<p>架构模型：定义了系统组件是如何组织和拼装的，明确系统的组件模块，划分各自边界以及如何组合在一起。<br>通信接口：定义了系统组件之间是如何进行通信的，通常指的是组件/模块之间的通信方式、接口定义、API。<br>质量要求：定义了非功能性的系统要求，例如扩展性、稳定性、高可用性、高并发、高性能、安全等等。</p>
</blockquote>
<p><a href="img/03.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/03.jpg" class="lazyload"></a></p>
<p><font color="red">不同阶段构成架构的因素是不同的，基于这个思路，架构设计可以分为四个层级：</font></p>
<blockquote>
<p>系统级，即应用在整个系统内的关系，如与后台服务如何通信，与第三方系统如何集成。<br>应用级，即应用外部的整体架构，如多个应用之间如何共享组件、如何通信等。<br>模块级，即应用内部的模块架构，如代码的模块化、数据和状态的管理等。<br>代码级，即从基础设施来保障架构实施。</p>
</blockquote>
<p><a href="img/04.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/04.jpg" class="lazyload"></a></p>
<h2 id="2、为什么软件架构很重要？"><a href="#2、为什么软件架构很重要？" class="headerlink" title="2、为什么软件架构很重要？"></a>2、为什么软件架构很重要？</h2><p>  软件架构代表了软件内部是组织运作的方式，这个往往并不会被用户所感知，因此，软件架构在某些时候会被忽略。</p>
<p>  对于用户而言，良好的用户界面和系统运行错误是能够被感知的，而内部的模块化设计并不会被感知，于是，良好的架构设计是很难被衡量的。</p>
<p><a href="img/05.png" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/05.png" class="lazyload"></a></p>
<p>  架构的根本价值在于能够降低未来功能开发的成本。</p>
<p>  如上图所示，对于架构糟糕的系统而言，其初始的开发速度是比较快的，但是随着时间的推移，要在其上面添加新功能变的越来越困难。开发人员需要花更多的时间理解原有的代码，需要更多的时间进行测试，并且很容易出现问题需要修复。</p>
<p>  对于架构良好的系统而言，虽然其初始的开发速度不快，但随着时间的推移，其研发效率将会变得很快，并且易于扩展。</p>
<p>  可悲的是，软件开发人员通常不能很好地解释这种情况。管理者不想让开发人员编写高质量的代码，因为它花费的时间太长。我们习惯于在生活中进行大多数决定的成本与质量之间的通常取舍，对软件的内部质量没有意义。由于成本与内部质量之间的关系是不寻常且违反直觉的关系，因此，良好的软件架构在长期而言是非常重要的。</p>
<h2 id="3、有哪些架构设计模型？"><a href="#3、有哪些架构设计模型？" class="headerlink" title="3、有哪些架构设计模型？"></a>3、有哪些架构设计模型？</h2><p><a href="img/06.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/06.jpg" class="lazyload"></a></p>
<p>  对于软件架构设计模型，我们可以从两个层面来看。第一个层面对应的是系统的情况，所有功能在一个单一巨石系统(Monolithic)、基于服务的系统(Service-based)和分布式系统(Dsitributed)。</p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>对于巨石系统而言，通常的软件架构方式是基于分层设计。</p>
<p><a href="img/07.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/07.jpg" class="lazyload"></a></p>
<p>通过分层设计可以将系统进行解耦拆分，每一层都会专注于自己的功能，并且提供对外暴露的接口以供上层调用。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>对于基于服务的系统而言，通常的软件架构方式是微服务架构。</p>
<p><a href="img/08.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/08.jpg" class="lazyload"></a></p>
<p>通过将一个巨大的系统拆分成一个个独立的、单独部署的服务(Service)，可以让系统变成松耦合的状态。服务之间通过API进行通信，并且所有的服务通过特定的组织方式整合在一起共同工作。</p>
<p>每个小服务都在自己的进程中运行并与轻量级通信机制（通常是HTTP API）进行通信。这些服务围绕业务功能构建，并且可以由全自动部署机制独立部署。这些服务几乎没有集中管理，它可以用不同的编程语言编写并使用不同的数据存储技术。尽管微服务的优势使它们在最近几年变得非常时尚，但它们却带来了分销增加，一致性降低的缺点，并且要求运维管理成熟。</p>
<h3 id="插件式架构-Service-Oriented-Architecture"><a href="#插件式架构-Service-Oriented-Architecture" class="headerlink" title="插件式架构(Service Oriented Architecture)"></a>插件式架构(Service Oriented Architecture)</h3><p><a href="img/09.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/09.jpg" class="lazyload"></a></p>
<p>插件式的架构体系，通常由一个核心系统(Kernal系统)和一系列插件组成。核心系统提供了最小可用的功能，通过插件来不断扩展系统能力。浏览器、文本编辑器、IDE等系统就都是采用插件式架构体系。</p>
<h2 id="4、前端架构演进"><a href="#4、前端架构演进" class="headerlink" title="4、前端架构演进"></a>4、前端架构演进</h2><p><a href="img/10.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/10.jpg" class="lazyload"></a></p>
<p>前端过去十年发展经历了巨大的变化，从PC时代进入了移动时代再到智能时代，前端架构也从无到有，逐步演进变得百花齐发。</p>
<h3 id="前后端分离架构"><a href="#前后端分离架构" class="headerlink" title="前后端分离架构"></a>前后端分离架构</h3><p><a href="img/11.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/11.jpg" class="lazyload"></a></p>
<p>随着前后端分工划分越来越明确，前后端系统也逐步分离。前端系统变成了静态前端资源，部署HTML、JS、CSS文件，后端服务提供API（通常是REST API），前后端通过API进行通信。</p>
<p>前后端分离解决了前后端分工的问题，但是随着移动互联网到来，前端变成多端状态（PC、iOS、Android），因此后端服务需要针对不同端提供定制化服务，前后端协同沟通成本开始变大。</p>
<p>于是，Node BFF应运而生。通过Node层，前端的研发人员就可以来编写后端服务的适配层，用于接口的整合编排、字段裁剪，甚至服务端渲染直出提升首屏性能。</p>
<p>Node服务虽然可以进一步提升前后端协同的效率，但是Node服务器的运维、部署、发布、监控等等成本也让前端研发同学苦不堪言。Serverless的诞生可以帮助解决这个问题，可以将服务器的运维功能都交给Serverless平台进行管理，研发人员只需要专注于实现函数即可完成功能开发。</p>
<p><a href="img/12.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/12.jpg" class="lazyload"></a></p>
<p>在前后端分离BFF，除了采用Node层技术以外还可以采用GraphQL技术，通过GraphQL技术可以很容易使用Schema来定义需要获取的数据结构，灵活的对现有数据源进行聚合和字段裁剪。</p>
<h3 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h3><p><a href="img/13.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/13.jpg" class="lazyload"></a><br>组件化架构是前端一个最为显著的架构方式，通过组件的封装和组合，可以快速的进行页面UI的搭建。</p>
<p>组件化也经历了不同阶段的演进：<br>组件库：以Ant Design、Element为代表，提供一系列统一设计语言的原子组件。<br>模板库：以Ant Design Pro为代表，提供一系列的组件模板/页面模板，例如用户详情页、登录页等等，方便快速搭建功能页面。<br>配置化：以Fusion Design、飞冰、云凤蝶为代表，通过可视化拖拽来自由拼装页面，进一步提升前端研发效率。</p>
<h3 id="分层架构-1"><a href="#分层架构-1" class="headerlink" title="分层架构"></a>分层架构</h3><p><a href="img/14.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/14.jpg" class="lazyload"></a></p>
<p>不论是MVC（Model-View-Controller）还是MPV（Model-Presenter-View）模式，都是将数据、界面、控制分离的方式。通过代码职责的拆分可以有效的将系统进行解耦，从而让各自部分能够很好的分工并且协同。<br><a href="img/16.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/16.jpg" class="lazyload"></a></p>
<p>随着页面逻辑复杂度提升，又演化出Redux、Mobx等数据流控制的框架，进一步将数据控制部分拆分成Store、Action、Dispatcher，避免了数据更改的混乱，将数据管理进行了统一，规范了数据修改的方式。<br><a href="img/17.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/17.jpg" class="lazyload"></a></p>
<p>Clean Architecture是分层架构的一种形态，分为Entities、User Case、Controllers、UI四层，外部层级是依赖内部层级，内部层级会对外暴露接口，但是避免暴露内部实现，所以越是上层的功能可以屏蔽掉内部的变化，降低层级之间的耦合度。</p>
<h3 id="微前端架构"><a href="#微前端架构" class="headerlink" title="微前端架构"></a>微前端架构</h3><p><a href="img/18.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/18.jpg" class="lazyload"></a></p>
<p>微前端架构是一种将微服务理念应用到浏览器，将多个小型前端应用聚合为一的应用。微前端架构可以允许各自小型应用独立部署、独立的技术栈，因此，特别适合遗留老旧系统的整合。</p>
<p>不必花费大量人力对老旧系统进行技术栈升级，通过微前端架构即可将其整合到新应用中。在新应用中可以使用新技术栈，老应用技术栈保持原状，两者功能上又可以进行通信和整合。</p>
<h2 id="5、写在最后"><a href="#5、写在最后" class="headerlink" title="5、写在最后"></a>5、写在最后</h2><p>软件架构也“没有银弹”，不存在某个普世好用的架构。软件架构总是伴随着业务功能的发展、系统稳定性、并发性不断发展而不断演进的。结合业务发展的规模，人员的能力，找到最适合你的架构才是最好的架构设计。<br><a href="img/19.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/19.jpg" class="lazyload"></a><br>最后，推荐几本关于软件架构的经典著作，如果有推荐的书籍欢迎留言交流。</p>
</body></html>]]></content>
      <categories>
        <category>前端架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
        <tag>前端</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjs中的Subjects</title>
    <url>/2020/03/01/Rxjs-Subjects/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>#彻底搞懂RxJS中的Subjects</p>
<p>  每周大约有1700万次npm下载，RxJS在JavaScript世界中非常受欢迎。如果您是Angular开发人员，则不会错过RxJS Observables，但您可能对Subjects不太熟悉。虽然它们不像简单的Observable被频繁使用，但还是非常有用的。了解它们将帮助我们编写更好，更简洁的响应式代码。</p>
<h2 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h2><blockquote>
<p>直观地，我们可以将Observables视为发出值流的对象，或者按照RxJS文档所述：Observables是多个值的惰性Push集合。</p>
</blockquote>
<p>例如，我们可以使用Observables每秒发出0到59之间的数字：</p>
<pre><code>import { Observable } from 'rxjs';
const observable = new Observable((subscriber) => {
  for (let i = 0; i < 60; i += 1) {
    setTimeout(() => {
      subscriber.next(i);
    }, i * 1000);
  }
});
observable.subscribe((value) => {
  console.log(`Observer receives: ${value}`);
});</code></pre><p>  需要订阅Observable才能开始计数，这与调用函数的方式相同。同样类似于函数，第二个”调用”将触发新的独立执行。如果两秒钟后再次订阅此Observable，我们将在控制台中看到两个”计数器”，第二个计数器有两秒钟的延迟。</p>
<pre><code>import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
  for (let i = 0; i < 60; i += 1) {
    setTimeout(() => {
      subscriber.next(i);
    }, i * 1000);
  }
});

console.log('First observer subscribes');
observable.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  observable.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);</code></pre><p>  这意味着我们不能同时向两个观察者发出相同的值，至少不能使用简单的Observable。因此，需要Subject。</p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><blockquote>
<p>Subject就像一个可观察对象，但是可以多播到许多观察者。</p>
</blockquote>
<p>  Subject也是可观察的。我们可以使用Subject创建每秒发射0到59的相同计数器：</p>
<pre><code>import { Subject } from 'rxjs';

const subject = new Subject();

console.log('Observer subscribes');
subject.subscribe((value) => {
  console.log(`Observer receives: ${value}`);
});

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    subject.next(i);
  }, i * 1000);
}</code></pre><p>  您可能会发现我们之前的示例的主要区别。在声明一个Observable时，我们提供了一个函数作为参数，告诉Observable向用户发出什么。可以，因为每个新订户都将开始新的执行。另一方面，在这种情况下，我们只有一个执行，而新订户只是开始“监听”它。我们只需使用new Subject（）创建一个新对象。<br>  我们也可以订阅主题，因为主题是可观察的。然后，我们直接调用主题，因为主题是观察者。<br>  任何新订户将被添加到主题在内部保留的订户列表中，并且同时将获得与其他订户相同的值。如果我们在第一次订阅后两秒钟订阅主题，则新订阅者将错过前两个值：</p>
<pre><code>import { Subject } from 'rxjs';

const subject = new Subject();

console.log('First observer subscribes');
subject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  subject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    subject.next(i);
  }, i * 1000);
}</code></pre><p>我们可以使用Subject一次向多个观察者发出值。</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>  Subject可能存在的问题是，观察者将仅收到订阅主题后发出的值。<br>在上一个示例中，第二个发射器未接收到值0、1和2。有时，我们需要在订阅该对象之前，知道该对象最后一次发射了哪个值。例如，如果我们发出日期，情况就是这样。任何在3月1日订阅的观察者，无论何时订阅，都将获得3月1日的订阅。在午夜，每个订阅者都会收到日期已更改的通知。<br>  对于这种情况，可以使用BehaviorSubject。BehaviorSubject保留其发出的最后一个值的内存。订阅后，观察者立即接收到最后发出的值。如果我们改编前面的示例，这意味着第二个观察者在订阅时收到值2，然后像第一个观察者一样接收之后的所有其他值。</p>
<pre><code>import { BehaviorSubject } from 'rxjs';

const behaviorSubject = new BehaviorSubject(0);

for (let i = 1; i < 60; i += 1) {
  setTimeout(() => {
    behaviorSubject.next(i);
  }, i * 1000);
}

console.log('First observer subscribes');
behaviorSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  behaviorSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);</code></pre><p>  您可能已经在示例中注意到，我们需要为BehaviorSubject提供一个初始值，而Subject则不需要。这是因为BehaviorSubject始终需要当前值。</p>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>  ReplaySubjects与BehaviorSubjects非常相似。所不同的是，他们不仅记住了最后一个值，还记住了之前发出的多个值。订阅后，它们会将所有记住的值发送给新观察者。<br>在创建时不给它们任何初始值，而是定义它们应在内存中保留多少个值。在示例中，我们保留两个值：</p>
<pre><code>import { ReplaySubject } from 'rxjs';

const replaySubject = new ReplaySubject(2);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    replaySubject.next(i);
  }, i * 1000);
}

console.log('First observer subscribes');
replaySubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
    replaySubject.subscribe((value) => {
      console.log(`Second observer receives: ${value}`);
    });
}, 2000);</code></pre><p>  当第二个观察者订阅ReplaySubject时，已经发出0、1和2。由于ReplaySubject保留了最后两个值，第二个观察者立即收到1和2。</p>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>  使用AsyncSubjects，在主题完成之前，观察者实际上什么也没收到。</p>
<pre><code>import { AsyncSubject } from 'rxjs';

const asyncSubject = new AsyncSubject();

console.log('First observer subscribes');
asyncSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    asyncSubject.next(i);
    if (i === 59 ) {
      asyncSubject.complete();
    }
  }, i * 1000);
}</code></pre><p>  在我们的示例中使用AsyncSubject，我们必须等待一分钟，然后观察者才能收到东西。<br>  我们必须完成主题。如果不这样做，我们的观察者将一无所获。<br>  在AsyncSubject完成后订阅的任何观察者将收到相同的值。</p>
<pre><code>import { AsyncSubject } from 'rxjs';

const asyncSubject = new AsyncSubject();

console.log('First observer subscribes');
asyncSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    asyncSubject.next(i);
    if (i === 59 ) {
      asyncSubject.complete();
    }
  }, i * 1000);
}

setTimeout(() => {
  console.log('Third observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Third observer receives: ${value}`);
  });
}, 65000);</code></pre><p>  在此示例中，第三个观察者在AsyncSubject完成五秒钟后对其进行订阅。订阅时，它将收到最后一个值：59。<br>  这使得AsyncSubjects对于获取和缓存值很有用，例如HTTP响应，我们只希望获取一次，但是以后可以从其他位置进行访问。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>  自己尝试这些示例并对其进行修改，以了解其如何影响结果。对RxJS主题的深入了解将有助于我们在响应式编程方面编写更具可读性和更高效的代码。</p>
</body></html>]]></content>
      <categories>
        <category>Rxjs</category>
      </categories>
      <tags>
        <tag>Rxjs</tag>
        <tag>Subjects</tag>
        <tag>Angular</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年2月末端</title>
    <url>/2020/02/29/leapYear/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>四年一遇的日子<br>我数着远处多汁的河流<br>树木、车辆、人影<br>灯火和建筑<br>我数着一切热爱和悲伤<br>窗外突然下起小雨<br>淅淅沥沥<br>少年悄悄低头<br>在记事本上写下了心里的秘密<br>留给，四年后的自己~</p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>2019吧</title>
    <url>/2020/01/01/summary2019/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="2019吧"><a href="#2019吧" class="headerlink" title="2019吧"></a>2019吧</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>  2020年的第一天了，我想我应该写点什么。嗯~不得不感慨时间过得太快，记忆中的2019仿佛一片空白，但是细细回味之后，这一年许多人许多事都还历历在目。<br>  2019年过去，2020的到来。踏过本命年，仿佛意识到自己确实已经不小了。但一想到自己的现状，只能说：<font color="red"> 革命尚未成功，我辈仍需继续努力！！！ </font></p>
<blockquote>
<p>灵魂拷问: 时间回到2019年年初，你当时立下的flag，现在又完成了多少呢？</p>
</blockquote>
<p>  2019年是我毕业后的第二年，已经不能厚脸皮说自己还是个学生、是个职场新人，到目前为止已经过去2年2个月了(2017.10)，如果要是算年头的话，2020年已经是我成为程序员的第4个年头了，看着这些数据真的是细思极恐，哇不忍直视！</p>
<p>  然写想着是写2019年度总结，写着写着，我更想借此对自己从参加工作到现在的生活和工作进行梳理。整理过去的人和事，确定今后的方向（立flag），轻装上阵。</p>
<p>  那闲话不多说，既然是总结，那就先对这过去的<font color="red"> 3 </font>个年头做一个简单的回溯吧</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><blockquote>
<p>2017有很多遗憾，难过和委屈，那年匆匆</p>
</blockquote>
<p>网易云热评上看到过这样一句话：</p>
<blockquote>
<p>跨越数千公里，只身来到一个陌生的城市，火车站凌晨昏黄的灯光照在脸上时大概是一个人最孤独的时候吧。</p>
</blockquote>
<p>虽然我没决定去远方，但我依然孤独</p>
<p>然而生活中谁又何尝不是负重前行，忍受孤独呢？我们都是平凡的普通人，所以你只管努力，其他的交给时间就好。</p>
<h3 id="年度关键字"><a href="#年度关键字" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>毕设</li>
<li>毕业</li>
<li>转换</li>
<li>萌新</li>
<li>起点</li>
<li>努力</li>
</ul>
<h3 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h3><p>  毕业之年，用完了快乐，没有毕业旅行；2017.4 2017.11 2017.12，接连参加了省考、国考、研究生考；那时候也算是初生牛犊不怕虎，眼高手低，真是一波未平一波又起，于是我习惯了失望；我还是决定当个普通人吧，于是12月底拿到一家软件公司offer，这才有种如梦初醒的感觉（我是谁？我在哪？我怎么跑这来了？？？），晃悠晃悠到了现在的公司</p>
<h3 id="工位"><a href="#工位" class="headerlink" title="工位"></a>工位</h3><p>  入职后来到一个新的环境，新的事物新的朋友，公司安排了宿舍，现在想想真的很温馨，大家对我都很关照。记得那时上手的技术大部分都没用过。学习之路-路漫漫其修远兮，吾将上下而求索</p>
<h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>  12月就是一个接收新事物的一个月，学习到新的技术，认识到新的朋友。那段时间也许是出于自身的焦虑，也或许是作为实习生应该要有一个努力上进的态度，每晚都在办公室学习，造轮子很久。</p>
<p>  时间过得很快，每天过着充实的学习生活，当时就像一片海绵，疯狂的吸取自己缺少的那些水分。记得当时已经开始帮同事解决禅道上的一些小bug（当时还用的禅道haha），直到年底，12月底，项目组接到了一个新的项目，我也有幸成为了项目的一员。当时我也不会想到这个项目一作就做到了现在，而且做到现在最初的那些开发人员也就只剩下了我和*，那些熟悉的面孔逐渐变成陌生又慢慢变为熟悉。</p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>  一辈子有很多夏天，但没有任何一个夏天像今夏</p>
<p>  2018年见了太多的别离，2018年也是毕业那年，记得那年夏天，记得那些人，四年美好的回忆</p>
<h3 id="年度关键字-1"><a href="#年度关键字-1" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>项目</li>
<li>自律</li>
<li>运动</li>
<li>博客</li>
<li>涨薪</li>
<li>全栈</li>
<li>出差</li>
<li>累</li>
</ul>
<p>  2018算是自己人生中历史性的一年吧，这一年正式摇身一变成为一名社会银，这一年正真开始了自己的程序生涯。</p>
<p> ###博客、分享<br>  回到公司，我开始迷上了一个东西：博客</p>
<p>  最初对于博客一直有敬畏之心，觉着能发表博客的都是大佬，都是业界大牛，这种想法直到我参加了一次小组的技术分享后发生了转变。</p>
<p>  以前在学校虽然也组织一些活动，参加一些活动，但是那些都是在自己熟悉的同学老师面前，做一些自己擅长的事情。而作为一个职场新人技术小白组内的技术分享对我来说就像是关公面前耍大刀（这个比拟比较夸大哈哈哈~），记得当时分享的是quartz，当时做了很多准备，结合自己的使用经验，以及实践社区大佬的使用经验总结成书面的技术分享文章，后来分享效果还挺不错，起码把自己懂得，理解到的，用过的都分享了出来并做了总结。</p>
<p>  通过那次的分享，逐渐明白完全掌握一个新知识新技术，并不是你会用就可以了，而是你能够将这个知识讲出来，教会别人，并能为其答疑解惑。</p>
<p>  自此，博客成了我记录学习，总结知识的方法和途径。</p>
<h3 id="程序生涯开启"><a href="#程序生涯开启" class="headerlink" title="程序生涯开启"></a>程序生涯开启</h3><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><blockquote>
<p>做正确的事儿，正确的做事儿</p>
</blockquote>
<p>  2019年是生活重心都在工作的一年，这一年也是五味杂陈的一年，这一年暴露出了自身的很多潜藏问题和缺点。</p>
<h3 id="年度关键字-2"><a href="#年度关键字-2" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>升职加薪</li>
<li>整合</li>
<li>规范</li>
<li>责任</li>
<li>管理</li>
<li>优秀员工</li>
</ul>
<p>这一年的项目情况就不多作介绍，主要对自己项目工作以外的一些事件进行总结</p>
<h3 id="五味杂陈"><a href="#五味杂陈" class="headerlink" title="五味杂陈"></a>五味杂陈</h3><p>  说到五味杂陈，离不开情之一字，哈哈哈，这种事其实不应该出现在程序员的年度总结中，但是键盘敲到这里，思绪划过2019一整年，真的是五味杂陈，感情痛点也算是这一年不可缺的的一部分，经历了很多的争吵，产生过很多的矛盾。一个在计划未来，一个却在谋划离开。这一年刚刚开始就已经结束了；愿这些烦恼都随2019一起远去。</p>
<h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>  经过1年的打怪升级，管人理事，优化组织结构和人员配置，技术中开发套路和基本架构都已经熟悉，在对目前项目中在使用的延时任务进行了整合，并以微服务形式提供接口支持。防止出现重复造轮子的现象，提高开发效率。</p>
<h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>   刚入行的时候就有朋友给提点过：做这一行，到了最后拼的都是内功，话俗理不俗！</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>  博客输出已经成为一种习惯，虽然我的更新频率十分不规律，而且技术深度也一般，但是相信自己只要坚持输出，终会有所收获。</p>
<p>  写博客已经不单单是记录和总结了，就像能用嘴巴说出来的东西，不一定能用文字清楚的表达。而写博客更多的是分享和文档撰写、信息归纳汇总的锻炼，就像锻炼一个人的文字表达能力一样。</p>
<h3 id="架构升级"><a href="#架构升级" class="headerlink" title="架构升级"></a>架构升级</h3><p>  哈哈，我已经开始全栈旅行啦~。</p>
<h3 id="暴露出的问题"><a href="#暴露出的问题" class="headerlink" title="暴露出的问题"></a>暴露出的问题</h3><p>  前面都是在总结一些自己的阶段性成果和大事件，但对于过程中暴露出额自身问题却只字未提，这里想把他们单拎出来，警示自己：</p>
<ul>
<li>未能时常关心到家人 —–> 做到一周最少一次联系（特别好奇是不是男生都和家里联系少？还是就我是这样？总之这样是不对的）</li>
<li>完善管理 —–> 为自己制定计划表，和奖惩措施，调整心态，微笑面对生活</li>
<li>读书太少 —–> 提升内涵，多读书，读好书</li>
<li>运动太少 —–> 加强锻炼，控制体重（增重增重……惨不忍睹，体重太少~我要当个男人）</li>
<li>熬夜太多 —–> 早睡早起，狗命重要！！！</li>
<li>技术宅 —–> 重拾兴趣爱好，充实业务生活，生活需要伴侣</li>
<li>多的flag着实不想立了，不想来年打脸，但以上这些已经列出来的问题点，是必须优先解决的。</li>
</ul>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><blockquote>
<p>逆水行舟不进则退，长期处于舒适区只会习惯于停留在原地</p>
</blockquote>
<p>  最后的这一节，就像小时候写新学期打算一样，要求新的一年做出展望和规划，也是必不可少的。</p>
<p>  新的一年也算是一个新的起点，希望自己初心不改，保持现在的节奏稳扎稳打，努力提升自己，变得更优秀。</p>
<div align="center">
2020仍会平凡而伟大<br>  
低头看路，抬头轻唱<br>  
忙碌、踏实、宁静<br>  
不负人、不负事；<br>  
每一天都可以<br>  
安然入睡<br>  
微笑醒来；<br>  
</div>


</body></html>]]></content>
  </entry>
  <entry>
    <title>使用node从零搭建自动化部署管理平台</title>
    <url>/2019/12/02/node-h5-cicd/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="抛弃jenkins，使用node从零搭建自动化部署管理平台"><a href="#抛弃jenkins，使用node从零搭建自动化部署管理平台" class="headerlink" title="抛弃jenkins，使用node从零搭建自动化部署管理平台"></a>抛弃jenkins，使用node从零搭建自动化部署管理平台</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>  H5页面由于其具有发布灵活、跨平台、易于传播等突出特点，所以H5页面是引流拉新、宣传推广的重要渠道和方式，备受各公司的青睐。<br>  在整个开发周期中，结合我司的一些情况，我总结了H5活动页面的以下特点：</p>
<blockquote>
<ul>
<li>面向用户，流量大；</li>
</ul>
</blockquote>
<ul>
<li>各端展示方案不同，需要兼容各端（比如活动规则、展示模块，ios和android不一样）；</li>
<li>需求变更频繁；</li>
<li>合作方较多（需要跟各个业务线合作联调）；</li>
<li>排期紧张；</li>
<li>所以开发测试期间，部署效率就显得特别重要了。</li>
</ul>
<p>  由于我司的CDN发布平台，需要手动创建模板、粘贴代码，部署效率比较低下；并且活动页面代码分散，无法统一管理和实现工程化，所以决定实现一套自动化部署系统，目前已经投入使用半年时间了，极大地提高了我们的工作效率。我称这个自动化部署系统为【H5 活动管理平台】。</p>
<h2 id="2-实现方案"><a href="#2-实现方案" class="headerlink" title="2. 实现方案"></a>2. 实现方案</h2><p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B201.png)
</p>

<p>  该平台实现主要依赖于本地开发工程、gitlab，三者之间通过通信交互，实现的自动化部署。</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B202.png)
</p>

<p>  最终达到的效果就是：当本地开发分支merge到测试分支devTest或者master分支时，该平台会自动拉取最新代码，构建目标文件，然后将目标文件部署到对应的服务器目录，另外提供了上下线、版本回滚、定时上下线等常用功能。</p>
<p>整体架构流程图：</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B203.png)
</p>

<h3 id="1-本地开发工程"><a href="#1-本地开发工程" class="headerlink" title="1. 本地开发工程"></a>1. 本地开发工程</h3><p>  我们的本地开发工程，是使用node + webpack + babel等相关技术搭建的多页面开发工程，不同的活动位于不同的目录。因为要做自动化构建部署处理，跟【H5活动管理平台】交互，所以有以下要点需要注意（可根据自己项目情况，自由调整方案）。</p>
<p>  本地开发工程作为自动化构建部署的源头，需要提供构建命令行用于构建测试文件和线上文件，便于后面shell命令调用。如在package.json中加入如下命令：</p>
<pre><code>"scripts": {
    "local": "cross-env NODE_ENV=local node build.js", // 本地开发命令
    "build": "cross-env NODE_ENV=product node build.js", // 构建上线文件
    "test": "cross-env NODE_ENV=test node build.js" // 构建测试文件
}</code></pre><p>  提供构建配置文件dev-config.js，用于过滤webpack构建时的入口目录，只构建编译当前正在开发的活动页面，提高构建速度。</p>
<pre><code>//dev-config.js
module.exports = {
    devPages: ['test']   //  当前自己正在开发页面目录，不写时会编译所有活动页面
}</code></pre><p>  提供活动页面目录信息配置config.json，该配置信息用于【H5活动管理平台】的展示，也就是效果图中的信息源。</p>
<pre><code>// config.json
{
  "pages": [
        {
            "folder": "lion",
            "desc": "前端名狮",
            "author": "诀九",
            "user": "juejiu"
        },
        {
            "folder": "test",
            "desc": "活动测试页面",
            "author": "诀九",
            "user": "juejiu"
        }
    ]
}</code></pre><p>  构建生成的 JS 和 HTML 文件，存放在 dist 目录下的对应活动目录中。构建生成的目录结构如下：</p>
<pre><code>|--dist
   |-- lion
       |-- lion_app.js
       |-- index.html
   |--test
       |-- test_app.js
       |-- index.html</code></pre><p>  提测时，将开发分支merge到devTest分支，上线时，将开发分支merge到master分支。<br>工程目录结构</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B204.png)
</p>

<h3 id="2-gitlab服务器"><a href="#2-gitlab服务器" class="headerlink" title="2. gitlab服务器"></a>2. gitlab服务器</h3><p>  Gitlab作为企业代码版本管理工具，提供了Webhook的功能配置，Webhook顾名思义，其实就是一钩子。当我们在Gitlab上做出某些特定操作时，可以触发钩子，去进行一些我们事先设定好的脚本，以达到某些特定功能（例如–前端项目自动发布）。</p>
<p>  实际上可以把它理解为回调，或者委托，或者事件通知，归根揭底它就是一个消息通知机制。当gitlab触发某个事件时，它会向你的所配置的http服务发送Post请求。</p>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>URL处填写的是【H5活动管理平台】部署的服务器IP;</li>
<li>IP后面跟的merge是该平台提供的一个接口，用于触发钩子后，gitlab服务器向这个接口发送Post请求；</li>
<li>Secret Token处填写的是一个token，主要用于merge接口请求做安全校验，可以随便设置。<br>具体配置如下图：</li>
</ul>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B205.png)
</p>

<p>  我们项目是设置的merge钩子，下面只贴一下Merge request events请求传递的数据信息：</p>
<pre><code>Request header:

X-Gitlab-Event: Merge Request Hook
Request body:

{
  "object_kind": "merge_request",
  "user": {
    "name": "Administrator",
    "username": "root",
    "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon"
  },
  "object_attributes": {
    "id": 99,
    "target_branch": "master",
    "source_branch": "ms-viewport",
    "source_project_id": 14,
    "author_id": 51,
    "assignee_id": 6,
    "title": "MS-Viewport",
    "created_at": "2013-12-03T17:23:34Z",
    "updated_at": "2013-12-03T17:23:34Z",
    "st_commits": null,
    "st_diffs": null,
    "milestone_id": null,
    "state": "opened",
    "merge_status": "unchecked",
    "target_project_id": 14,
    "iid": 1,
    "description": "",
    "source":{
      "name":"Awesome Project",
      "description":"Aut reprehenderit ut est.",
      "web_url":"http://example.com/awesome_space/awesome_project",
      "avatar_url":null,
      "git_ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "git_http_url":"http://example.com/awesome_space/awesome_project.git",
      "namespace":"Awesome Space",
      "visibility_level":20,
      "path_with_namespace":"awesome_space/awesome_project",
      "default_branch":"master",
      "homepage":"http://example.com/awesome_space/awesome_project",
      "url":"http://example.com/awesome_space/awesome_project.git",
      "ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "http_url":"http://example.com/awesome_space/awesome_project.git"
    },
    "target": {
      "name":"Awesome Project",
      "description":"Aut reprehenderit ut est.",
      "web_url":"http://example.com/awesome_space/awesome_project",
      "avatar_url":null,
      "git_ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "git_http_url":"http://example.com/awesome_space/awesome_project.git",
      "namespace":"Awesome Space",
      "visibility_level":20,
      "path_with_namespace":"awesome_space/awesome_project",
      "default_branch":"master",
      "homepage":"http://example.com/awesome_space/awesome_project",
      "url":"http://example.com/awesome_space/awesome_project.git",
      "ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "http_url":"http://example.com/awesome_space/awesome_project.git"
    },
    "last_commit": {
      "id": "da1560886d4f094c3e6c9ef40349f7d38b5d27d7",
      "message": "fixed readme",
      "timestamp": "2012-01-03T23:36:29+02:00",
      "url": "http://example.com/awesome_space/awesome_project/commits/da1560886d4f094c3e6c9ef40349f7d38b5d27d7",
      "author": {
        "name": "GitLab dev user",
        "email": "gitlabdev@dv6700.(none)"
      }
    },
    "work_in_progress": false,
    "url": "http://example.com/diaspora/merge_requests/1",
    "action": "open",
    "assignee": {
      "name": "User1",
      "username": "user1",
      "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon"
    }
  }
}</code></pre><h2 id="3-H5-活动管理平台"><a href="#3-H5-活动管理平台" class="headerlink" title="3. H5 活动管理平台"></a>3. H5 活动管理平台</h2><p>  当开发者merge代码到GitLab服务器，会触发merge事件，GitLab会发送一个POST请求连带数据（数据格式）给webhooks指定的URL，该平台接收到URL请求后，就涉及如下关键技术点：</p>
<h3 id="1-根据post请求头信息和和body数据，我们能得到如下信息："><a href="#1-根据post请求头信息和和body数据，我们能得到如下信息：" class="headerlink" title="1. 根据post请求头信息和和body数据，我们能得到如下信息："></a>1. 根据post请求头信息和和body数据，我们能得到如下信息：</h3><blockquote>
<ul>
<li>merge的目标分支：req.body.object_attributes.target_branch；</li>
</ul>
</blockquote>
<ul>
<li>安全校验token：req.headers[‘x-gitlab-token’]；</li>
<li>gitlab工程仓库地址：req.body.project.git_ssh_url</li>
<li>触发的钩子行为类型：req.body.object_attributes.action</li>
</ul>
<pre><code>// gitlab触发merge请求
router.post('/merge', function (req, res, next) {
    let git_ssh_url = req.body.project.git_ssh_url;
    let name = req.body.project.name;
    // 上线merge分支master
    if (req.headers['x-gitlab-token'] == 'mergeRequest' && req.body.object_attributes.target_branch == 'master' && req.body.object_attributes.action == 'merge') {
        if (config[name] && config[name].git_ssh_url == git_ssh_url) {
            mergeTaskQueue.addTask(function () {
                getCode.init(git_ssh_url, name, 'master').then(function (data) {
                    console.log(data);
                    mergeTaskQueue.run();
                }).catch(function (error) {
                    console.log(error);
                    mergeTaskQueue.run();
                })
            }.bind(null, git_ssh_url, name));
        }
        res.end('receive request');
        // 测试merge分支dev
    } else if (req.headers['x-gitlab-token'] == 'mergeRequest' && req.body.object_attributes.target_branch == config[name].testEnv.targetBranch && req.body.object_attributes.action == 'merge') {
        if (config[name] && config[name].git_ssh_url == git_ssh_url) {
            mergeTaskQueue.addTask(function () {
                getCode.init(git_ssh_url, name, req.body.object_attributes.target_branch).then(function (data) {
                    console.log(data);
                    mergeTaskQueue.run();
                }).catch(function (error) {
                    console.log(error);
                    mergeTaskQueue.run();
                })
            }.bind(null, git_ssh_url, name));
        }
        res.end('receive request');
    } else {
        return res.end('receive request');
    }
})</code></pre><h3 id="2-执行脚本"><a href="#2-执行脚本" class="headerlink" title="2. 执行脚本"></a>2. 执行脚本</h3><p>  脚本这块没有使用shell脚本，而是使用了node版本的shell.js库，这个库可以让我们控制执行逻辑，更友好的处理错误信息，帮助平台有更友好的信息展示。</p>
<p>拉取最新代码进行构建出目标文件，大致逻辑如下图：</p>
<p align="center">

</p><p><a href="http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B206.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B206.png" class="lazyload"></a></p>
<p></p>

<p>目标代码</p>
<pre><code>function init(git_ssh_url, projectName, targetBranch) {
    deferred = Q.defer();
    if (!git_ssh_url || !projectName) {
        return deferred.reject('项目地址或者项目名称为空');
    }
    repository = git_ssh_url;
    repositoryName = projectName;
    clonePath = path.join(__dirname, '../projects/' + projectName);

    shell.exec('exit 0');
    if (shell.test('-e', clonePath)) {
        shell.cd(clonePath);
        let currentBranch = shell.exec('git symbolic-ref --short -q HEAD', {async: false, silent: true}).stdout;
        if(currentBranch != targetBranch) {
            let outInfo = shell.exec('git branch', {async: false, silent: true}).stdout;
            let gitcmd = outInfo.indexOf(targetBranch) >= 0 ? ('git checkout ' + targetBranch) : ('git checkout -b ' + targetBranch + ' origin/' + targetBranch);
            shell.exec('git pull && ' + gitcmd, {async: false, silent: true});
        }
        shell.exec('git pull', {async: false, silent: true}, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('git pull error');
            }
            console.log(stdout);
            console.log('git pull run success');
            return buildTest(projectName, targetBranch);
        })
    } else {
        if (!fs.existsSync(projects_path)) {
            fs.mkdirSync(projects_path);
        }
        shell.cd(projects_path);
        shell.exec('git clone ' + repository, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('git clone error');
            }
            console.log('git clone success');
            shell.cd(clonePath);
            let outInfo = shell.exec('git branch', {async: false, silent: true}).stdout;
            let gitcmd = outInfo.indexOf(targetBranch) >= 0 ? ('git checkout ' + targetBranch) : ('git checkout -b ' + targetBranch + ' origin/' + targetBranch);
            shell.exec(gitcmd, {async: false, silent: true});
            return buildTest(projectName, targetBranch);
        })
    }
    return deferred.promise;
}</code></pre><pre><code>
// 构建项目
function buildTest(projectName, targetBranch) {
    shell.cd(clonePath);
    shell.exec('npm config set registry https://registry.npm.taobao.org && npm install', {async: true, silent: true}, function (code, stdout, stderr) {
        if (code != 0) {
            console.log(stderr);
            return deferred.reject('npm install error');
        }
        console.log('npm install success');
        shell.rm('-rf', path.join(clonePath, 'dist'));
        let testCommand = config[repositoryName].commands.test || 'npm run test'; //构建测试文件命令行
        shell.exec(testCommand, {async: true, silent: true}, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('npm run test fail');
            }
            console.log('npm run test success');
            copyPage(repositoryName, 'test'); // copy到测试目录
            if(targetBranch != 'master') {
                shell.exec('exit 0');
                deferred.resolve('build success and finish');
                return; // 提测时只构建测试文件
            }
            // 构建最终上线文件
            shell.rm('-rf', path.join(clonePath, 'dist'));
            let buildCommand = config[repositoryName].commands.build || 'npm run build'; //构建预上线文件命令行
            shell.exec(buildCommand, {async: true, silent: true}, function (code, stdout, stderr) {
                if (code != 0) {
                    console.log(stderr);
                    return deferred.reject('npm run build fail');
                }
                console.log('npm run build success');
                copyPage(repositoryName, 'online'); //copy到上线正式目录

                // 每次合并master构建后，都切换到测试分支，便于平台读取config.json信息（测试分支是最新的）
                shell.exec('git checkout ' + config[projectName].testEnv.targetBranch, {async: false, silent: false}); 
                shell.exec('exit 0');
                deferred.resolve('build success and finish');
            })
        })
    })
}</code></pre><h3 id="3-动态扩展项目"><a href="#3-动态扩展项目" class="headerlink" title="3. 动态扩展项目"></a>3. 动态扩展项目</h3><p>  通过修改项目配置文件，接入不同的项目，配置信息有每个项目要上传的CDN路径、构建命令、项目目录展示信息文件路径（config.json），如下图：</p>
<pre><code>// 接入该平台的项目列表
module.exports = {
    'h5-activity-cms': {
        git_ssh_url: 'git@example.com:awesome_space/awesome_project.git',
        desc: '前端名狮项目',
        tabContent: '前端名狮', //页面中tab展示文字
        onlineParam: { //上传cdn的参数，根据自己项目设置
            html: {
                domain: '',
                path: ''
            },
            js: {
                domain: '',
                path: ''
            }
        },
        commands: { //构建脚本命令行
            test: 'npm run test',
            build: 'npm run build'
        },

        configFile: 'config.json', // 活动页面列表信息
    }
}</code></pre><h3 id="4-队列处理"><a href="#4-队列处理" class="headerlink" title="4. 队列处理"></a>4. 队列处理</h3><p>  构建目标文件的过程中，很多生成文件、压缩、copy的异步操作，不同的merge请求，有可能操作的是同一个文件，所以需要对merge请求做队列处理。</p>
<pre><code>class TaskQueue {
    constructor() {
        this.list = [];
        this.isRunning = false;
    }
    addTask(task) {
        this.list.push(task);
        if(this.isRunning) {
            return;
        }
        this.start();
    }
    shift() {
        return this.list.length > 0 ? this.list.shift() : null;
    }
    run() {
        let task = this.shift();
        if(!task) {
            this.isRunning = false;
            return;
        }
        task();
    }
    start() {
        this.isRunning = true;
        this.run();
    }
}
module.exports = TaskQueue;</code></pre><h3 id="5-CDN-发布"><a href="#5-CDN-发布" class="headerlink" title="5. CDN 发布"></a>5. CDN 发布</h3><p>  这个需要后端同学提供一个服务接口，用于推送文件到CDN上或者服务器上。我们这边是借助于一个服务端接口，我们通过node上传到他们的服务器，接口方会定时推送文件到CDN，具体每个人的情况处理吧哈。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><blockquote>
<ul>
<li>该平台使用node实现了一个微型的、类似jenkins功能的部署管理平台，具有如下突出的优点：</li>
</ul>
</blockquote>
<ul>
<li>该平台打通了本地开发环境和测试环境部署，实现了测试部署自动化，节省了人工上传粘贴代码的时间，大大地提高了工作效率；</li>
<li>基于项目工程划分的类别，便于开发者高效率的查找页面；</li>
<li>支持动态扩展，可以通过添加配置文件，接入其他gitlab项目；</li>
<li>可以根据需要定制化平台操作页面，比使用jenkins更灵活，更轻便；</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>生活</title>
    <url>/2018/06/23/todayFeel/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). -->

</head><body><h2 id="那天"><a href="#那天" class="headerlink" title="那天"></a>那天</h2><p>  天黑了，没人可以等你回家，你告诉自己离家很近。</p>
<p>​   蹒跚在路上，路灯微暗，周围行人匆忙，路边小贩一旁大声吆喝着，你想过去买些水果，顺带和大叔唠嗑两句，不知自己是想聊天还是想买水果，想着想着，而你已经走过了那小水果摊位，算了，你也没有吃水果的习惯。</p>
<h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>​   今天天气还不错，没有雨，不算热，你居然有点开心起来，假装着将一切抛掷脑后，哼着背不熟的歌曲，回想着明星的模样，他和歌词的描述那样，上进，阳光，积极。一切都是你想要的样子。</p>
<p>​   园区里，一只小黄猫只蹲在垃圾桶上，一直往里看，好像掉了什么东西。它身躯瘦小，好像是饿了很久了。你路过它身旁，目光一直在它身上，但它似乎对你没有多大兴趣。在它眼里，你并不如垃圾桶的东西呢。</p>
<p><a href="https://goss.cfp.cn/creative/vcg/nowarter800/new/VCG211130066346.jpg?x-oss-process=image/format,webp" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="https://goss.cfp.cn/creative/vcg/nowarter800/new/VCG211130066346.jpg?x-oss-process=image/format,webp" class="lazyload"></a></p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>记事儿不记人</tag>
      </tags>
  </entry>
</search>
