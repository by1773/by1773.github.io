<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>愚人节？我们是认真的</title>
    <url>/2020/04/01/2020foolsday/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>  生活会有岁月静好，我也愿意为你负重前行；那一刻，这一刻，以后的每个时刻，是因为我而你感到幸福快乐。行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，爱过一个正当最好年龄的人。要和你闻闻新鲜的春天，感受阳关洒满肩头的夏天，整个世界涂满金色的秋天，充满童话飘雪纯白的冬天。“愚”你同在，陪你同行，我们是认真的～</p>
<!-- ![markdown](http://q7hgnfyvz.bkt.clouddn.com/avater.png) -->
<a href="./avater.png" data-fancybox="group" data-caption="undefined" class="fancybox"><img align="center" width="60%" data-src="./avater.png" class="lazyload"></a></body></html>]]></content>
  </entry>
  <entry>
    <title>瞎说“进程，线程，异步协程”</title>
    <url>/2020/03/23/Back-End-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="进程，线程，异步协程"><a href="#进程，线程，异步协程" class="headerlink" title="进程，线程，异步协程"></a>进程，线程，异步协程</h1><p>本文记录一下自己对线程，进程，协程的理解。</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><pre><code>狭义的进程可以代表一个应用程序的执行过程，比如我们打开任务管理器，可以看到很多程序在运行，这些都可以都可以说是一个个进程。

广义的进程指的是具有一定独立功能的程序，关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单位。</code></pre><blockquote>
<p>进程的概念主要有两点</p>
</blockquote>
<ul>
<li>进程是一个实体，每一个进程都有其自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程中调用的指令和本地变量。</li>
<li>进程是”执行中的程序”，一个程序不运行就是个空壳，只有经过运行，让处理器赋予其地址，给其生命，它才是一个实体，也就是一个进程。</li>
</ul>
<blockquote>
<p>进程的状态</p>
</blockquote>
<ul>
<li>就绪，指其获取了除CPU之外的所有资源，只要CPU分配资源就可以运行。</li>
<li>运行，也就是就绪之后获得了CPU分配的资源，可以执行操作</li>
<li>阻塞，当条件不足（比如说缺少某些插件，资源之类）此时称为阻塞态。</li>
</ul>
<blockquote>
<p>进程的特征</p>
</blockquote>
<ul>
<li>动态性，进程是程序的一次执行，有其生命期，不是永生的<br>并发行，任何进程都可以和其他进程一起执行（一个健壮的程序不止一个进程，只能同时运行一个程序的电脑和板砖有什么区别）</li>
<li>独立性，进程是系统进行资源分配和调度的一个独立单位</li>
<li>进程由程序、数据和进程控制块三部分组成。</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。</p>
</blockquote>
<ul>
<li>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。<br>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了，于是就发明了线程。</li>
</ul>
<blockquote>
<p>线程特征：</p>
</blockquote>
<ul>
<li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），一个线程可以创建和撤销另一个线程；<br>通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源。在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度。</li>
</ul>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li>通常程序至少一个进程，一个进程最少一个线程，进程是分配资源的最小单位，线程是CPU调度的最小单位。</li>
<li>资源（内存、寄存器等）分配给进程，进程在执行过程拥有独立的内存空间，而同一进程下的所有线程共享所有资源，从而提高程序的运行效率；</li>
<li>处理机分配给线程，即处理机真正运行的是线程；</li>
<li>线程在执行过程中，需要协作同步。不同线程间的要利用通信协议来实现同步。</li>
</ul>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><blockquote>
<p>协程，使用一个线程去完成多个任务，可以理解成微线程。</p>
</blockquote>
<p>  协程的调度完全由用户控制，相对独立，有自己的上下文。一个线程可以有多个协程，用户创建了几个线程，然后每个线程都是循环按照指定的任务清单顺序完成不同的任务，当任务被阻塞的时候执行下一个任务，当恢复的时候再回来执行这个任务，任务之间的切换只需要保存每个任务的上下文内容，就像直接操作栈一样的，这样就完全没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快；另外协程还需要保证是非阻塞的且没有相互依赖，协程基本上不能同步通讯，多采用异步的消息通讯，效率比较高。</p>
<blockquote>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程</p>
</blockquote>
<p>注：协程不是真正的多线程。</p>
<h2 id="多进程？多线程？"><a href="#多进程？多线程？" class="headerlink" title="多进程？多线程？"></a>多进程？多线程？</h2><p>  前文说到，进程是操作系统进行资源分配的最小单位，那么在同一时间，同一设备，运行至少两个的进程，这就是多任务操作系统（不然怎么满足大众需求）<br>  那么这里就出现问题了，我们人不能一心二用，而一直模仿人类的计算机显然也不可以，原则上一个CPU只能分配资源给一个进程，但我们常用的电脑都是单CPU,怎么实现多进程的呢，这就是“并发”。具体理论很复杂，可以理解为轮流使用CPU,每个进程只占用几毫秒，以人类的反应速度是无法感觉出来，实现一种很多进程同时运行的假象，但同一时间只有一个进程获得了CPU的使用权，多核CPU可以实现同时运行多个进程即——并行。但显然我们电脑的CPU数目远远小于我们运行的任务数，那么——并发还需仔细研究。</p>
<p>  在计算机编程中，一个基本的概念就是同时对多个任务加以控制。许多程序设计问题都要求程序能够停下手头的工作，改为处理其他一些问题，再返回主进程。最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。<br>  但由于共享资源，如果多个线程同时运行，而且访问同一个资源，那么就会报错。所以就有了所谓的“锁”，线程运行时将资源锁定，执行结束再释放，使其他线程来使用这部分资源，所以多线程的程序可以充分的利用CPU的资源，大大减少响应的时间，使得运行效率大大提高，而且由于使用统一的内存，减少了数据的传送困难，方便不同任务的协调操作和运行，数据交互问题会更容易解决。</p>
<p>  多进程和多线程，是实现多任务最常用的两种方式。现在，我们来讨论一下这两种方式的优缺点。</p>
<ul>
<li><p>要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。      </p>
</li>
<li><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</p>
</li>
<li><p>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p>
</li>
<li><p>多进程 优点 是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程。（当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）著名的Apache最早就是采用多进程模式。</p>
</li>
<li><p>多进程 缺点 是创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。还有一个不足之处，多进程下程序与各进程之间的通信和数据共享不方便；</p>
</li>
<li><p>多线程 优点 通常比多进程快一点，但是也快不到哪去，开销小！</p>
</li>
<li><p>多线程主要是为了节约CPU时间，为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率！</p>
</li>
<li><p>多线程 缺点 任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>
</li>
</ul>
<p>  多任务操作系统(如Windows)的基本原理是：操作系统将CPU的时间片分配给多个线程，每个线程在操作系统指定的时间片内完成(注意,这里的多个线程是分属于不同进程的)。操作系统不断的从一个线程的执行切换到另一个线程的执行，如此往复，宏观上看来,就好像是多个线程在一起执行。由于这多个线程分属于不同的进程,因此在我们看来,就好像是多个进程在同时执行,这样就实现了多任务。</p>
<p>  那么多任务并发，可以充分发挥CPU资源，那么是不是并发量越大越好。当然不是，因为切换任务需要一定的消耗，少的时候看不出来，当达到某个临界值，那么卡顿就伴随而来。</p>
<ul>
<li>操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</li>
</ul>
<h2 id="I-O-以及同步异步"><a href="#I-O-以及同步异步" class="headerlink" title="I/O 以及同步异步"></a>I/O 以及同步异步</h2><blockquote>
<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。但由于硬件等的差距，两者的运行效率是不一样的，甚至差距很大，这时有两种方式。</p>
</blockquote>
<ul>
<li>同步，即CPU等待程序完成任务，再继续其他操作</li>
<li>异步，即把当前任务挂载，CPU去执行其他任务</li>
</ul>
<p>   显然异步很优秀，但异步编程模型相对复杂，异步IO复杂度远远高于同步</p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><blockquote>
<p>同步：就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。<br>    按照这个定义，其实绝大多数函数都是同步调用（例如sin isdigit等）。<br>    但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。<br>    最常见的例子就是 SendMessage。该函数发送一个消息给某个窗口，在对处理完消息之前，这个函数不返回。<br>    当对方处理完毕以后，该函数才把消息处理函数所返回的值返回给调用者。</p>
</blockquote>
<h3 id="异步的概念和同步相对"><a href="#异步的概念和同步相对" class="headerlink" title="异步的概念和同步相对"></a>异步的概念和同步相对</h3><blockquote>
<p> 当一个异步过程调用发出后，调用者不会立刻得到结果。<br>    实际处理这个调用的部件是在调用发出后，<br>    通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
</blockquote>
<pre><code>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。

现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。

对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</code></pre><h2 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h2><p>  这是程序等待消息时的状态，不妨想一下同步异步是什么。<br>  阻塞调用是指结果返回之前，进程会被挂起，函数得到结果后才能返回（注，阻塞不等同于同步）<br>  非阻塞就是未得到结果之前，该函数不会阻塞当前进程，而立即返回<br>其实他们还可以结合</p>
<ul>
<li>同步阻塞</li>
</ul>
<p>效率最低，拿排队来说，就是你专心排队，什么事都不能做。（同步-排队这个进程，阻塞-未排到自己事件不返回）</p>
<ul>
<li>异步阻塞</li>
</ul>
<p>即排队领号之后的人，它不能离开太远也就是被阻塞在这个任务，因为你要等待被叫号（即等待消息解除阻塞状态）</p>
<ul>
<li>同步非阻塞</li>
</ul>
<p>效率也不高，还是排队，这次你可以做别的事了，比如玩个手机，但你要是不是注意是否排到了自己，两种行为切换很多次。</p>
<ul>
<li>异步非阻塞</li>
</ul>
<p>效率最高，你可以任意做其他事（异步），然后坐等柜台通知你去办理业务（非阻塞，未被阻塞在等待的操作上）。</p>
</body></html>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker环境下的前后端分离部署与运维</title>
    <url>/2020/03/20/Docker-Introduction/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Docker环境下的前后端分离部署与运维"><a href="#Docker环境下的前后端分离部署与运维" class="headerlink" title="Docker环境下的前后端分离部署与运维"></a>Docker环境下的前后端分离部署与运维</h1><h2 id="Docker-虚拟机常用命令"><a href="#Docker-虚拟机常用命令" class="headerlink" title="Docker 虚拟机常用命令"></a>Docker 虚拟机常用命令</h2><ol>
<li><p>先更新软件包</p>
<pre><code class="shell">yum -y update</code></pre>
</li>
<li><p>安装 Docker 虚拟机</p>
<pre><code class="shell">yum install -y docker</code></pre>
</li>
<li><p>运行、重启、关闭 Docker 虚拟机</p>
<pre><code class="shell">service docker start
service docker start
service docker stop</code></pre>
</li>
<li><p>搜索镜像</p>
<pre><code class="shell">docker search 镜像名称</code></pre>
</li>
<li><p>下载镜像</p>
<pre><code class="shell">docker pull 镜像名称</code></pre>
</li>
<li><p>查看镜像</p>
<pre><code class="shell">docker images</code></pre>
</li>
<li><p>删除镜像</p>
<pre><code class="shell">docker rmi 镜像名称</code></pre>
</li>
<li><p>运行容器</p>
<pre><code class="shell">docker run 启动参数  镜像名称</code></pre>
</li>
<li><p>查看容器列表</p>
<pre><code class="shell">docker ps -a</code></pre>
</li>
<li><p>停止、挂起、恢复容器</p>
<pre><code class="shell">docker stop 容器ID
docker pause 容器ID
docker unpase 容器ID</code></pre>
</li>
<li><p>查看容器信息</p>
<pre><code class="shell">docker inspect 容器ID</code></pre>
</li>
<li><p>删除容器</p>
<pre><code class="shell">docker rm 容器ID</code></pre>
</li>
<li><p>数据卷管理</p>
<pre><code class="shell">docker volume create 数据卷名称  #创建数据卷
docker volume rm 数据卷名称  #删除数据卷
docker volume inspect 数据卷名称  #查看数据卷</code></pre>
</li>
<li><p>网络管理</p>
<pre><code class="shell">docker network ls 查看网络信息
docker network create --subnet=网段 网络名称
docker network rm 网络名称</code></pre>
</li>
<li><p>避免 VM 虚拟机挂起恢复之后，Docker 虚拟机断网</p>
<pre><code class="shell">vi /etc/sysctl.conf</code></pre>
<p>文件中添加<code>net.ipv4.ip_forward=1</code>这个配置</p>
<pre><code> #重启网络服务
 systemctl  restart network</code></pre></li>
</ol>
<h2 id="安装-PXC-集群，负载均衡，双机热备"><a href="#安装-PXC-集群，负载均衡，双机热备" class="headerlink" title="安装 PXC 集群，负载均衡，双机热备"></a>安装 PXC 集群，负载均衡，双机热备</h2><ol>
<li><p>安装 PXC 镜像</p>
<pre><code class="shell">docker pull percona/percona-xtradb-cluster</code></pre>
</li>
<li><p>为 PXC 镜像改名</p>
<pre><code class="shell">docker tag percona/percona-xtradb-cluster pxc</code></pre>
</li>
<li><p>创建 net1 网段</p>
<pre><code class="shell">docker network create --subnet=172.18.0.0/16 net1</code></pre>
</li>
<li><p>创建 5 个数据卷</p>
<pre><code class="shell">docker volume create --name v1
docker volume create --name v2
docker volume create --name v3
docker volume create --name v4
docker volume create --name v5</code></pre>
</li>
<li><p>创建备份数据卷（用于热备份数据）</p>
<pre><code class="shell">docker volume create --name backup</code></pre>
</li>
<li><p>创建 5 节点的 PXC 集群</p>
<p>注意，每个 MySQL 容器创建之后，因为要执行 PXC 的初始化和加入集群等工作，耐心等待 1 分钟左右再用客户端连接 MySQL。另外，必须第 1 个 MySQL 节点启动成功，用 MySQL 客户端能连接上之后，再去创建其他 MySQL 节点。</p>
<pre><code class="shell">#创建第1个MySQL节点
docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -v v1:/var/lib/mysql -v backup:/data --privileged --name=node1 --net=net1 --ip 172.18.0.2 pxc
#创建第2个MySQL节点
docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v2:/var/lib/mysql -v backup:/data --privileged --name=node2 --net=net1 --ip 172.18.0.3 pxc
#创建第3个MySQL节点
docker run -d -p 3308:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v3:/var/lib/mysql --privileged --name=node3 --net=net1 --ip 172.18.0.4 pxc
#创建第4个MySQL节点
docker run -d -p 3309:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v4:/var/lib/mysql --privileged --name=node4 --net=net1 --ip 172.18.0.5 pxc
#创建第5个MySQL节点
docker run -d -p 3310:3306 -e MYSQL_ROOT_PASSWORD=abc123456 -e CLUSTER_NAME=PXC -e XTRABACKUP_PASSWORD=abc123456 -e CLUSTER_JOIN=node1 -v v5:/var/lib/mysql -v backup:/data --privileged --name=node5 --net=net1 --ip 172.18.0.6 pxc</code></pre>
</li>
<li><p>安装 Haproxy 镜像</p>
<pre><code class="shell">docker pull haproxy</code></pre>
</li>
<li><p>宿主机上编写 Haproxy 配置文件</p>
<pre><code class="shell">vi /home/soft/haproxy.cfg</code></pre>
<p>配置文件如下：</p>
<pre><code class="properties">global
    #工作目录
    chroot /usr/local/etc/haproxy
    #日志文件，使用rsyslog服务中local5日志设备（/var/log/local5），等级info
    log 127.0.0.1 local5 info
    #守护进程运行
    daemon

defaults
    log    global
    mode    http
    #日志格式
    option    httplog
    #日志中不记录负载均衡的心跳检测记录
    option    dontlognull
    #连接超时（毫秒）
    timeout connect 5000
    #客户端超时（毫秒）
    timeout client  50000
    #服务器超时（毫秒）
    timeout server  50000

#监控界面
listen  admin_stats
    #监控界面的访问的IP和端口
    bind  0.0.0.0:8888
    #访问协议
    mode        http
    #URI相对地址
    stats uri   /dbs
    #统计报告格式
    stats realm     Global\ statistics
    #登陆帐户信息
    stats auth  admin:abc123456
#数据库负载均衡
listen  proxy-mysql
    #访问的IP和端口
    bind  0.0.0.0:3306
    #网络协议
    mode  tcp
    #负载均衡算法（轮询算法）
    #轮询算法：roundrobin
    #权重算法：static-rr
    #最少连接算法：leastconn
    #请求源IP算法：source
    balance  roundrobin
    #日志格式
    option  tcplog
    #在MySQL中创建一个没有权限的haproxy用户，密码为空。Haproxy使用这个账户对MySQL数据库心跳检测
    option  mysql-check user haproxy
    server  MySQL_1 172.18.0.2:3306 check weight 1 maxconn 2000
    server  MySQL_2 172.18.0.3:3306 check weight 1 maxconn 2000
    server  MySQL_3 172.18.0.4:3306 check weight 1 maxconn 2000
    server  MySQL_4 172.18.0.5:3306 check weight 1 maxconn 2000
    server  MySQL_5 172.18.0.6:3306 check weight 1 maxconn 2000
    #使用keepalive检测死链
    option  tcpka</code></pre>
</li>
<li><p>创建两个 Haproxy 容器</p>
<pre><code class="shell">#创建第1个Haproxy负载均衡服务器
docker run -it -d -p 4001:8888 -p 4002:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h1 --privileged --net=net1 --ip 172.18.0.7 haproxy
#进入h1容器，启动Haproxy
docker exec -it h1 bash
haproxy -f /usr/local/etc/haproxy/haproxy.cfg
#创建第2个Haproxy负载均衡服务器
docker run -it -d -p 4003:8888 -p 4004:3306 -v /home/soft/haproxy:/usr/local/etc/haproxy --name h2 --privileged --net=net1 --ip 172.18.0.8 haproxy
#进入h2容器，启动Haproxy
docker exec -it h2 bash
haproxy -f /usr/local/etc/haproxy/haproxy.cfg</code></pre>
</li>
<li><p>Haproxy 容器内安装 Keepalived，设置虚拟 IP</p>
<pre><code class="shell">#进入h1容器
docker exec -it h1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件（参考下方配置文件）
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start
#宿主机执行ping命令
ping 172.18.0.201</code></pre>
<p>配置文件内容如下：</p>
<pre><code>vrrp_instance  VI_1 {
    state  MASTER
    interface  eth0
    virtual_router_id  51
    priority  100
    advert_int  1
    authentication {
        auth_type  PASS
        auth_pass  123456
    }
    virtual_ipaddress {
        172.18.0.201
    }
}</code></pre><pre><code class="shell">#进入h2容器
docker exec -it h2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start
#宿主机执行ping命令
ping 172.18.0.201</code></pre>
<p>配置文件内容如下：</p>
<pre><code class="shell">vrrp_instance  VI_1 {
    state  MASTER
    interface  eth0
    virtual_router_id  51
    priority  100
    advert_int  1
    authentication {
        auth_type  PASS
        auth_pass  123456
    }
    virtual_ipaddress {
        172.18.0.201
    }
}</code></pre>
</li>
<li><p>宿主机安装 Keepalived，实现双击热备</p>
<pre><code class="shell">#宿主机执行安装Keepalived
yum -y install keepalived
#修改Keepalived配置文件
vi /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<p>Keepalived 配置文件如下：</p>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    virtual_ipaddress {
           192.168.99.150
    }
}

virtual_server 192.168.99.150 8888 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 172.18.0.201 8888 {
        weight 1
    }
}

virtual_server 192.168.99.150 3306 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP

    real_server 172.18.0.201 3306 {
        weight 1
    }
}</code></pre>
</li>
<li><p>热备份数据</p>
<pre><code class="shell">#进入node1容器
docker exec -it node1 bash
#更新软件包
apt-get update
#安装热备工具
apt-get install percona-xtrabackup-24
#全量热备
innobackupex --user=root --password=abc123456 /data/backup/full</code></pre>
</li>
<li><p>冷还原数据<br>停止其余 4 个节点，并删除节点</p>
<pre><code class="shell">docker stop node2
docker stop node3
docker stop node4
docker stop node5
docker rm node2
docker rm node3
docker rm node4
docker rm node5</code></pre>
<p>node1 容器中删除 MySQL 的数据</p>
<pre><code class="shell">#删除数据
rm -rf /var/lib/mysql/*
#清空事务
innobackupex --user=root --password=abc123456 --apply-back /data/backup/full/2018-04-15_05-09-07/
#还原数据
innobackupex --user=root --password=abc123456 --copy-back  /data/backup/full/2018-04-15_05-09-07/</code></pre>
<p>重新创建其余 4 个节点，组件 PXC 集群</p>
</li>
</ol>
<h2 id="安装-Redis，配置-RedisCluster-集群"><a href="#安装-Redis，配置-RedisCluster-集群" class="headerlink" title="安装 Redis，配置 RedisCluster 集群"></a>安装 Redis，配置 RedisCluster 集群</h2><ol>
<li><p>安装 Redis 镜像</p>
<pre><code class="shell">docker pull yyyyttttwwww/redis</code></pre>
</li>
<li><p>创建 net2 网段</p>
<pre><code class="shell">docker network create --subnet=172.19.0.0/16 net2</code></pre>
</li>
<li><p>创建 6 节点 Redis 容器</p>
<pre><code class="shell">docker run -it -d --name r1 -p 5001:6379 --net=net2 --ip 172.19.0.2 redis bash
docker run -it -d --name r2 -p 5002:6379 --net=net2 --ip 172.19.0.3 redis bash
docker run -it -d --name r3 -p 5003:6379 --net=net2 --ip 172.19.0.4 redis bash
docker run -it -d --name r4 -p 5004:6379 --net=net2 --ip 172.19.0.5 redis bash
docker run -it -d --name r5 -p 5005:6379 --net=net2 --ip 172.19.0.6 redis bash</code></pre>
</li>
<li><p>启动 6 节点 Redis 服务器</p>
<pre><code class="shell">#进入r1节点
docker exec -it r1 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r2节点
docker exec -it r2 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r3节点
docker exec -it r3 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r4节点
docker exec -it r4 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r5节点
docker exec -it r5 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf
#进入r6节点
docker exec -it r6 bash
cp /home/redis/redis.conf /usr/redis/redis.conf
cd /usr/redis/src
./redis-server ../redis.conf</code></pre>
</li>
<li><p>创建 Cluster 集群</p>
<pre><code class="shell">#在r1节点上执行下面的指令
cd /usr/redis/src
mkdir -p ../cluster
cp redis-trib.rb ../cluster/
cd ../cluster
#创建Cluster集群
./redis-trib.rb create --replicas 1 172.19.0.2:6379 172.19.0.3:6379 172.19.0.4:6379 172.19.0.5:6379 172.19.0.6:6379 172.19.0.7:6379</code></pre>
</li>
</ol>
<h2 id="打包部署后端项目"><a href="#打包部署后端项目" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol>
<li><p>进入人人开源后端项目，执行打包（修改配置文件，更改端口，打包三次生成三个 JAR 文件）</p>
<pre><code class="shell">mvn clean install -Dmaven.test.skip=true</code></pre>
</li>
<li><p>安装 Java 镜像</p>
<pre><code class="shell">docker pull java</code></pre>
</li>
<li><p>创建 3 节点 Java 容器</p>
<pre><code class="shell">#创建数据卷，上传JAR文件
docker volume create j1
#启动容器
docker run -it -d --name j1 -v j1:/home/soft --net=host java
#进入j1容器
docker exec -it j1 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar

#创建数据卷，上传JAR文件
docker volume create j2
#启动容器
docker run -it -d --name j2 -v j2:/home/soft --net=host java
#进入j1容器
docker exec -it j2 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar

#创建数据卷，上传JAR文件
docker volume create j3
#启动容器
docker run -it -d --name j3 -v j3:/home/soft --net=host java
#进入j1容器
docker exec -it j3 bash
#启动Java项目
nohup java -jar /home/soft/renren-fast.jar</code></pre>
</li>
<li><p>安装 Nginx 镜像</p>
<pre><code class="shell">docker pull nginx</code></pre>
</li>
<li><p>创建 Nginx 容器，配置负载均衡</p>
<p>宿主机上/home/n1/nginx.conf 配置文件内容如下：</p>
<pre><code class="properties">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream tomcat {
        server 192.168.99.104:6001;
        server 192.168.99.104:6002;
        server 192.168.99.104:6003;
    }
    server {
        listen       6101;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://tomcat;
            index  index.html index.htm;
        }
    }
}</code></pre>
<p>创建第 1 个 Nginx 节点</p>
<pre><code class="shell">docker run -it -d --name n1 -v /home/n1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx
</code></pre>
<p>宿主机上/home/n2/nginx.conf 配置文件内容如下：</p>
<pre><code class="properties">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream tomcat {
        server 192.168.99.104:6001;
        server 192.168.99.104:6002;
        server 192.168.99.104:6003;
    }
    server {
        listen       6102;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://tomcat;
            index  index.html index.htm;
        }
    }
}</code></pre>
<p>创建第 2 个 Nginx 节点</p>
<pre><code class="shell">docker run -it -d --name n2 -v /home/n2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
</li>
<li><p>在 Nginx 容器安装 Keepalived</p>
<pre><code class="shell">#进入n1节点
docker exec -it n1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code>vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.151
    }
}
virtual_server 192.168.99.151 6201 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6101 {
        weight 1
    }
}</code></pre><pre><code class="shell">#进入n1节点
docker exec -it n2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.151
    }
}
virtual_server 192.168.99.151 6201 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6102 {
        weight 1
    }
}</code></pre>
</li>
</ol>
<h2 id="打包部署后端项目-1"><a href="#打包部署后端项目-1" class="headerlink" title="打包部署后端项目"></a>打包部署后端项目</h2><ol>
<li><p>在前端项目路径下执行打包指令</p>
<pre><code class="shell">npm run build</code></pre>
</li>
<li><p>build 目录的文件拷贝到宿主机的/home/fn1/renren-vue、/home/fn2/renren-vue、/home/fn3/renren-vue 的目录下面</p>
</li>
<li><p>创建 3 节点的 Nginx，部署前端项目</p>
<p>宿主机/home/fn1/nginx.conf 的配置文件</p>
<pre><code>user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6501;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn1/renren-vue;
            index  index.html;
        }
    }
}</code></pre><pre><code class="shell">#启动第fn1节点
docker run -it -d --name fn1 -v /home/fn1/nginx.conf:/etc/nginx/nginx.conf -v /home/fn1/renren-vue:/home/fn1/renren-vue --privileged --net=host nginx</code></pre>
<p>宿主机/home/fn2/nginx.conf 的配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6502;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn2/renren-vue;
            index  index.html;
        }
    }
}</code></pre>
<pre><code class="shell">#启动第fn2节点
docker run -it -d --name fn2 -v /home/fn2/nginx.conf:/etc/nginx/nginx.conf -v /home/fn2/renren-vue:/home/fn2/renren-vue --privileged --net=host nginx</code></pre>
<p>宿主机/home/fn3/nginx.conf 的配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    server {
        listen 6503;
        server_name  192.168.99.104;
        location  /  {
            root  /home/fn3/renren-vue;
            index  index.html;
        }
    }
}</code></pre>
<p>启动 fn3 节点</p>
<pre><code class="shell">#启动第fn3节点
docker run -it -d --name fn3 -v /home/fn3/nginx.conf:/etc/nginx/nginx.conf -v /home/fn3/renren-vue:/home/fn3/renren-vue --privileged --net=host nginx</code></pre>
</li>
<li><p>配置负载均衡</p>
<p>宿主机/home/ff1/nginx.conf 配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream fn {
        server 192.168.99.104:6501;
        server 192.168.99.104:6502;
        server 192.168.99.104:6503;
    }
    server {
        listen       6601;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://fn;
            index  index.html index.htm;
        }
    }
}</code></pre>
<pre><code class="shell">#启动ff1节点
docker run -it -d --name ff1 -v /home/ff1/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
<p>宿主机/home/ff2/nginx.conf 配置文件</p>
<pre><code class="shell">user  nginx;
worker_processes  1;
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    proxy_redirect          off;
    proxy_set_header        Host $host;
    proxy_set_header        X-Real-IP $remote_addr;
    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
    client_max_body_size    10m;
    client_body_buffer_size   128k;
    proxy_connect_timeout   5s;
    proxy_send_timeout      5s;
    proxy_read_timeout      5s;
    proxy_buffer_size        4k;
    proxy_buffers           4 32k;
    proxy_busy_buffers_size  64k;
    proxy_temp_file_write_size 64k;

    upstream fn {
        server 192.168.99.104:6501;
        server 192.168.99.104:6502;
        server 192.168.99.104:6503;
    }
    server {
        listen       6602;
        server_name  192.168.99.104;
        location / {
            proxy_pass   http://fn;
            index  index.html index.htm;
        }
    }
}</code></pre>
<pre><code class="shell">#启动ff2节点
docker run -it -d --name ff2 -v /home/ff2/nginx.conf:/etc/nginx/nginx.conf --net=host --privileged nginx</code></pre>
</li>
<li><p>配置双机热备</p>
<pre><code class="shell">#进入ff1节点
docker exec -it ff1 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.152
    }
}
virtual_server 192.168.99.151 6701 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6601 {
        weight 1
    }
}</code></pre>
<pre><code class="shell">#进入ff1节点
docker exec -it ff2 bash
#更新软件包
apt-get update
#安装VIM
apt-get install vim
#安装Keepalived
apt-get install keepalived
#编辑Keepalived配置文件(如下)
vim /etc/keepalived/keepalived.conf
#启动Keepalived
service keepalived start</code></pre>
<pre><code class="shell">vrrp_instance VI_1 {
    state MASTER
    interface ens33
    virtual_router_id 52
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 123456
    }
    virtual_ipaddress {
        192.168.99.152
    }
}
virtual_server 192.168.99.151 6701 {
    delay_loop 3
    lb_algo rr
    lb_kind NAT
    persistence_timeout 50
    protocol TCP
    real_server 192.168.99.104 6602 {
        weight 1
    }
}</code></pre>
<p>​</p>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>前端换肤的N种方案，请收下</title>
    <url>/2020/05/08/Front-End-CSS/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="前端换肤的N种方案，请收下"><a href="#前端换肤的N种方案，请收下" class="headerlink" title="前端换肤的N种方案，请收下"></a>前端换肤的N种方案，请收下</h2><h3 id="覆盖样式实现"><a href="#覆盖样式实现" class="headerlink" title="覆盖样式实现"></a>覆盖样式实现</h3><hr>
<pre><code>// light
$color-brand1: #ffcd32;
$fill-1: #fff !default;
$color-text: #3c3c3c;
$color-text-1: #757575;
$color-text-2: #222;

// dark
$dark-fill-1: #222 !default; // 品牌色
$dark-color-text: #fff;
$dark-color-text-1: rgba(255, 255, 255, 0.3);
$dark-color-text-2: $color-brand1;
// 页面使用
<style lang="scss">
@import "./assets/scss/index.scss";

[data-theme="dark"] {
  body {
    background: $dark-fill-1;
  }
  .reaconmend .reaconmend-list .item .name {
    color: $dark-color-text;
  }
  .reaconmend .reaconmend-list .item .desc {
    color: $dark-color-text-1;
  }
  .header .text {
    color: $dark-color-text-2;
  }
}
</style></code></pre><p>利用css优先级的原理覆盖掉原有样式的实现，每定义一套皮肤就要定义对应的sass变量，以及定义一套覆盖原有样式的皮肤样式。如果有多套皮肤的话，覆盖的代码量就会n套。</p>
<p><strong>缺点：</strong> 样式不易管理，查找样式复杂，开发效率低，拓展性差，维护成本高，多人协作沟通麻烦。</p>
<h3 id="sass变量实现"><a href="#sass变量实现" class="headerlink" title="sass变量实现"></a>sass变量实现</h3><hr>
<pre><code>// variable.scss  

// 浅色
$colors-light: (
  fill-1: #fff,
  text: #3c3c3c,
  text-1: #757575,
  text-2: #222,
);

// 深色
$colors-dark: (
  fill-1: #222,
  text: #fff,
  text-1: rgba(255, 255, 255, 0.3),
  text-2: #ffcd32,
);
// mixin.scss
// 背景色
@mixin bg-color($key) {
  background-color: map-get($colors-light, $key);
  [data-theme="dark"] & {
    background-color: map-get($colors-dark, $key);
  }
}
// text色
@mixin text-color($key) {
  color: map-get($colors-light, $key);
  [data-theme="dark"] & {
    color: map-get($colors-dark, $key);
  }
}
// 页面使用

<style lang="scss" rel="stylesheet/scss">
@import "../../../assets/scss/variable.scss";
@import "../../../assets/scss/mixin.scss";
.reaconmend-list {
    .list-title {
      height: 40px;
      line-height: 40 px;
      text-align: center;
        @include text-color(text-1);
    }
}
</style></code></pre><p>如上所示用到的知识点包含Sass变量（variable），嵌套（nestend rules），混合（mixins）， Sass Maps的函数-map-get(key)。</p>
<blockquote>
<p>Maps的含义：Maps可视为键值对的集合，键被用于定位值 在css种没有对应的概念。和Lists不同Maps必须被圆括号包围，键值对被都好分割 。Maps中的keys和values可以是sassscript的任何对象。（包括任意的sassscript表达式 arbitrary SassScript expressions） 和Lists一样Maps主要为sassscript函数服务，如 map-get函数用于查找键值，map-merge函数用于map和新加的键值融合，@each命令可添加样式到一个map中的每个键值对。Maps可用于任何Lists可用的地方，在List函数中 Map会被自动转换为List ， 如 (key1: value1, key2: value2)会被List函数转换为 key1 value1, key2 value2 ，反之则不能。(网友Soledad提供)</p>
</blockquote>
<p><strong>使用scss变量换肤相比覆盖样式</strong></p>
<ul>
<li>拓展性更强</li>
<li>将换肤的逻辑进行了收敛</li>
</ul>
<h3 id="生成多套皮肤css"><a href="#生成多套皮肤css" class="headerlink" title="生成多套皮肤css"></a>生成多套皮肤css</h3><hr>
<p>使用覆盖样式实现与scss变量实现会把多套皮肤的样式都编译到一个css文件里面，如果有多套皮肤样式，这个文件是会非常大的。为了解决这样的问题，就自然的想出了拆分scss的实现：</p>
<p>实现方案，通过编译工具与构建工具编译出多套皮肤css，通过js动态的link对应的皮肤样式</p>
<pre><code>// js动态处理
 var theme = /\bt=(\w+)/.exec(location.search);
 theme = theme ? theme[1] : "light";

 changeTheme(theme);

function changeTheme(theme) {
    var head = document.getElementsByTagName("head")[0];
    var link = document.createElement("link");
    link.dataset.type = "theme";
    link.href = "assets/css/theme-" + theme + "/pages/home/home.css";
    link.rel = "stylesheet";
    link.type = "text/css";
    head.appendChild(link);
}</code></pre><h3 id="CSS变量实现"><a href="#CSS变量实现" class="headerlink" title="CSS变量实现"></a>CSS变量实现</h3><hr>
<pre><code>// variable.scss
// 默认变量
:root {
  --fill-1: #fff;
  --text: #3c3c3c;
  --text-1: #757575;
  --text-2: #222;

  --font-size-large: 18px;
  --font-size-large-x: 22px;
  --font-size-medium: 14px;
  --font-size-medium-x: 16px;
  --font-size-small-s: 10px;
  --font-size-small: 12px;
}
// 深色变量
[data-theme="dark"] {
  --fill-1: #222;
  --text: #fff;
  --text-1: rgba(255, 255, 255, 0.3);
  --text-2: #ffcd32;
}</code></pre><p>在页面对css变量做引入使用</p>
<pre><code>// 页面使用
@import "../../assets/scss/variable.scss";

.header {
  position: relative;
  height: 70px;
  text-align: center;
  font-size: 0; 
  .text {
    display: inline-block;
    vertical-align: top;
    line-height: 70px;
    font-size: var(--font-size-large);
    color: var(--text-2);
  }
}</code></pre><p>具体的实现效果：<a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/2.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/2.gif" class="lazyload"></a></p>
<blockquote>
<p>问题点：css变量会存在兼容性问题</p>
</blockquote>
<p>css变量兼容性如下：<a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/3.png" class="lazyload"></a><br>虽然现在大部分主流浏览器都可以兼容，但是还要考虑更多的兼容性这块的请往下看：</p>
<h3 id="CSS变量兼容性实现-1"><a href="#CSS变量兼容性实现-1" class="headerlink" title="CSS变量兼容性实现-1"></a>CSS变量兼容性实现-1</h3><hr>
<blockquote>
<p>在css变量的基础上新增了postcss-custom-properties这个插件 安装依赖：npm install postcss-custom-properties –save-dev npm install postcss-loader –save-dev</p>
</blockquote>
<p>在根目录新建postcss.config.js增加配置，配置如下：</p>
<pre><code>const postcssCustompProperties = require("postcss-custom-properties");

module.exports = {
  plugins: [
    postcssCustompProperties({
      importFrom: "src/assets/scss/variable.scss"
    })
  ]
};</code></pre><p>postcss 会将css自定义变量直接编译为<code>确定值</code>，而<code>不是保留</code>。这时就需要 <code>postcss 插件</code> 来为我们保留这些自定义变量，使用 postcss-custom-properties效果如下：<a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/4.webp" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/4.webp" class="lazyload"></a></p>
<ul>
<li>优点：会生成一套与css变量对应的css</li>
<li>缺点：在构建时根据css变量生成对应的css，换肤是运行时并不能生成对应的css。</li>
</ul>
<p>换肤后样式：</p>
<p><a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/5.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/5.png" class="lazyload"></a></p>
<h3 id="CSS变量兼容性实现-2"><a href="#CSS变量兼容性实现-2" class="headerlink" title="CSS变量兼容性实现-2"></a>CSS变量兼容性实现-2</h3><hr>
<p>首先需要建一个存放公共css变量的js文件，将需要定义的css变量存放到该js文件，例如（variable.js）</p>
<pre><code>// variable.js

// 字体变量
const baseSize = {
  "--font-size-large-x": "22px",
  "--font-size-large": "18px",
  "--font-size-medium": "14px",
  "--font-size-medium-x": "16px",
  "--font-size-small-s": "10px",
  "--font-size-small": "12px",
};

//浅色
export const lightTheme = {
  "--fill-1": "#fff",
  "--text": "#3c3c3c",
  "--text-1": "#757575",
  "--text-2": "#222",
  ...baseSize,
};

// 深色
export const darkTheme = {
  "--fill-1": "#222",
  "--text": "#fff",
  "--text-1": "rgba(255, 255, 255, 0.3)",
  "--text-2": "#ffcd32",
  ...baseSize,
};</code></pre><p>页面使用css变量，例如：</p>
<pre><code><style lang="scss">
 .text {
    display: inline-block;
    vertical-align: top;
    line-height: 70px;
    font-size: var(--font-size-large);
    color: var(--text-2);
  }
</style></code></pre><p>安装css-vars-ponyfill 插件</p>
<blockquote>
<p><strong>css-vars-ponyfill</strong>官方概念：在传统浏览器和现代浏览器中为CSS自定义属性(又名“CSS变量”)提供客户端支持的ponyfill。（具体用法与概念请查阅官方网站：<strong>css-vars-ponyfill</strong>）</p>
</blockquote>
<p>封装切换主题的js，在main.js做初始化调用</p>
<pre><code>// theme.js
import { lightTheme, darkTheme } from "../src/assets/js/variable";
import cssVars from "css-vars-ponyfill";
export const initTheme = (theme) => {
  document.documentElement.setAttribute("data-theme", theme ? "light" : "dark");
  cssVars({
    watch: true, // 当添加，删除或修改其<link>或<style>元素的禁用或href属性时，ponyfill将自行调用
    variables: theme ? lightTheme : darkTheme, // variables 自定义属性名/值对的集合
    onlyLegacy: false, // false  默认将css变量编译为浏览器识别的css样式  true 当浏览器不支持css变量的时候将css变量编译为识别的css
  });
};</code></pre><p><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/5.webp" alt="img"><br>在切换主题的按钮组件中调用!<br><a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/6.png" target="_blank" rel="noopener">img</a></p>
<p>总结：css自定义属性 + css-vars-ponyfill(解决兼容性) 预览效果!<br><a href="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/7.gif" target="_blank" rel="noopener">img</a></p>
<blockquote>
<p>细心的小伙伴们，一定发现了这里的css变量已经编译成浏览器可识别的css样式了。</p>
</blockquote>
<h3 id="ElementUI实现"><a href="#ElementUI实现" class="headerlink" title="ElementUI实现"></a>ElementUI实现</h3><hr>
<p>官方的实现解释</p>
<ul>
<li>先把默认主题文件中涉及到颜色的 CSS 值替换成关键词：github.com/ElementUI/t…</li>
<li>根据用户选择的主题色生成一系列对应的颜色值：github.com/ElementUI/t…</li>
<li>把关键词再换回刚刚生成的相应的颜色值：github.com/ElementUI/t…</li>
<li>直接在页面上加 <code>style</code> 标签，把生成的样式填进去：github.com/ElementUI/t…</li>
</ul>
<p>已实现的链接参考：<a href="https://juejin.im/post/5ca41617f265da3092006155#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5ca41617f265da3092006155#heading-1</a></p>
<h3 id="less在线编译实现"><a href="#less在线编译实现" class="headerlink" title="less在线编译实现"></a>less在线编译实现</h3><hr>
<p>根据<strong>less</strong>可以直接 编译<strong>less变量</strong>实现的步骤如下：</p>
<pre><code>// variable.less 定义less变量
// 公共字体
@font-size-large-x: 22px;
@font-size-large: 18px;
@font-size-medium: 14px;
@font-size-medium-x: 16px;
@font-size-small-s: 10px;
@font-size-small: 12px;

// 浅色
@fill-1: #fff;
@text: #3c3c3c;
@text-1: #757575;
@text-2: #222;

// 页面使用 例如：
// 下面.text的css 如下，这里的 @font-size-large 和  @text-2就是 less 变量：
.text {
    display: inline-block;
    vertical-align: top;
    line-height: 70px;
    font-size: @font-size-large;
    color: @text-2;
  }</code></pre><p>当点击换肤按钮的时候，直接去加载 <code>less.js</code>，具体代码如下:</p>
<pre><code><template>
  <div class="header">
    <div class="text">小恐龙换肤</div>
    <div role="switch" class="switch" :class="theme === true ? 'is-checked' : ''">
      <input type="checkbox" class="switch-input" />
      <span class="switch-core" @click="changeTheme"></span>
    </div>
  </div>
</template>

<script>
import { lightTheme, darkTheme } from "../../assets/js/variable";
export default {
  name: "m-header",
  data() {
    return {
      theme: true
    };
  },
  methods: {
    changeTheme() {
      this.theme = !this.theme;
      // 调用 `less.modifyVars` 方法来改变变量值
      window.less.modifyVars(this.theme ? lightTheme : darkTheme);
    }
  },
  mounted() {}
};
</script></code></pre><p>定义variable.js是因为如果直接将less变量放在modifyVars中切换的效果只会生效一次，所以根据切换的状态使用对应的less变量。</p>
<pre><code>//浅色
export const lightTheme = {
  "@fill-1": "#fff",
  "@text": "#3c3c3c",
  "@text-1": "#757575",
  "@text-2": "#222",
};

// 深色
export const darkTheme = {
  "@fill-1": "#222",
  "@text": "#fff",
  "@text-1": "rgba(255, 255, 255, 0.3)",
  "@text-2": "#ffcd32",
};</code></pre><p>然后点击色块进行试验，发现并没有生效，这是why？然后就去看了其文档，原来它会找到所有如下的less 样式标签，并且使用已编译的css同步创建 style 标签。也就是说我们必须吧代码中所有的less 都以下面这种link的方式来引入，这样<code>less.js</code> 才能在浏览器端实现编译。</p>
<blockquote>
<p>``</p>
</blockquote>
<p>这里我用了vue，所以直接把 <code>less</code> 文件放在了<code>public</code>目录下，然后在html中直接引入：<br><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/8.webp" alt="img"><br><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/9.webp" alt="img"></p>
<p><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/10.webp" alt="img"><br>点击切换按钮，可见background和color确实都变了<br><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/11.webp" alt="img"><br><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/12.webp" alt="img"></p>
<blockquote>
<p>注：使用less 来实现换肤要注意 <code>less 文件</code>在 <code>html</code> 中编写的位置，不然很可能被其他css 文件所干扰导致换肤失败。如果less文件特别大，会存在编译性能问题。</p>
</blockquote>
<h3 id="拓展-图片切换"><a href="#拓展-图片切换" class="headerlink" title="拓展-图片切换"></a>拓展-图片切换</h3><hr>
<p>以上的方案—只是对background-color和color进行的换肤，如果要对图片进行换肤该怎么办呐？                   </p>
<p><strong>图片切换</strong></p>
<p>项目中还存在很多占位图或者其他图片会随着主题的变化而变化。通过引入所有图片，并用文件名来区分不同主题所对应的图片。在点击切换主题时，切换到主题所对应的文件，就能实现图片切换了。</p>
<blockquote>
<img class :src="avatar" alt>
</blockquote>
<pre><code>// 页面实现
<template>
  <div class="header">
    <div class="text">小恐龙换肤</div>
    <div role="switch" class="switch" :class="theme === true ? 'is-checked' : ''">
      <input type="checkbox" class="switch-input" />
      <span class="switch-core" @click="changeTheme"></span>
    </div>
  </div>
</template>
<script>
import { initTheme } from "../../theme";
import bus from "../../bus";
export default {
  name: "m-header",
  data() {
    return {
      theme: true, // false深色主题
      avatar: ""
    };
  },
  methods: {
    changeTheme() {
      this.theme = !this.theme;
      initTheme(this.theme);
      this.setThemeValue(this.theme);
      bus.$emit("changeTheme", this.theme);
    },
    setThemeValue(theme) {
      theme = theme ? "light" : "dark";
      this.avatar = require(`@/assets/images/logo-${theme}.jpeg`);
    }
  },
  created() {
    this.setThemeValue(this.theme);
  }
};
</script></code></pre><p>在点击切换主题时，会发射一个 <code>changeTheme</code> 事件，各组件接收到 <code>changeTheme</code> 事件，就会为图片重新赋值，也就达到了切换图片的效果。</p>
<p><img src="https://tingres.obs.cn-north-4.myhuaweicloud.com/it-ing.cn/20200503/13.gif" alt="img"></p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><hr>
<p>很感谢能在百忙中抽出时间把这篇文章看完的小伙伴:) 如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。好了，本文到此结束，希望对你有帮助 :)</p>
</body></html></style></code></pre></body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>初谈软件架构与前端架构演进</title>
    <url>/2020/03/03/Front-End-Construct/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="初谈软件架构及前端架构演进"><a href="#初谈软件架构及前端架构演进" class="headerlink" title="初谈软件架构及前端架构演进"></a>初谈软件架构及前端架构演进</h1><h2 id="1、什么是软件架构？"><a href="#1、什么是软件架构？" class="headerlink" title="1、什么是软件架构？"></a>1、什么是软件架构？</h2><a href="https://goss3.cfp.cn/creative/vcg/nowarter800/version2/168582954.jpg?x-oss-process=image/format,webp" data-fancybox="group" data-caption="undefined" class="fancybox"><img align="center" max-width="400" data-src="https://goss3.cfp.cn/creative/vcg/nowarter800/version2/168582954.jpg?x-oss-process=image/format,webp" class="lazyload"></a>
  人人都在说软件架构，但人们并不能给出一个准确的定义，就像Martin Folwer在《Making Architecture Matter》上分享说的，<font color="red">Architecture is about the important stuff. Whatever that is</font>。

<p>  软件界的人们长期以来一直在争论架构的定义。对于某些人来说，这就像是系统的基本结构，或者是将最高级别的组件连接在一起的方式。但Martin认为没有客观的方法来定义基本的或高级的组件，软件架构的更多是专家开发人员对于系统的设计的共同理解。</p>
<p>  架构的第二种常见定义是，它是“需要在项目早期就做出的设计决策”，但是Martin觉得更像是在项目开发过程中你期望能够早日做出的正确决策。</p>
<p>  因此，软件架构是关于软件开发中重要的事情。思考软件架构其实就是思考哪些是最重要的事情，并且要保持这些部分始终运行在良好的状态下。<br><a href="img/02.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/02.jpg" class="lazyload"></a><br><font color="red">软件架构通常涵盖三个部分：</font></p>
<blockquote>
<p>架构模型：定义了系统组件是如何组织和拼装的，明确系统的组件模块，划分各自边界以及如何组合在一起。<br>通信接口：定义了系统组件之间是如何进行通信的，通常指的是组件/模块之间的通信方式、接口定义、API。<br>质量要求：定义了非功能性的系统要求，例如扩展性、稳定性、高可用性、高并发、高性能、安全等等。</p>
</blockquote>
<p><a href="img/03.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/03.jpg" class="lazyload"></a></p>
<p><font color="red">不同阶段构成架构的因素是不同的，基于这个思路，架构设计可以分为四个层级：</font></p>
<blockquote>
<p>系统级，即应用在整个系统内的关系，如与后台服务如何通信，与第三方系统如何集成。<br>应用级，即应用外部的整体架构，如多个应用之间如何共享组件、如何通信等。<br>模块级，即应用内部的模块架构，如代码的模块化、数据和状态的管理等。<br>代码级，即从基础设施来保障架构实施。</p>
</blockquote>
<p><a href="img/04.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/04.jpg" class="lazyload"></a></p>
<h2 id="2、为什么软件架构很重要？"><a href="#2、为什么软件架构很重要？" class="headerlink" title="2、为什么软件架构很重要？"></a>2、为什么软件架构很重要？</h2><p>  软件架构代表了软件内部是组织运作的方式，这个往往并不会被用户所感知，因此，软件架构在某些时候会被忽略。</p>
<p>  对于用户而言，良好的用户界面和系统运行错误是能够被感知的，而内部的模块化设计并不会被感知，于是，良好的架构设计是很难被衡量的。</p>
<p><a href="img/05.png" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/05.png" class="lazyload"></a></p>
<p>  架构的根本价值在于能够降低未来功能开发的成本。</p>
<p>  如上图所示，对于架构糟糕的系统而言，其初始的开发速度是比较快的，但是随着时间的推移，要在其上面添加新功能变的越来越困难。开发人员需要花更多的时间理解原有的代码，需要更多的时间进行测试，并且很容易出现问题需要修复。</p>
<p>  对于架构良好的系统而言，虽然其初始的开发速度不快，但随着时间的推移，其研发效率将会变得很快，并且易于扩展。</p>
<p>  可悲的是，软件开发人员通常不能很好地解释这种情况。管理者不想让开发人员编写高质量的代码，因为它花费的时间太长。我们习惯于在生活中进行大多数决定的成本与质量之间的通常取舍，对软件的内部质量没有意义。由于成本与内部质量之间的关系是不寻常且违反直觉的关系，因此，良好的软件架构在长期而言是非常重要的。</p>
<h2 id="3、有哪些架构设计模型？"><a href="#3、有哪些架构设计模型？" class="headerlink" title="3、有哪些架构设计模型？"></a>3、有哪些架构设计模型？</h2><p><a href="img/06.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/06.jpg" class="lazyload"></a></p>
<p>  对于软件架构设计模型，我们可以从两个层面来看。第一个层面对应的是系统的情况，所有功能在一个单一巨石系统(Monolithic)、基于服务的系统(Service-based)和分布式系统(Dsitributed)。</p>
<h3 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h3><p>对于巨石系统而言，通常的软件架构方式是基于分层设计。</p>
<p><a href="img/07.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/07.jpg" class="lazyload"></a></p>
<p>通过分层设计可以将系统进行解耦拆分，每一层都会专注于自己的功能，并且提供对外暴露的接口以供上层调用。</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p>对于基于服务的系统而言，通常的软件架构方式是微服务架构。</p>
<p><a href="img/08.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/08.jpg" class="lazyload"></a></p>
<p>通过将一个巨大的系统拆分成一个个独立的、单独部署的服务(Service)，可以让系统变成松耦合的状态。服务之间通过API进行通信，并且所有的服务通过特定的组织方式整合在一起共同工作。</p>
<p>每个小服务都在自己的进程中运行并与轻量级通信机制（通常是HTTP API）进行通信。这些服务围绕业务功能构建，并且可以由全自动部署机制独立部署。这些服务几乎没有集中管理，它可以用不同的编程语言编写并使用不同的数据存储技术。尽管微服务的优势使它们在最近几年变得非常时尚，但它们却带来了分销增加，一致性降低的缺点，并且要求运维管理成熟。</p>
<h3 id="插件式架构-Service-Oriented-Architecture"><a href="#插件式架构-Service-Oriented-Architecture" class="headerlink" title="插件式架构(Service Oriented Architecture)"></a>插件式架构(Service Oriented Architecture)</h3><p><a href="img/09.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/09.jpg" class="lazyload"></a></p>
<p>插件式的架构体系，通常由一个核心系统(Kernal系统)和一系列插件组成。核心系统提供了最小可用的功能，通过插件来不断扩展系统能力。浏览器、文本编辑器、IDE等系统就都是采用插件式架构体系。</p>
<h2 id="4、前端架构演进"><a href="#4、前端架构演进" class="headerlink" title="4、前端架构演进"></a>4、前端架构演进</h2><p><a href="img/10.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/10.jpg" class="lazyload"></a></p>
<p>前端过去十年发展经历了巨大的变化，从PC时代进入了移动时代再到智能时代，前端架构也从无到有，逐步演进变得百花齐发。</p>
<h3 id="前后端分离架构"><a href="#前后端分离架构" class="headerlink" title="前后端分离架构"></a>前后端分离架构</h3><p><a href="img/11.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/11.jpg" class="lazyload"></a></p>
<p>随着前后端分工划分越来越明确，前后端系统也逐步分离。前端系统变成了静态前端资源，部署HTML、JS、CSS文件，后端服务提供API（通常是REST API），前后端通过API进行通信。</p>
<p>前后端分离解决了前后端分工的问题，但是随着移动互联网到来，前端变成多端状态（PC、iOS、Android），因此后端服务需要针对不同端提供定制化服务，前后端协同沟通成本开始变大。</p>
<p>于是，Node BFF应运而生。通过Node层，前端的研发人员就可以来编写后端服务的适配层，用于接口的整合编排、字段裁剪，甚至服务端渲染直出提升首屏性能。</p>
<p>Node服务虽然可以进一步提升前后端协同的效率，但是Node服务器的运维、部署、发布、监控等等成本也让前端研发同学苦不堪言。Serverless的诞生可以帮助解决这个问题，可以将服务器的运维功能都交给Serverless平台进行管理，研发人员只需要专注于实现函数即可完成功能开发。</p>
<p><a href="img/12.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/12.jpg" class="lazyload"></a></p>
<p>在前后端分离BFF，除了采用Node层技术以外还可以采用GraphQL技术，通过GraphQL技术可以很容易使用Schema来定义需要获取的数据结构，灵活的对现有数据源进行聚合和字段裁剪。</p>
<h3 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h3><p><a href="img/13.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/13.jpg" class="lazyload"></a><br>组件化架构是前端一个最为显著的架构方式，通过组件的封装和组合，可以快速的进行页面UI的搭建。</p>
<p>组件化也经历了不同阶段的演进：<br>组件库：以Ant Design、Element为代表，提供一系列统一设计语言的原子组件。<br>模板库：以Ant Design Pro为代表，提供一系列的组件模板/页面模板，例如用户详情页、登录页等等，方便快速搭建功能页面。<br>配置化：以Fusion Design、飞冰、云凤蝶为代表，通过可视化拖拽来自由拼装页面，进一步提升前端研发效率。</p>
<h3 id="分层架构-1"><a href="#分层架构-1" class="headerlink" title="分层架构"></a>分层架构</h3><p><a href="img/14.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/14.jpg" class="lazyload"></a></p>
<p>不论是MVC（Model-View-Controller）还是MPV（Model-Presenter-View）模式，都是将数据、界面、控制分离的方式。通过代码职责的拆分可以有效的将系统进行解耦，从而让各自部分能够很好的分工并且协同。<br><a href="img/16.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/16.jpg" class="lazyload"></a></p>
<p>随着页面逻辑复杂度提升，又演化出Redux、Mobx等数据流控制的框架，进一步将数据控制部分拆分成Store、Action、Dispatcher，避免了数据更改的混乱，将数据管理进行了统一，规范了数据修改的方式。<br><a href="img/17.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/17.jpg" class="lazyload"></a></p>
<p>Clean Architecture是分层架构的一种形态，分为Entities、User Case、Controllers、UI四层，外部层级是依赖内部层级，内部层级会对外暴露接口，但是避免暴露内部实现，所以越是上层的功能可以屏蔽掉内部的变化，降低层级之间的耦合度。</p>
<h3 id="微前端架构"><a href="#微前端架构" class="headerlink" title="微前端架构"></a>微前端架构</h3><p><a href="img/18.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/18.jpg" class="lazyload"></a></p>
<p>微前端架构是一种将微服务理念应用到浏览器，将多个小型前端应用聚合为一的应用。微前端架构可以允许各自小型应用独立部署、独立的技术栈，因此，特别适合遗留老旧系统的整合。</p>
<p>不必花费大量人力对老旧系统进行技术栈升级，通过微前端架构即可将其整合到新应用中。在新应用中可以使用新技术栈，老应用技术栈保持原状，两者功能上又可以进行通信和整合。</p>
<h2 id="5、写在最后"><a href="#5、写在最后" class="headerlink" title="5、写在最后"></a>5、写在最后</h2><p>软件架构也“没有银弹”，不存在某个普世好用的架构。软件架构总是伴随着业务功能的发展、系统稳定性、并发性不断发展而不断演进的。结合业务发展的规模，人员的能力，找到最适合你的架构才是最好的架构设计。<br><a href="img/19.jpg" data-fancybox="group" data-caption="markedown" class="fancybox"><img alt="markedown" title="markedown" data-src="img/19.jpg" class="lazyload"></a><br>最后，推荐几本关于软件架构的经典著作，如果有推荐的书籍欢迎留言交流。</p>
</body></html>]]></content>
      <categories>
        <category>前端架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
        <tag>前端</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
  <entry>
    <title>前端骨架屏生成技术揭秘</title>
    <url>/2020/03/25/Front-End-Skeleton/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- # 前端骨架屏生成技术揭秘 -->

</head><body><h1 id="1-为什么要使用骨架屏"><a href="#1-为什么要使用骨架屏" class="headerlink" title="1. 为什么要使用骨架屏"></a>1. 为什么要使用骨架屏</h1><p>骨架屏就是在页面数据尚未加载前，先给用户展示出页面的大致结构（灰色占位图），直到请求数据返回后再渲染页面，补充进需要显示的数据内容，考拉H5购物车就使用了骨架屏技术：</p>
<p><a href="./1.gif" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="./1.gif" class="lazyload"></a></p>
<p>了解了骨架屏是什么，我们来看看为什么要使用骨架屏。 假如能在加载前把网页的大概轮廓预先显示，接着再逐渐加载真正内容，这样既降低了用户的焦灼情绪，又能使界面加载过程变得自然通畅，不会造成网页长时间白屏或者闪烁。骨架屏能给人一种页面内容“已经渲染出一部分”的感觉，相较于传统的 loading 效果，在一定程度上可<strong>提升用户体验</strong>。尤其在下面场景中，骨架屏技术能极大提高用户体验：</p>
<ul>
<li>网络较慢，需要长时间等待加载处理的情况下。</li>
<li>图文信息内容较多的列表/卡片中。</li>
<li>首屏加载数据量较大的时候。</li>
</ul>
<h1 id="2-骨架屏技术总览"><a href="#2-骨架屏技术总览" class="headerlink" title="2. 骨架屏技术总览"></a>2. 骨架屏技术总览</h1><p>目前主流的骨架屏生成技术主要包括以下三种：</p>
<ol>
<li>通过设计师给出的骨架屏图片。</li>
<li>通过 HTML+CSS 编写骨架屏代码。</li>
<li>非侵入式自动生成骨架屏代码。</li>
</ol>
<p>前两种情况由于变更成本和续维护成本高，且对业务代码有一定侵入性，不进行讨论。业界对于自动生成骨架屏有多种实践，但是存在一些问题，有些配置较少，生成效果较差；有些操作繁琐，项目集成成本高，且难以定制。</p>
<p>本文主要针对自动生成骨架屏技术进行了深入的探讨，并开发了 awesome-skeleton，支持多种配置，以及骨架屏定制功能，并提供骨架图生成和骨架图模板注入能力。</p>
<h1 id="3-自动生成骨架屏技术揭秘"><a href="#3-自动生成骨架屏技术揭秘" class="headerlink" title="3. 自动生成骨架屏技术揭秘"></a>3. 自动生成骨架屏技术揭秘</h1><p>谷歌浏览器在2017年自行开发了 Chrome Headless 特性，并与之同时推出了 Puppeteer。Puppeteer 是一个 Node库，提供了一组用来操纵 Chrome 的 API，默认 Headless 也就是无界面的chrome，俗称“无头浏览器”。我们在浏览器中完成的大多数操作都可以在 Puppeteer 中完成，比如截图、爬虫、自动化测试、性能分析等。</p>
<p>借助 Puppeteer，我们对自动生成骨架屏方案进行了如下设计：</p>
<ul>
<li>使用 Puppeteer 进行页面渲染，获取页面 DOM 结构；</li>
<li>命令行工具生成骨架屏代码，并支持第三方平台接入；</li>
<li>支持页面登录态、不同设备页面显示、列表重复渲染、骨架屏灰色块大小配置；</li>
<li>支持骨架屏图片压缩和代码自动生成；</li>
<li>通过 DOM 属性进行骨架屏细粒度的配置，指定节点配置，包括背景色、是否在骨架屏中显示等。</li>
</ul>
<p>我们可以通过传入页面地址，使用无头浏览器打开页面，对页面首屏图片和文本等节点进行灰色背景处理，然后对页面首屏进行截图，生成压缩后的 base64 png 图片，并注入 HTML + CSS，从而自动生成页面骨架屏。流程见下图：</p>
<p><a href="./2.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./2.jpg" class="lazyload"></a></p>
<h2 id="3-1-使用-Puppeteer-渲染页面"><a href="#3-1-使用-Puppeteer-渲染页面" class="headerlink" title="3.1 使用 Puppeteer 渲染页面"></a>3.1 使用 Puppeteer 渲染页面</h2><p>使用 Puppeteer 可以指定不同设备模拟器来渲染页面，从而获取页面的 DOM 结构。关键代码：</p>
<pre><code class="javascript">// 初始化无头浏览器
const browser = await puppeteer.launch({
  headless: !options.debug, // 是否打开无头浏览器
  args: [ '--no-sandbox', '--disable-setuid-sandbox' ],
});
// 打开新页面
const page = await browser.newPage();
// 指定设备模拟器
const device = devices[options.device] || desktopDevice;
await page.emulate(device);
// 打开指定页面
await page.goto(options.pageUrl);</code></pre>
<p>获取到页面 DOM 结构之后，需要对其进行处理，例如将图片转换为灰色色块，隐藏大小小于一定阈值的节点，这里我们通过向页面中动态插入一端 JavaScript 脚本，对页面节点进行处理，从而生成骨架屏。关键代码：</p>
<pre><code class="javascript">// 获取处理 DOM 节点的脚本代码
const scriptContent = await genScriptContent();
// 将代码插入到页面中
await page.addScriptTag({ content: scriptContent });</code></pre>
<h2 id="3-2-页面-DOM-处理"><a href="#3-2-页面-DOM-处理" class="headerlink" title="3.2 页面 DOM 处理"></a>3.2 页面 DOM 处理</h2><p>下面我们来重点看看如何对页面节点进行处理，主要包括以下内容：</p>
<p><a href="./3.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./3.jpg" class="lazyload"></a></p>
<h3 id="3-2-1-预处理"><a href="#3-2-1-预处理" class="headerlink" title="3.2.1 预处理"></a>3.2.1 预处理</h3><p>首先，对页面所有节点进行下列处理：</p>
<ul>
<li>置空所有大小小于指定阈值的节点</li>
<li>所有节点背景图设置为 none，并且将背景色设置为骨架屏主色调（灰色）</li>
<li>所有节点阴影、边框颜色设置为主色调</li>
<li>置空所有标签中含有 “data-skeleton-empty” 属性的节点</li>
<li>若节点设置了“data-skeleton-bgcolo”，则选取其属性值来设置背景色。### 文本处理 本文处理是所有节点中比较复杂的一种，需要考虑文本是一行还是多行、文本是位置是居中还是左对齐等，通过获取文本位置和样式，通过简单的计算来设置灰色色块位置。下面只列出了关键代码，全部代码见：text.js。</li>
</ul>
<pre><code class="javascript">// 获取行高
if (!/\d/.test(lineHeight)) {
  const fontSizeNum = parseInt(fontSize, 10) || 14;
  lineHeight = `${fontSizeNum * 1.4}px`;
}
// 获取行数
let lineCount = (height - parseFloat(paddingTop, 10) - parseFloat(paddingBottom, 10)) / parseFloat(lineHeight, 10) || 0;
lineCount = lineCount < 1.5 ? 1 : lineCount;
// 设置文本色块样式
ele.classList.add(SKELETON_TEXT_CLASS);
Object.assign(ele.style, {
  backgroundImage: `linear-gradient(
  transparent ${(1 - textHeightRatio) / 2 * 100}%,
  ${MAIN_COLOR} 0%,
  ${MAIN_COLOR} ${((1 - textHeightRatio) / 2 + textHeightRatio) * 100}%,
  transparent 0%
  )`,
  backgroundSize: `100% ${px2rem(parseInt(lineHeight) * 1.1)}`,
  position,
});
// 添加文本Mask
if (lineCount > 1) { // 多行情况特殊处理
  addTextMask(ele, Object.assign(JSON.parse(JSON.stringify(comStyle)), {
    lineHeight,
  }));
} else { // 单行文本处理
  const textWidthPercent = textWidth / (width - parseInt(paddingRight, 10) - parseInt(paddingLeft, 10));
  ele.style.backgroundSize = `${textWidthPercent * 100}% 100%`;
  switch (textAlign) {
    case 'left':
      break;
    case 'right':
      ele.style.backgroundPositionX = '100%';
      break;
    default: // center
      ele.style.backgroundPositionX = '50%';
      break;
  }
}</code></pre>
<h3 id="3-2-2-列表处理"><a href="#3-2-2-列表处理" class="headerlink" title="3.2.2 列表处理"></a>3.2.2 列表处理</h3><p>可以根据配置，对列表进行重复处理，也就是根据列表的第一项重复渲染其他项，关键代码：</p>
<pre><code class="javascript">const listHandler = (node, options) => {
  if (!options.openRepeatList || !node.children.length) return;
  const children = node.children;
  const len = Array.from(children).filter(child => LIST_ITEM_TAG.indexOf(child.tagName) > -1).length;
  if (len === 0) return false;
  const firstChild = children[0];
  // 若元素不是列表节点，则递归处理
  if (LIST_ITEM_TAG.indexOf(firstChild.tagName) === -1) {
    return listHandler(firstChild, options);
  }
  // 只保留第一个项目
  Array.from(children).forEach((li, index) => {
    if (index > 0) {
      removeElement(li);
    }
  });
  // 重复渲染剩余项
  for (let i = 1; i < len; i++) {
    node.appendChild(firstChild.cloneNode(true));
  }
};</code></pre>
<h3 id="3-2-3-其他节点"><a href="#3-2-3-其他节点" class="headerlink" title="3.2.3 其他节点"></a>3.2.3 其他节点</h3><p>其他节点的处理较为简单，有兴趣可以在 Github 上查看代码，这里有几个需要关注的点：</p>
<ul>
<li>a 标签需要移除 href 属性</li>
<li>button 标签需要设置宽高，保证在移除按钮文案后宽高不变</li>
<li>img 标签也需要设置宽高，并将 src 设置为 1px 的 base64</li>
<li>input 标签需要移除 placeholder</li>
<li>伪元素同样需要处理。</li>
</ul>
<h3 id="3-2-4-文本类型特殊处理"><a href="#3-2-4-文本类型特殊处理" class="headerlink" title="3.2.4 文本类型特殊处理"></a>3.2.4 文本类型特殊处理</h3><p>需要注意的是，对于文本节点，由于存在下面的情况，所以需要进行特殊处理：</p>
<pre><code class="html"><span>111<a>222</a></span> 文本中包含超链接
<span>111<a href="xx" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="xx" class="lazyload"></a></span> 文本中包含图片
111 文本没有使用标签包裹</code></pre>
<p>文本类型进行处理的关键代码：</p>
<pre><code class="javascript">handleText(node) {
  const tagName = node.tagName && node.tagName.toUpperCase();
  // 处理 <div>xxx</div> or <a>xxx</a>
  if (node.childNodes && node.childNodes.length === 1 && node.childNodes[0].nodeType === 3) {
    handler.text(node, this.options);
    return true;
  }
  // 处理 xxx，转换为 <i>xxx</i>
  if (node && node.nodeType === 3 && node.textContent) {
    const parent = node.parentNode;
    // Determine if it has been processed
    if (!parent.classList.contains(SKELETON_TEXT_CLASS)) {
      // It is plain text itself and needs to be replaced with a node
      const textContent = node.textContent.replace(/[\r\n]/g, '').trim();
      if (textContent) {
        const tmpNode = document.createElement('i');
        tmpNode.classList.add(SKELETON_TEXT_CLASS);
        tmpNode.innerText = textContent;
        node.parentNode.replaceChild(tmpNode, node);
        handler.text(tmpNode, this.options);
        return true;
      }
    }
  }
  // 处理 <span>111<a>222</a></span> <span>111<a href="xx" data-fancybox="group" data-caption="undefined" class="fancybox"><img data-src="xx" class="lazyload"></a></span>
  if (tagName === 'SPAN' && node.innerHTML) {
    // Process image and background image first
    this.handleImages(node.childNodes);
    handler.text(node, this.options);
    return true;
  }
  return false;
}</code></pre>
<h3 id="3-2-5-处理页面节点入口函数"><a href="#3-2-5-处理页面节点入口函数" class="headerlink" title="3.2.5 处理页面节点入口函数"></a>3.2.5 处理页面节点入口函数</h3><p>有些上述单个节点的处理函数，我们可以遍历页面所有节点进行处理。关键代码：</p>
<pre><code class="javascript">handleNode(node) {
  if (!node) return;
  // Delete elements that are not in first screen, or marked for deletion
  if (!inViewPort(node) || hasAttr(node, 'data-skeleton-remove')) {
    return removeElement(node);
  }
  // Handling elements that are ignored by user tags -> End
  const ignore = hasAttr(node, 'data-skeleton-ignore') || node.tagName === 'STYLE';
  if (ignore) return;
  // Preprocessing some styles
  handler.before(node, this.options);
  // Preprocessing pseudo-class style
  handler.pseudo(node, this.options);
  const tagName = node.tagName && node.tagName.toUpperCase();
  const isBtn = tagName && (tagName === 'BUTTON' || /(btn)|(button)/g.test(node.getAttribute('class')));
  let isCompleted = false;
  switch (tagName) {
    case 'SCRIPT':
      handler.script(node);
      break;
    case 'IMG':
      handler.img(node);
      break;
    case 'SVG':
      handler.svg(node);
      break;
    case 'INPUT':
      handler.input(node);
      break;
    case 'BUTTON': // Button processing ends once
      handler.button(node);
      break;
    case 'UL':
    case 'OL':
    case 'DL':
      handler.list(node, this.options);
      break;
    case 'A': // A label processing is placed behind to prevent IMG from displaying an exception
      handler.a(node);
      break;
    default:
      break;
  }
  if (isBtn) {
    handler.button(node);
  } else {
    isCompleted = this.handleText(node);
  }
  // If it is a button and has not been processed by handleText, then the child node is processed
  if (!isBtn && !isCompleted) {
    this.handleNodes(node.childNodes); // 递归处理
  }
}</code></pre>
<h3 id="3-2-6-使用-rollup-打包脚本"><a href="#3-2-6-使用-rollup-打包脚本" class="headerlink" title="3.2.6 使用 rollup 打包脚本"></a>3.2.6 使用 rollup 打包脚本</h3><p>由于对页面节点处理的脚本使用 es6 语法编写， 我们需要在插入页面之前，进行编译：</p>
<pre><code class="javascript">// rollup.config.js
export default {
  input: 'src/script/main.js',
  output: {
    file: 'src/script/dist/index.js',
    format: 'iife',
    name: 'AwesomeSkeleton',
  },
};
</code></pre>
<p><strong>3.3 生成骨架屏代码</strong></p>
<p>生成处理页面节点脚本之后，插入到页面中，这个时候需要一些钩子来执行页面DOM的处理。我们定义一个全局对象 AwesomeSkeleton，其中包含 genSkeleton 方法，调用后会处理页面节点。</p>
<pre><code class="javascript">window.AwesomeSkeleton = {
  // Entry function
  async genSkeleton(options) {
    this.options = options;
    if (options.debug) {
      await this.debugGenSkeleton(options);
    } else {
      await this.startGenSkeleton(); // 生成骨架屏
    }
  },
  // Start generating the skeleton
  async startGenSkeleton() {
    this.init();
    try {
      this.handleNode(document.body);
    } catch (e) {
      console.log('==genSkeleton Error==\n', e.message, e.stack);
    }
  },
  ...
}</code></pre>
<p>在使用 puppeteer 打开页面之后，我们注入了 rollup 打包后的脚本，这时候我们需要执行脚本才能生成骨架屏：</p>
<pre><code class="javascript">await page.evaluate(async options => {
  await window.AwesomeSkeleton.genSkeleton(options);
}, options);</code></pre>
<p>生成骨架屏后，我们通过调用 puppeteer 的截图接口，生成骨架屏图片，并使用 images 包进行图片压缩，生成 base64，从而生成骨架屏代码。</p>
<pre><code class="javascript">// First screen skeleton screenshot
await page.screenshot({
  path: screenshotPath,
});
const imgWidth = options.device ? 375 : 1920;
// Use images for image compression
await images(screenshotPath).size(imgWidth).save(screenshotPath);
const skeletonImageBase64 = base64Img.base64Sync(screenshotPath);
// Inject the skeleton into the desired page
const result = insertSkeleton(skeletonImageBase64, options);</code></pre>
<p><strong>4. 使用 awesome-skeleton</strong></p>
<p>通过上述讨论的技术方案，我们实现了 awesome-skeleton 骨架屏生成工具。支持命令行生成骨架屏代码，同时也可以非常方便的在第三方平台接入。</p>
<h2 id="4-1-参数配置"><a href="#4-1-参数配置" class="headerlink" title="4.1 参数配置"></a>4.1 参数配置</h2><table>
<thead>
<tr>
<th>参数名称</th>
<th>必填</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>pageUrl</td>
<td>是</td>
<td>-</td>
<td>页面地址（此地址必须可访问）</td>
</tr>
<tr>
<td>pageName</td>
<td>否</td>
<td>output</td>
<td>页面名称（仅限英文）</td>
</tr>
<tr>
<td>cookies</td>
<td>否</td>
<td></td>
<td>页面 Cookies，用来解决登录态问题</td>
</tr>
<tr>
<td>outputPath</td>
<td>否</td>
<td>skeleton-output</td>
<td>骨架图文件输出文件夹路径，默认到项目 skeleton-output 中</td>
</tr>
<tr>
<td>openRepeatList</td>
<td>否</td>
<td>true</td>
<td>默认会将每个列表的第一项进行复制</td>
</tr>
<tr>
<td>device</td>
<td>否</td>
<td>PC</td>
<td>参考 puppeteer/DeviceDescriptors.js，可以设置为 ‘iPhone 6 Plus’</td>
</tr>
<tr>
<td>debug</td>
<td>否</td>
<td>false</td>
<td>是否开启调试开关</td>
</tr>
<tr>
<td>debugTime</td>
<td>否</td>
<td>0</td>
<td>调试模式下，页面停留在骨架图的时间</td>
</tr>
<tr>
<td>minGrayBlockWidth</td>
<td>否</td>
<td>0</td>
<td>最小处理灰色块的宽度</td>
</tr>
<tr>
<td>minGrayPseudoWidth</td>
<td>否</td>
<td>0</td>
<td>最小处理伪类宽</td>
</tr>
</tbody></table>
<p>例如添加 skeleton.config.json，生成考拉首页在 iphone X 下的骨架屏。</p>
<pre><code class="json">{
  "pageName": "baidu",
  "pageUrl": "https://www.kaola.com",
  "openRepeatList": false,
  "device": "iPhone X",
  "minGrayBlockWidth": 80,
  "minGrayPseudoWidth": 10,
  "debug": true,
  "debugTime": 3000
}
</code></pre>
<h2 id="4-2-一键生成骨架屏"><a href="#4-2-一键生成骨架屏" class="headerlink" title="4.2 一键生成骨架屏"></a>4.2 一键生成骨架屏</h2><pre><code class="javascript">skeleton -c ./skeleton.config.json</code></pre>
<p>页面 DomReady 之后，会在页面顶部出现红色按钮：开始生成骨架屏。</p>
<p>生成完成后，会在运行目录生成 skeleton-output 文件件，里面包括骨架屏 png 图片、base64 文本、html 文件：</p>
<ul>
<li>base64-baidu.png # 骨架图图片</li>
<li>base64-baidu.txt # 骨架图 Base64 编码</li>
<li>base64-baidu.html # 最终生成 HTML</li>
</ul>
<p>其中 html 文件可以直接拿来用，复制下面位置：</p>
<pre><code class="html">
  
    <!--- 骨架屏代码 -->
  
</code></pre>
<p>注意：</p>
<ul>
<li>骨架图默认在 onload 事件后销毁。</li>
<li>手动销毁方式：<code>javascript window.SKELETON && SKELETON.destroy();</code> 当然，你也可以在项目中直接使用生成的 Base64 图片。</li>
</ul>
<h2 id="4-3-解决登录问题"><a href="#4-3-解决登录问题" class="headerlink" title="4.3 解决登录问题"></a>4.3 解决登录问题</h2><p>如果页面需要登录，则需要下载 Chrome 插件 EditThisCookie，将 Cookie 复制到配置参数中。Puppeteer 通过在打开页面的时候注入 Cookie 从而模拟登录态：</p>
<pre><code class="javascript">// Write cookies to solve the login status problem
if (options.cookies && options.cookies.length) {
  await page.setCookie(...options.cookies);
  await page.cookies(options.pageUrl);
  await sleep(1000);
}</code></pre>
<h2 id="4-4-DOM-节点配置"><a href="#4-4-DOM-节点配置" class="headerlink" title="4.4 DOM 节点配置"></a>4.4 DOM 节点配置</h2><p>这是获取优质骨架图的要点，通过设置以下几个 dom 节点属性，在骨架图中对某些节点进行移除、忽略和指定背景色的操作，去除冗余节点的干扰，从而使得骨架图效果达到最佳。</p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>data-skeleton-remove</td>
<td>指定进行移除的 dom 节点属性</td>
</tr>
<tr>
<td>data-skeleton-bgcolor</td>
<td>指定在某 dom 节点中添加的背景色</td>
</tr>
<tr>
<td>data-skeleton-ignore</td>
<td>指定忽略不进行任何处理的 dom 节点属性</td>
</tr>
<tr>
<td>data-skeleton-empty</td>
<td>将某dom的innerHTML置为空字符串</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code><div data-skeleton-remove>
    <span>abc</span>
</div>
<div data-skeleton-bgcolor="#EE00EE">
    <span>abc</span>
</div>
<div data-skeleton-ignore>
    <span>abc</span>
</div>
<div data-skeleton-empty>
    <span>abc</span>
</div></code></pre><h1 id="5-开发骨架屏生成平台"><a href="#5-开发骨架屏生成平台" class="headerlink" title="5. 开发骨架屏生成平台"></a>5. 开发骨架屏生成平台</h1><p>有了骨架屏生成工具，我们可以非常方便的接入第三方平台，例如我们使用 egg.js 开发骨架屏生成平台，用户输入页面链接，自动生成对应骨架屏。关键代码：</p>
<pre><code class="javascript">const getSkeleton = require('awesome-skeleton');
class SkeletonService extends Service {
  async generator(params) {
    try {
      const result = await getSkeleton(params);
      return {
        success: true,
        ...result,
      };
    } catch (e) {
            ...
    }
  }
}

</code></pre>
<p>页面效果：</p>
<p><a href="./4.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./4.jpg" class="lazyload"></a></p>
<p>骨架屏配置：</p>
<p><a href="./5.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./5.jpg" class="lazyload"></a></p>
<h1 id="6-参与贡献"><a href="#6-参与贡献" class="headerlink" title="6. 参与贡献"></a>6. 参与贡献</h1><p>Github：<a href="https://github.com/kaola-fed/awesome-skeleton" target="_blank" rel="noopener">https://github.com/kaola-fed/awesome-skeleton</a></p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>骨架屏</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>重go吧!</title>
    <url>/2020/03/22/Java-Standard-Restructure/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h1><p>重构不止是代码整理，它提供了一种高效且受控的代码整理技术。</p>
<h2 id="（一）重构原则"><a href="#（一）重构原则" class="headerlink" title="（一）重构原则"></a>（一）重构原则</h2><h3 id="1、何谓重构"><a href="#1、何谓重构" class="headerlink" title="1、何谓重构"></a>1、何谓重构</h3><p>对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</p>
<p>另一种解释是：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</p>
<h3 id="2、为何重构"><a href="#2、为何重构" class="headerlink" title="2、为何重构"></a>2、为何重构</h3><p>改进软件设计：如果没有重构，程序的设计会逐渐变质，重构很像是在整理代码，你所做的就是让所有的东西回到应处的位置上。<br>帮助找到bug：对代码进行重构，可以深入理解代码的作为，在搞清楚程序结构的同时，想不把bug揪出来都难。<br>提高编程速度：良好的设计是快速开发的根本，改善设计、提高可读性，减少错误，这些都是提高质量。</p>
<h3 id="3、何时重构"><a href="#3、何时重构" class="headerlink" title="3、何时重构"></a>3、何时重构</h3><p>任何情况下我都反对专门拨出时间进行重构。重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地的进行。</p>
<ul>
<li>三次法则</li>
</ul>
<p>第一次做某件事情是只管去做；第二次做类似的事情会产生反感；第三次再做类似的事，你就应该重构</p>
<p>最常见的重构时机是想给软件添加新特性的时候；</p>
<p>重构的另个一原动力是：代码的设计无法帮助我轻松的添加所需要的特性</p>
<p>修改错误的时候，review代码的时重构</p>
<ul>
<li>间接层和重构</li>
</ul>
<p>计算机科学是这样一门科学：它相信所有的问题都可以通过增加一个间接层来解决。</p>
<p>大多数重构都为程序引入了更多的间接层，重构往往把大型的对象拆成多个小型的对象，把大型的函数拆成多个小型的函数。但是，间接层是一把双刃剑。每次把一个东西分成两份，你就需要多管理一个东西。如果某个对象委托另一个对象，后者又委托另一个对象，程序会愈加难以阅读。</p>
<p>何时不该重构：有时候既有代码实在太混乱，重构它还不如重新写一个来得简单。</p>
<p>重写而非重构的一个清楚讯号是：现有代码根本不能正常运作。</p>
<h2 id="（二）代码的坏味道"><a href="#（二）代码的坏味道" class="headerlink" title="（二）代码的坏味道"></a>（二）代码的坏味道</h2><ul>
<li>1、重复代码</li>
</ul>
<p>如果你在一个以上的地点看到相同的程序结构，那么可以肯定：设法将它们合二为一，程序会变得更好 。</p>
<p>同一个类中有相同的表达式：提炼出重复的代码，然后让两个地方都调用被提炼出来的那一段代码；</p>
<p>两个互为兄弟的子类内含有相同的表达式：提炼出相同代码，将它推入超类内；</p>
<p>两个毫不相干的类中出现：将重复的代码提炼到一个独立的类中。</p>
<ul>
<li>2、过长的类</li>
</ul>
<p>拥有短函数的对象活得比较好、比较长。间接层所能带来的全部利益——解释能力、共享能力、选择能力——都是由小型函数支持的。</p>
<p>每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立的函数中。</p>
<p>如何确定提炼哪一段代码？寻找注释是一个很好的技巧。它们通常能指出代码用途和实现手法之间的语义距离。如果代码前方有一行注释，就是提醒你：可以将这段代码替换成一个函数。</p>
<p>条件表达式和循环常常也是提炼的信号。</p>
<ul>
<li>3、过大的类</li>
</ul>
<p>如果想利用单个类做太多的事情，其内往往就会出现太多实力变量。<br>类内如果有太多代码，也是代码重复、混乱病最终走向死亡的源头。</p>
<ul>
<li>4、过长参数列</li>
</ul>
<p>太长的参数列难以理解，太多的参数会造成前后不一致、不容易使用，而且一旦你需要更多数据，就不得不修改它。如果将对象传递给函数，大多数修改都将没有必要。</p>
<ul>
<li>5、发散式变化</li>
</ul>
<p>如果某个类经常因为不同的原因在不同的方向上发生变化，那么此时也许将这个对象分成两个会更好，这么一来每个对象就可以只因为一种变化而需要修改。</p>
<ul>
<li>6、散弹式修改</li>
</ul>
<p>如果没遇到某种变化，你都必须在许多不同的类内做出许多小修改，你所面临的坏味道就是散弹式修改。如果需要修改的代码散布四处，你不但很难找到它们，也很容易忘记某个重要的修改。</p>
<p>把所有需要修改的代码放进同一个类中，如果眼下没有合适的类可以安置这些代码就创造一个。</p>
<ul>
<li>7、依恋情结</li>
</ul>
<p>对象技术的要点在于：将数据和对数据的操作行为包装在一起.有一种经典的气味是：函数对某个类的兴趣高过对自己所处类的兴趣。某个函数为了计算某个值，从另一个对象那调用几乎半打的取值函数。</p>
<p>一个函数往往会用到几个类的功能，那么它该置于何处？我们的原则是：判断哪个类拥有最大被此函数使用的数据，然后就把这个函数和那些数据放在一起。</p>
<ul>
<li>8、数据泥团</li>
</ul>
<p>很多地方看到相同的三四项数据一起出现。这些总是绑在一起出现的数据应该拥有属于他们自己的对象。</p>
<p>首先找到这些数据以字段形式出现的地方，将它们提炼到一个独立的对象中。这么做的直接好处是可以将很多参数列缩短简化函数调用。</p>
<ul>
<li>9、基本类型偏执</li>
</ul>
<p>对象的一个极大价值在于：它们模糊了横旦与基本数据和体积较大的类之间的界限</p>
<p>对象技术的新手通常不愿意在小任务上运用小对象——结合数值和比重的money类、有一个起始值和一个结束值组成的range类。将原本单独存在的数值替换成对象，从而走出传统的洞窟，进入炙手可热的对象世界。</p>
<ul>
<li>10、switch惊悚现身</li>
</ul>
<p>面向对象的一个最明显的特征是：少用switch语句一看到switch语句，就应该考虑以多态来替换它。</p>
<p>如果只是在单一函数中有些选择实例，且并不想改动它们，那么多态就有点杀鸡用牛刀了。</p>
<ul>
<li>11、平行集成体系</li>
</ul>
<p>每当你为某个类增加一个子类，必须也为另一个类相应增加一个子类。<br>消除这种重复性的一般策略是：让一个继承体系的实例引用另一个继承体系的实例。</p>
<ul>
<li>12、冗余类</li>
</ul>
<p>某个类原本对得起自己的身价，但重构使它身形缩水，不再做那么多工作，这个时候请让这个类庄严赴义吧。</p>
<ul>
<li>13、夸夸其谈未来性</li>
</ul>
<p>企图以各种各样的钩子和特殊情况来处理一些非必要的事情，这种怀味道就出现了。如果用到了那就值得去做，如果用不到那就不值得，只会挡你的路，所以把它挪开吧。</p>
<p>如果你的某个抽象类其实没有起到太大的作用，函数上的某些参数未被使用…可以移除它们了。</p>
<ul>
<li>14、令人迷惑的暂时字段</li>
</ul>
<p>某个实例变量仅为某种特定的情况而设。这样的代码让人不易理解。在变量未被使用的情况下猜测当初其设置目的，会让你发疯的。</p>
<ul>
<li>15、过度耦合消息链</li>
</ul>
<p>如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另个一对象……..这就是消息链。采用这种方式，意味着客户代码将与查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应的修改。</p>
<ul>
<li>16、中间人</li>
</ul>
<p>封装往往伴随着委托。你也许会看到某个类接口有一半的函数都委托给其他类，这样就是过度运用。</p>
<ul>
<li>17、狎昵关系</li>
</ul>
<p>有时会看到两个类过于亲密，话费太多的时间去探究彼此的private成分。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。<br>继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。如果你觉得该让孩子独立生活了，让他离开继承。</p>
<ul>
<li>18、异曲同工的类</li>
</ul>
<p>两个函数做同一件事，却有着不同的签名。</p>
<ul>
<li>19、不完美的类库</li>
</ul>
<p>类库函数构造的不够好，又不能修改它们：</p>
<p>如果只想修改类的一两个函数，可以引入外加函数。如果想要添加一大堆额外行为，建立一个新类包含这些额外行为，让其成为子类。</p>
<ul>
<li>20、纯稚的数据类</li>
</ul>
<p>纯稚的数据类是指：它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。</p>
<p>封装public字段;<br>恰当封装容器类字段;<br>移除不应修改的字段的设置函数;<br>提炼调用函数以隐藏取值/设值函数;</p>
<ul>
<li>21、被拒绝的遗赠</li>
</ul>
<p>子类只运用了父类的一部分函数和数据。为子类建立一个兄弟类,将所有用不到的字段/函数下移至兄弟类,保证超类的纯粹;</p>
<ul>
<li>22、过多的注释</li>
</ul>
<p>注释之所以存在是因为代码很糟糕 。注释的最高境界——代码即注释。</p>
<p>当你感觉需要撰写注释时，请先尝试重构，试着让所有的注释都变得多余。</p>
<h2 id="（三）重新组织函数"><a href="#（三）重新组织函数" class="headerlink" title="（三）重新组织函数"></a>（三）重新组织函数</h2><ul>
<li>1、提炼函数</li>
</ul>
<p>动机：看到一个过长的函数或者一段需要注释才能让人理解用途的代码，将这段代码放一个独立的函数中；<br>做法：</p>
<p>创造一个新函数，根据这个函数的意图来命名它；</p>
<p>只要新函数的名称能够以更好的方式昭示代码意图，你也应该提炼它。但如果想不到一个更有意义的名称就别动</p>
<p>将提炼的代码从原函数复制到新建的目标函数中；<br>将被提炼代码段中需要读取的局部变量，当作参数传递给目标函数；<br>在源函数中，将被提炼代码段替换为目标函数调用。</p>
<ul>
<li>2、内联函数</li>
</ul>
<p>一个函数的本体与名称同样清楚易懂。在函数调用点插入函数本体，然后移除该函数。<br>动机：</p>
<p>一群组织不甚合理的函数。你可以将它们都内联到一个大函数中，再从中提炼出组织合理的小型函数。<br>使用的太多的间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在委托动作之间晕头转向。</p>
<blockquote>
<p>做法：<br>1、检查函数，确定不具备多态；<br>如果子类继承了这个函数，就不要将此函数内联，因为子类无法复写一个根本不存在的函数。<br>2、找出这个函数的所有调用点；<br>3、将这个函数的所有调用点都替换成函数本体。</p>
</blockquote>
<ul>
<li>3、内联临时变量</li>
</ul>
<p>有一个临时变量，只被一个简单的表达是赋值一次，而它妨碍了其他重构手法。将所有对该变量的引用动作，替换为对它赋值的那个表达式自身</p>
<pre><code>double basePrice = anOrder.basePrice();
return (base > 10000 );</code></pre><p>替换为：</p>
<pre><code>return (anOrder.basePrice > 1000);
</code></pre><ul>
<li>4、以查询取代临时变量</li>
</ul>
<p>你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立的函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。</p>
<pre><code>double basePrice = quantity * timePrice;
if(basePrice > 1000){
   return basePrice * 09.5;
} else {
   return basePrice * 0.98;
}</code></pre><p>替换为：</p>
<pre><code>if(basePrice() > 1000){
   return basePrice * 09.5;
} else {
   return basePrice * 0.98;
}
double basePrice(){
   return quantity * timePrice;
}</code></pre><p>临时变量只在所属的函数中可见，如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这个份信息，这将带给你极大的帮助，使你能够为这个类编写更清晰的代码。</p>
<ul>
<li>5、引入注释性变量</li>
</ul>
<p>你有一个复杂的表达式。将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途。</p>
<pre><code>if ((platform.toUpperCase().indexOf("MAC") > -1) && (browser.toUpperCase().indexOf("IE") > -1) && wasInitialized() && resize >0){
   //do smothing
}</code></pre><p>替换为：</p>
<pre><code>final boolean isMacOs = platform.toUpperCase().indexOf("MAC") > -1;
final boolean isIEBrowser = browser.toUpperCase().indexOf("IE") > -1;
final boolean wasResized = resize >0;
if(isMacOs && isIEBrowser && wasInitialized() && wasResized){
   //do smothing
}</code></pre><p>表达式有可能非常复杂难以理解。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。</p>
<p>在条件逻辑中，你可以用这项重构将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义。另一种情况是：在较长的算法中，可以运用临时变量来解释每一步运算的意义。</p>
<ul>
<li>6、分解临时变量</li>
</ul>
<p>你的程序有某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。针对每次赋值，创造一个独立、对应的临时变量。</p>
<pre><code>double temp = 2 * (height + width);
System.out.println(temp);
temp = height * width;
System.out.println(temp);</code></pre><p>替换为：</p>
<pre><code>double perimeter = 2 * (height + width);
System.out.println(perimeter);
double area = height * width;
System.out.println(area);</code></pre><p>如果临时变量被赋值超过一次，就意味着它们在函数中承担了一个以上的责任。如果临时变量承担多个责任，它就应该被替换为多个临时变量。每个变量只承担一个责任，同一个临时变量承担两件不同的事情会令代码阅读者糊涂</p>
<ul>
<li>7、移除对参数的赋值</li>
</ul>
<p>代码对一个参数进行复制。以一个临时变量取代该参数的位置。</p>
<pre><code>int discount (int inputVal, int quantity, int yearToData){
   if(inputVal > 50) inputVal -= 2;
}</code></pre><p>替换为：</p>
<pre><code>int discount (int inputVal, int quantity, int yearToData){
   int result = inputVal;
   if(inputVal > 50) result -= 2;
}</code></pre><p>如果代码的语义是按引用传递的，请在调用段检查调用后是否还使用了这个参数。</p>
<ul>
<li>8、替换算法</li>
</ul>
<p>想要把某个算法替换为另一个更清晰的算法。将函数本体替换成为另一个算法。</p>
<pre><code>String foundPerson(String[] people){
   for(int i = 0;i < people.length; i++){
       if(people[i].equals("Don")){
           return "Don";
       }
       if(people[i].equals("John")){
           return "John";
       }
       if(people[i].equals("Kent")){
           return "Kent";
       }
   }
   return "";
}</code></pre><p>替换为：</p>
<pre><code>String foundPerson(String[] people){
   List candidates = Arrays.asList(new String[]{"Don", "John", "Kent"});
   for(int i = 0;i < people.length; i++){
       if(candidates.contains(people[i])){
           return prople[i];
       }
   }
   return "";
}</code></pre><h2 id="（四）在对象之间搬移特性"><a href="#（四）在对象之间搬移特性" class="headerlink" title="（四）在对象之间搬移特性"></a>（四）在对象之间搬移特性</h2><p>在对象设计过程中，决定把责任放在哪儿是即使不是最重要的事，也是最重要的事之一。</p>
<p>常常只使用搬移函数和搬移字段简单地移动对象行为，就可以解决这些问题。如果这两个重构手法都需要用到，我会首先使用搬移字段，再使用搬移方法。</p>
<p>如果一个类承担了太多责任而变得臃肿不堪，这种情况下会使用提炼类将一部分责任分离出去。如果一个类变得太不负责任，使用将类内联化将它融入到另一个类中。</p>
<ul>
<li>1、搬移函数</li>
</ul>
<p>你的程序中，有个函数与其所驻类之外的另个一类进行跟过的交流：调用后者或被后者调用。在该函数最长引用的类中建立一个有着类似行为的新函数。将旧函数变成一个单纯的委托函数，或者将旧函数完全移除。<br>如果一个类有太多行为，或如果一个类与另一个类有太多合作而高度耦合，就需要搬移函数。可以是系统中的类更简单</p>
<ul>
<li>2、搬移字段</li>
</ul>
<p>程序中，某个字段被其所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改原字段的所有用户，令他们改用新字段</p>
<ul>
<li>3、提炼类</li>
</ul>
<p>某个类做了应该由两个类做的事。建立一个新类，将相关字段和函数从就类搬到新类。</p>
<ul>
<li>4、将类内联化</li>
</ul>
<p>某个类没有做太多的事情，不在承担足够责任，不再有的那单独存在的理由。将这个类的所有特性搬移到另一个类中，然后移除原类。</p>
<ul>
<li>5、隐藏“委托关系”</li>
</ul>
<p>客户通过一个委托类来调用另一个对象。在服务类上建立客户所需要的所有函数，用来隐藏委托关系。</p>
<p>封装意味每个对象都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的对象就会比较少。</p>
<p>如果某个客户先通过服务对象的字段得到另一个对象，然后调用后者的函数。那么客户就必须知晓这一层委托关系。万一委托关系变化，客户也要相应变化。</p>
<ul>
<li>6、移除中间人</li>
</ul>
<p>某个类做了过多的简单委托。让客户直接调用委托类。<br>每当客户要使用手委托类的新特性时，你就必须在服务端添加一个简单委托函数。随着受委托类的特性越来越多，这一过程会让你很痛苦。</p>
<ul>
<li>7、引入外加函数</li>
</ul>
<p>你需要为提供服务的类增加一个函数，但你无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例。</p>
<pre><code>Date newStart = new Date(year, month, date + 1);</code></pre><p>替换为：</p>
<pre><code>Date newStart = nextDay(nowDate);
private static Date nextDay(Date arg){
   retrun new Date(arg.getYear(), arg.getMonth(), arg.getDate() + 1);
}</code></pre><p>如果可以修改源码，你可以自行添加一个新函数；如果不能，你就得在客户端编码，补足你要的那个函数</p>
<ul>
<li>8、引入本地扩展</li>
</ul>
<p>你需要为服务类踢狗一些额外函数，但你无法修改这个类。建立一个新类，使它包含这些额外函数。让这个扩展品成为源类的子类或包装类。</p>
<h2 id="（五）重新组织数据"><a href="#（五）重新组织数据" class="headerlink" title="（五）重新组织数据"></a>（五）重新组织数据</h2><ul>
<li>1、自封装字段</li>
</ul>
<p>直接访问一个字段。为这个字段建立取值/设值函数，并且只以这些函数来访问字段。</p>
<pre><code>private int low, high;
boolean includes(int arg){
   retrun arg >= low && arg <= high;
}</code></pre><p>替换为：</p>
<pre><code>private int low, high;
boolean includes(int arg){
   retrun arg >= getLow() && arg <= getHigh();
}
int getLow(){
   retrun low;
}
int getHigh(){
   return high;
}</code></pre><p>在“字段访问方式”这个问题上，存在两种截然不同的观点：</p>
<p>在该变量定义所在的类中，你可以自由的访问。<br>即使在这个类中你也应该只使用访问函数间接访问。<br>*间接访问的好处是：子类可以通过复写一个函数而改变获取数据的途径；它支持更灵活的数据管理方式，例如延迟初始化。</p>
<ul>
<li>2、以对象取代数据值</li>
</ul>
<p>你有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象。</p>
<p>一开始你肯能会用一个字符串来表示“电话号码”概念，但是随后你会发现，电话号码需要“格式化”、“区号”之类的行为。这时候就需要为带替换的数值新建一个类。</p>
<ul>
<li>3、将值对象改为引用对象</li>
</ul>
<p>你从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象。将这个值对象变成引用对象。</p>
<ul>
<li>4、将引用对象改为值对象</li>
</ul>
<p>你有一个引用对象，很小且不可改变，而且不易管理。将它变成一个值对象。</p>
<ul>
<li>5、以对象取代数组</li>
</ul>
<p>你有一个数组，其中的元素各自代表不同的东西。以对象替换数组。对于数组中的每个元素，以一个字段来表示</p>
<ul>
<li>6、复制“被监视数据”</li>
</ul>
<p>你有一些领域数据置身GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中。建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据。</p>
<ul>
<li>7、将单向关联改为双向关联</li>
</ul>
<p>两个类都需要使用对方特性，但其间只有一条单向连接。添加一个反向指针，并使修改函数能够同时更新两条连接。</p>
<ul>
<li>8、将双向关联改为单向关联</li>
</ul>
<p>两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性。去除不必要的关联。</p>
<ul>
<li>9、以字面常量取代魔数</li>
</ul>
<p>你有一个字面数值，带有特别含义。创造一个常量，根据其意义为它命名，并将上述的字面数值替换为常量。</p>
<ul>
<li>10、封装字段</li>
</ul>
<p>你的类中存在一个public字段。将它声明为private，并提供相应的访问函数。</p>
<ul>
<li>11、封装集合</li>
</ul>
<p>有个函数返回一个集合。让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数。</p>
<h2 id="（六）简化条件表达式"><a href="#（六）简化条件表达式" class="headerlink" title="（六）简化条件表达式"></a>（六）简化条件表达式</h2><ul>
<li>1、分解条件表达式</li>
</ul>
<p>有一复杂的条件语句。从if、then、else三个段落中分别提炼出独立函数。</p>
<ul>
<li>2、合并表达式</li>
</ul>
<p>你有一系列条件测试，都得到相同结果。将这些测试合并为一个条件表达式，并将这个条件表达式提炼成一个独立函数。</p>
<ul>
<li>3、合并重复的条件代码</li>
</ul>
<p>在表达式的每个分支上都执行了相同的一段代码。将这段重复代码搬移到条件表达式之外。</p>
<ul>
<li>4、移除控制标记</li>
</ul>
<p>在一系列布尔表达式中,某个变量带有”控制标记”的作用。以break/return语句取代控制标记。</p>
<ul>
<li>5、以多态取代条件表达式</li>
</ul>
<p>有个条件表达式根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</p>
<h2 id="（七）简化函数调用"><a href="#（七）简化函数调用" class="headerlink" title="（七）简化函数调用"></a>（七）简化函数调用</h2><ul>
<li>1、函数改名</li>
</ul>
<p>函数的名称未能揭示其用途。修改函数名称。</p>
<ul>
<li>2、添加参数</li>
</ul>
<p>某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带仅函数所需信息。</p>
<ul>
<li>3、移除参数</li>
</ul>
<p>函数本体不再需要某个参数。去除参数。</p>
<ul>
<li>4、分离查询函数和修改函数</li>
</ul>
<p>某个函数既返回对象状态值，又修改对象值。建立两个不同函数,其中一个负责查询,另一个负责修改。</p>
<ul>
<li>5、令函数携带参数</li>
</ul>
<p>若干函数做了类似的工作，但在函数本体中包含了不同的值。建立单一函数,以参数表达那些不同的值。<br>有这样两个函数：它们做着类似的工作，但因少数几个值致使行为略有不同。在这种情况下，你可以将这些各自分离的函数同一起来，并通过参数来处理那些变化情况，用以简化问题。</p>
<ul>
<li>6、以明确函数取代参数</li>
</ul>
<p>你有一个函数，其中完全取决于参数值而采用不同行为。针对该参数的每一个可能值，建立一个独立函数。<br>如果某个参数有多种可能的值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，那么就应该使用本项重构。</p>
<ul>
<li>7、保持对象完整</li>
</ul>
<p>从某个对象中取出若干值，将它们作为某一次函数调用时的参数。改为传递整个对象。</p>
<ul>
<li>8、以函数取代参数</li>
</ul>
<p>对象调用某个函数，并将所得结果作为参数，传递给另一函数，而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该参数，直接调用前一个函数。</p>
<ul>
<li>9、引入参数对象</li>
</ul>
<p>某些参数总是很自然的同时出现。以一个对象取代这些参数。</p>
<ul>
<li>10、移除设值函数</li>
</ul>
<p>类中某个字段在对象创建时被设值，然后不再改变。去掉该字段的所有设值函数。</p>
<ul>
<li>11、隐藏函数</li>
</ul>
<p>某个函数，从来没有被其他任何类用到 。将函数修改为private。</p>
<ul>
<li>12 、以工厂函数取代构造函数</li>
</ul>
<p>希望在创建对象时不仅仅是做简单的建构动作 。将构造函数替换为工厂函数。</p>
<h2 id="（八）处理概括关系"><a href="#（八）处理概括关系" class="headerlink" title="（八）处理概括关系"></a>（八）处理概括关系</h2><ul>
<li>1、字段上移</li>
</ul>
<p>两个子类拥有相同的字段。将该字段移至超类。</p>
<ul>
<li>2 、函数上移</li>
</ul>
<p>有些函数在各子类中产生完全相同的结果。将该函数移至超类。</p>
<ul>
<li>3 、构造函数本体上移</li>
</ul>
<p>各个子类中有一些构造函数本体几乎完全一致 。在超类中新建一个构造函数，并在子类构造函数中调用它。</p>
<ul>
<li>4、函数下移</li>
</ul>
<p>超类中的某个函数只与部分(而非全部)子类用到。将函数移到相关的子类中。</p>
<ul>
<li>5、字段下移</li>
</ul>
<p>超类中的某个字段只被部分(而非全部)子类用到。将字段移到需要它的子类中。</p>
<ul>
<li>6、提炼子类</li>
</ul>
<p>类中的某些特性只被某些(而非全部)实例用到。新建一个子类，将上述部分的特性移到子类中。</p>
<ul>
<li>7、提炼超类</li>
</ul>
<p>两个类有相似特性。为这两个类建立一个超类,将相同特性移至超类。</p>
<ul>
<li>8、提炼接口</li>
</ul>
<p>若干客户使用类接口中的同一子集，或两个类的接口有部分相同。将相同的子集提炼到一个独立接口中。</p>
<ul>
<li>9、折叠继承体系</li>
</ul>
<p>超类和子类之间无太大区别。将它们合为一体。</p>
<ul>
<li>10、塑造模板函数</li>
</ul>
<p>子类中某些函数以相同顺序执行类似操作，但各操作细节略有不同。将操作放进独立函数(保持签名相同)，然后将它们移至超类。</p>
<ul>
<li>11、以委托取代继承</li>
</ul>
<p>某个子类只使用超类接口中的一部分或根本不需要继承而来的数据。子类新建字段保存超类，调整子类函数为委托超类，取消继承关系。</p>
<ul>
<li>12、以继承取代委托</li>
</ul>
<p>你在两个类中使用委托关系，并经常为整个接口编写许多极简单的委托函数。`让委托类继承受托类。</p>
</body></html>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>代码</tag>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（一）</title>
    <url>/2020/04/03/Nest-Dev-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-6-x-快速指南"><a href="#Nest-6-x-快速指南" class="headerlink" title="Nest 6.x 快速指南"></a>Nest 6.x 快速指南</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>Nest 是一个用于构建高效，可扩展的 <a href="http://nodejs.cn/" target="_blank" rel="noopener">Node.js</a> 服务器端应用程序的框架。它使用渐进式 JavaScript，内置并完全支持 <a href="https://www.tslang.cn/" target="_blank" rel="noopener">TypeScript</a>，结合了 OOP（面向对象编程），FP（函数式编程）和 FRP（函数式响应编程）的元素。</p>
<h2 id="2、特征"><a href="#2、特征" class="headerlink" title="2、特征"></a>2、特征</h2><p>模块、控制器、组件</p>
<ul>
<li>框架</li>
</ul>
<p>Nest是一个渐进的Node.js框架，可以在TypeScript和JavaScript (ES6、ES7、ES8)之上构建高效、可伸缩的企业级服务器端应用程序。</p>
<ul>
<li>哲学</li>
</ul>
<p>Nest 提供了一个开箱即用的应用程序架构，允许开发人员和团队创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</p>
<ul>
<li>平台无关</li>
</ul>
<p>技术上讲，Nest 可以在创建适配器后使用任何 Node HTTP 框架。 有两个支持开箱即用的 HTTP 平台：express 和 fastify。 您可以选择最适合您需求的产品。</p>
<ul>
<li>理念</li>
</ul>
<p>在设计上的很多灵感来自于 Angular，Angular 的很多模式又来自于 Java 中的 Spring 框架，依赖注入、面向切面编程等，所以我们也可以认为： Nest 是 Node.js 版的 Spring 框架。</p>
<h2 id="3、NestJS和Egg-js-的一些简单对比"><a href="#3、NestJS和Egg-js-的一些简单对比" class="headerlink" title="3、NestJS和Egg.js 的一些简单对比"></a>3、NestJS和Egg.js <strong>的一些简单对比</strong></h2><blockquote>
<ol>
<li>Egg.js 是和 Nest.js 都是为企业级框架和应用而生。 </li>
<li>Egg.js 和 Nest.js 都是非常优秀的 Nodejs 框架。Egg.js 基于 Koa，Nest.js 默认基于 </li>
<li>Express，nest 也可以基于其他框架 </li>
<li>Egg.j<strong>s</strong> 文档相比 <strong>Nestjs</strong> 优秀很多 </li>
<li>Express、Koa 是 Node.js 社区广泛使用的框架，简单且扩展性强，非常适合做个 </li>
<li>人项目。但框架本身缺少约定，标准的 MVC 模型会有各种千奇百怪的写法。Egg 和 Nestjs </li>
<li>都是按照约定进行开发的。但是 Egg 相比 Nestjs 约定更标准。 </li>
<li>面向对象方面 Nestjs 优于 Egg.js，Nestjs 基于 TypeScript，如果你会 angular 或者 java </li>
<li>学习 Nestjs 非常容易。 </li>
</ol>
</blockquote>
<ul>
<li><p><strong>Egg.js</strong> <strong>的特性：</strong> </p>
<p>提供基于 Egg 定制上层框架的能力高度可扩展的插件机制 </p>
<p>内置多进程管理 </p>
<p>基于 Koa 开发，性能优异 </p>
<p>框架稳定，测试覆盖率高 </p>
<p>渐进式开发 </p>
</li>
</ul>
<p>  <strong>Nestjs</strong> <strong>的特性：</strong> </p>
<p>  依赖注入容器 </p>
<p>  模块化封装 </p>
<p>  可测试性 </p>
<p>  内置支持 TypeScript </p>
<p>  可基于 Express 或者 fastify</p>
<h2 id="3、创建项目"><a href="#3、创建项目" class="headerlink" title="3、创建项目"></a>3、创建项目</h2><p>首先，您可以使用 Nest CLI 构建项目，也可以克隆启动项目（两者都会产生相同的结果）。</p>
<p>要使用 Nest CLI 构建项目，请运行以下命令。这将创建一个新的项目目录，并生成 Nest 核心文件和支持模块，为您的项目创建传统的基础结构。建议初学者使用Nest CLI 创建新项目。我们将在<a href="https://www.bookstack.cn/read/nest-6/$6-firststeps?id=第一步" target="_blank" rel="noopener">第一步</a>继续使用这种方法。</p>
<ul>
<li><h4 id="使用-CLI-安装"><a href="#使用-CLI-安装" class="headerlink" title="使用 CLI 安装"></a>使用 CLI 安装</h4></li>
</ul>
<pre><code class="shell">$ npm i -g @nestjs/cli$ 
$ nest new project-name</code></pre>
<ul>
<li><h4 id="使用-Git-安装"><a href="#使用-Git-安装" class="headerlink" title="使用 Git 安装"></a><strong>使用 Git 安装</strong></h4></li>
</ul>
<pre><code class="shell">$ git clone https://github.com/nestjs/typescript-starter.git project
$ cd project
$ npm install
$ npm run start</code></pre>
<h2 id="4、常用命令"><a href="#4、常用命令" class="headerlink" title="4、常用命令"></a>4、常用命令</h2><p>基于nest-cli脚手架工具我们可以快速的创建项目所需要的组件，该命令与angulr-cli极其相似，大致命令如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nest  g  service   “路径/服务名称”</td>
<td>创建一个服务</td>
</tr>
<tr>
<td>nest  g  module   “路径/模块名称”</td>
<td>创建一个模块</td>
</tr>
<tr>
<td>nest  g  pip”路径/管道名称”</td>
<td>创建一个管道</td>
</tr>
<tr>
<td>nest  g  provider”路径/服务提供者名称”</td>
<td>创建一个服务提供者</td>
</tr>
<tr>
<td>nest  g  controller”路径/控制器名称”</td>
<td>创建一个控制器</td>
</tr>
<tr>
<td>···</td>
<td>···</td>
</tr>
</tbody></table>
<h2 id="5、工程解释"><a href="#5、工程解释" class="headerlink" title="5、工程解释"></a>5、工程解释</h2><blockquote>
<p>入口文件main.ts</p>
</blockquote>
<pre><code class="typescript">import { NestFactory } from '@nestjs/core';
import * as rateLimit from 'express-rate-limit';
import * as compression from 'compression';
import * as helmet from 'helmet';
import { TransformInterceptor } from './interceptors/transform.interceptor';
import { HttpExceptionFilter } from './filters/http-exception.filter';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express'
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
async function bootstrap() {
  const app = await NestFactory.create<nestexpressapplication>(AppModule);
  app.enableCors();
  app.setGlobalPrefix('/api'); //设置全局请求前置
  app.use(
    rateLimit({
      windowMs: 60 * 1000, // 1 minutes
      max: 1000, // limit each IP to 1000 requests per windowMs
    })
  );
  app.use(compression()); // 启用 gzip 压缩
  app.use(helmet());
  app.useGlobalInterceptors(new TransformInterceptor()); // 正常情况下，响应值统一
  app.useGlobalFilters(new HttpExceptionFilter()); // 异常情况下，响应值统一
  app.useStaticAssets('public') //配置静态资源访问地址
  // 配置swagger-ui接口文档
  const options = new DocumentBuilder()   //实例化swagger 文档
    .setTitle('网站后台管理系统与前端页面接口文档') //设置文档标题
    .setDescription('网站后台管理系统与前端页面接口文档') //设置文档描述
    .setVersion('1.0.0') //设置文档版本
    // .addTag('Next与Nest建站') //设置文档标签
    .build(); //执行构建
  const document = SwaggerModule.createDocument(app, options);
  SwaggerModule.setup('api-docs', app, document);   //设置本地访问地址
  await app.listen(4000);  //设置服务监听端口
}

bootstrap();</nestexpressapplication></code></pre>
<p>要创建一个 Nest 应用实例，我们使用了 <code>NestFactory</code> 核心类。<code>NestFactory</code> 暴露了一些静态方法用于创建应用实例。 <code>create()</code> 方法返回一个实现 <code>INestApplication</code> 接口的对象, 并提供一组可用的方法, 在后面的章节中将对此进行详细描述。 在上面的main.ts示例中，我们只是启动 HTTP 服务器，它允许应用程序等待入站 HTTP 请求。</p>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（三）</title>
    <url>/2020/04/03/Nest-Dev-03/</url>
    <content><![CDATA[<html lang="zh-CN"><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-指南（三）"><a href="#Nest-指南（三）" class="headerlink" title="Nest 指南（三）"></a>Nest 指南（三）</h1><h2 id="1、模块"><a href="#1、模块" class="headerlink" title="1、模块"></a>1、模块</h2><p>模块是具有 @Module() 装饰器的类。 @Module() 装饰器提供了元数据，Nest 用它来组织应用程序结构。</p>
<p><a href="https://docs.nestjs.com/modules" target="_blank" rel="noopener">NestModule</a></p>
<p><a href="https://www.itying.com/nestjs/statics/images/module.png" data-fancybox="group" data-caption="Nestjs中的模块" class="fancybox"><img alt="Nestjs中的模块" title="Nestjs中的模块" data-src="https://www.itying.com/nestjs/statics/images/module.png" class="lazyload"></a></p>
<p>每个 Nest 应用程序至少有一个模块，即根模块。根模块是 Nest 开始安排应用程序树的地方。事实上，根模块可能是应用程序中唯一的模块，特别是当应用程序很小时，但是对于大型程序来说这是没有意义的。在大多数情况下，您将拥有多个模块，每个模块都有一组紧密相关的功能。</p>
<p><strong>@module() 装饰器接受一个描述模块属性的对象：</strong></p>
<pre><code class="javascript">providers        由 Nest 注入器实例化的提供者，并且可以至少在整个模块中共享
controllers        必须创建的一组控制器
imports            导入模块的列表，这些模块导出了此模块中所需提供者
exports            由本模块提供并应在其他模块中可用的提供者的子集</code></pre>
<h3 id="1、创建模块"><a href="#1、创建模块" class="headerlink" title="1、创建模块"></a>1、创建模块</h3><pre><code class="shell">nest g module admin</code></pre>
<p><a href="https://www.itying.com/nestjs/statics/images/module2.png" data-fancybox="group" data-caption="Nestjs中的模块" class="fancybox"><img alt="Nestjs中的模块" title="Nestjs中的模块" data-src="https://www.itying.com/nestjs/statics/images/module2.png" class="lazyload"></a></p>
<h3 id="2、共享模块"><a href="#2、共享模块" class="headerlink" title="2、共享模块"></a>2、共享模块</h3><p>实际上，每个模块都是一个共享模块。一旦创建就能被任意模块重复使用。假设我们将在几个模块之间共享 CatsService 实例。 我们需要把 CatsService 放到 exports 数组中，如下所 示：</p>
<pre><code class="javascript">import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService]
})
export class CatsModule {}</code></pre>
<h2 id="2、TypeORM操作Mysql数据库"><a href="#2、TypeORM操作Mysql数据库" class="headerlink" title="2、TypeORM操作Mysql数据库"></a>2、TypeORM操作Mysql数据库</h2><p>Nestjs中操作mysql数据库可以使用Nodejs封装的DB库，也可以使用TypeORM。下面我们主要给大家讲讲在Nestjs中使用TypeORM操作mysql数据库</p>
<h3 id="1、关于TypeORM"><a href="#1、关于TypeORM" class="headerlink" title="1、关于TypeORM"></a>1、关于TypeORM</h3><p>TypeORM是一个ORM框架，是一款比较成熟的对象关系映射器，它是由typescript写的。 支持 MySQL, PostgreSQL, MariaDB, SQLite, MS SQL Server, Oracle, WebSQL等数据库。</p>
<h3 id="2、安装TypeORM-操作Mysql模块"><a href="#2、安装TypeORM-操作Mysql模块" class="headerlink" title="2、安装TypeORM 操作Mysql模块"></a>2、安装TypeORM 操作Mysql模块</h3><p>Nest 操作Mysql<a href="https://docs.nestjs.com/techniques/database" target="_blank" rel="noopener">官方文档</a></p>
<pre><code class="shell">npm install --save @nestjs/typeorm typeorm mysql</code></pre>
<h3 id="3、配置数据库"><a href="#3、配置数据库" class="headerlink" title="3、配置数据库"></a>3、配置数据库</h3><p>在app.module.ts中配置数据库连接</p>
<pre><code class="typescript">      import { Module } from '@nestjs/common';
      import { TypeOrmModule } from '@nestjs/typeorm';
      @Module({
        imports: [
          TypeOrmModule.forRoot({
            type: 'mysql',
            host: 'localhost',
            port: 3306,
            username: 'root',
            password: 'root',
            database: 'test',
            entities: [__dirname + '/**/*.entity{.ts,.js}'],
            synchronize: true,
          }),
        ],
      })
      export class AppModule {}
</code></pre>
<h3 id="3、配置实体entity"><a href="#3、配置实体entity" class="headerlink" title="3、配置实体entity"></a>3、配置实体entity</h3><pre><code class="typescript">      import { PrimaryGeneratedColumn, Column, Entity } from "typeorm";
      @Entity()
      export class Nav {
        @PrimaryGeneratedColumn()
        id: number;

        @Column({length: 45})
        name: string;

        @Column({length:255})
        url: string;

        @Column('int')
        status: number;
      }
</code></pre>
<h3 id="4、在控制器对应的Module中配置Model"><a href="#4、在控制器对应的Module中配置Model" class="headerlink" title="4、在控制器对应的Module中配置Model"></a>4、在控制器对应的Module中配置Model</h3><pre><code class="typescript">      import { Module } from '@nestjs/common';
      import { UserController } from './controller/user/user.controller';
      import { NewsController } from './controller/news/news.controller';
      import { TypeOrmModule } from '@nestjs/typeorm';
      import {Nav} from '../../entity/nav.entity';
      import {Navinfo} from '../../entity/navinfo.entity';
      import { AppService } from '../../app.service';

      @Module({
        imports:[TypeOrmModule.forFeature([Nav,Navinfo])],
        controllers: [UserController, NewsController],
        providers:[AppService]
      })
      export class AdminModule {}

</code></pre>
<h3 id="5、在服务里面使用-InjectRepository获取数据库Model实现操作数据库"><a href="#5、在服务里面使用-InjectRepository获取数据库Model实现操作数据库" class="headerlink" title="5、在服务里面使用@InjectRepository获取数据库Model实现操作数据库"></a>5、在服务里面使用@InjectRepository获取数据库Model实现操作数据库</h3><pre><code class="typescript">      import { Injectable } from '@nestjs/common';
      import { InjectRepository } from '@nestjs/typeorm';
      import { Repository } from 'typeorm';
      import {Nav} from './entity/nav.entity';
      import {Navinfo} from './entity/navinfo.entity';
      @Injectable()
      export class AppService {
        constructor(
          //依赖注入
          @InjectRepository(Nav) private readonly navRepository: Repository,
          @InjectRepository(Navinfo) private readonly navinfoRepository: Repository,
        ) {}
        async findAll(){   
          return await this.navRepository.find();    
        }
      }
</code></pre>
<h2 id="3、Redis"><a href="#3、Redis" class="headerlink" title="3、Redis"></a>3、Redis</h2><h3 id="1、基本语法"><a href="#1、基本语法" class="headerlink" title="1、基本语法"></a>1、基本语法</h3><ul>
<li>Redis 字符串数据类型的相关命令用于管理 redis 字符串值。</li>
</ul>
<pre><code class="json">  基本语法：
  查看所有的key:         keys *
  普通设置：             set key value
  设置并加过期时间：     set key value EX 30           表示30秒后过期
  获取数据：             get key
  删除指定数据：         del key
  删除全部数据:          flushall 
  查看类型：             type key
  设置过期时间:          expire key  20              表示指定的key5秒后过期
</code></pre>
<ul>
<li>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li>
</ul>
<pre><code class="json">基本语法：
列表右侧增加值：             rpush key value
列表左侧增加值：             lpush key value
右侧删除值：                 rpop key
左侧删除值：                 lpop key
获取数据：                   lrange key
删除指定数据：               del key
删除全部数据:                flushall 
查看类型：                   type key</code></pre>
<ul>
<li>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。它和列表的最主要区别就是没法增加重复值</li>
</ul>
<pre><code>基本语法：
给集合增数据：               sadd key value
删除集合中的一个值：         srem key value
获取数据：                   smembers key
删除指定数据：               del key
删除全部数据:                flushall </code></pre><ul>
<li>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</li>
</ul>
<pre><code>  基本语法：
  设置值hmset ：               hmset zhangsan name "张三" age 20  sex “男”
  设置值hset ：                 hset zhangsan name "张三"
  获取数据：                     hgetall key
  删除指定数据：                 del key
  删除全部数据:                  flushall </code></pre><ul>
<li>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</li>
</ul>
<blockquote>
<p><strong>发布</strong></p>
</blockquote>
<pre><code class="typescript">  client.publish('testPublish', 'message from publish.js');</code></pre>
<blockquote>
<p><strong>订阅</strong></p>
</blockquote>
<pre><code class="typescript">client.subscribe('testPublish');
client.on('message', function(channel, msg){
    console.log('client.on message, channel:', channel, ' message:', msg);
});</code></pre>
<h3 id="2、Nest使用"><a href="#2、Nest使用" class="headerlink" title="2、Nest使用"></a>2、Nest使用</h3><p><a href="https://github.com/kyknow/nestjs-redis" target="_blank" rel="noopener">Nestjs Redis 官方文档</a></p>
<h4 id="1、安装redis"><a href="#1、安装redis" class="headerlink" title="1、安装redis"></a><strong>1、安装redis</strong></h4><pre><code class="shell">npm install nestjs-redis --save</code></pre>
<h4 id="2、用到redis的模块中注册RedisModule"><a href="#2、用到redis的模块中注册RedisModule" class="headerlink" title="2、用到redis的模块中注册RedisModule"></a><strong>2、用到redis的模块中注册RedisModule</strong></h4><p>options是一个对象，里面配置了连接redis服务器的信息</p>
<pre><code class="typescript">  import { RedisModule} from 'nestjs-redis'
  关于options
  let options={
          port: 6379,
          host: '127.0.0.1',
          password: '',
          db: 0
  }
   @Module({
      imports: [
          RedisModule.register(options)
      ],
  })</code></pre>
<h4 id="3、创建一个cache-service-ts-服务-封装操作redis的方法"><a href="#3、创建一个cache-service-ts-服务-封装操作redis的方法" class="headerlink" title="3、创建一个cache.service.ts 服务 封装操作redis的方法"></a><strong>3、创建一个cache.service.ts 服务 封装操作redis的方法</strong></h4><pre><code class="typescript">import { Injectable } from '@nestjs/common';
import { RedisService } from 'nestjs-redis';
@Injectable()
export class CacheService {    
    public client;
    constructor(private redisService: RedisService) {
        this.getClient();
    }
    async getClient() {
        this.client = await this.redisService.getClient()
    }

    //设置值的方法
    async set(key:string, value:any, seconds?:number) {
        value = JSON.stringify(value);
        if(!this.client){
            await this.getClient();
        }
        if (!seconds) {
            await this.client.set(key, value);
        } else {
            await this.client.set(key, value, 'EX', seconds);
        }
    }

    //获取值的方法
    async get(key:string) {
        if(!this.client){
            await this.getClient();
        }
        var data = await this.client.get(key);           
        if (!data) return;
        return JSON.parse(data);       
    }
}</code></pre>
<h4 id="4、调用cache-service-ts-里面封装的方法操作redis数据库"><a href="#4、调用cache-service-ts-里面封装的方法操作redis数据库" class="headerlink" title="4、调用cache.service.ts 里面封装的方法操作redis数据库"></a><strong>4、调用cache.service.ts 里面封装的方法操作redis数据库</strong></h4><pre><code class="typescript">await this.cache.set('username','李四');

await this.cache.get('username')</code></pre>
<h2 id="4、GraphQL"><a href="#4、GraphQL" class="headerlink" title="4、GraphQL"></a>4、GraphQL</h2><p>GraphQl是一种新的API 的查询语言，它提供了一种更高效、强大和灵活API 查询,下面给大家讲讲在Nestjs中使用Graphql</p>
<p>Nestjs中使用<a href="https://docs.nestjs.com/graphql/quick-start" target="_blank" rel="noopener">Graphql官方文档</a></p>
<h3 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h3><pre><code class="shell"> $ npm i --save @nestjs/graphql graphql-tools graphql        </code></pre>
<h3 id="2、定义数据库Schema"><a href="#2、定义数据库Schema" class="headerlink" title="2、定义数据库Schema"></a>2、定义数据库Schema</h3><p>src目录下面新建app.graphql，Schema（数据映射模型）代码如下</p>
<pre><code class="typescript">type Query {
  hello: String
  findCat(id: ID): Cat
  cats: [Cat]
}

type Cat {
  id: Int
  name: String
  age: Int
}

type Mutation {
  addCat(cat: InputCat): Cat
}

input InputCat {
  name: String
  age: Int
}
</code></pre>
<h3 id="3、定义-resolvers-操作数据库的方法"><a href="#3、定义-resolvers-操作数据库的方法" class="headerlink" title="3、定义 resolvers 操作数据库的方法"></a>3、定义 resolvers 操作数据库的方法</h3><p>通过命令创建resolvers</p>
<pre><code class="shell">nest g resolver app</code></pre>
<p>这样会在src目录下面生成app.resolvers.ts ，然后配置如下代码</p>
<pre><code class="typescript">import { ParseIntPipe } from '@nestjs/common';
import { Query, Resolver, Args, Mutation } from '@nestjs/graphql';
import { AppService } from './app.service';

@Resolver()
export class AppResolver {
  constructor(private readonly appService: AppService) {}

  // query { hello }
  @Query()
  hello(): string {
    return this.appService.hello();
  }

  // query { findCat(id: 1) { name age } }
  // 网络传输过来的id会是字符串类型，而不是number
  @Query('findCat')
  findOneCat(@Args('id', ParseIntPipe) id: number) {
    return this.appService.findCat(id);
  }

  // query { cats { id name age } }
  @Query()
  cats() {
    return this.appService.findAll();
  }

  // mutation { addCat(cat: {name: "ajanuw", age: 12}) { id name age } }
  @Mutation()
  addCat(@Args('cat') args) {
    console.log(args);
    return this.appService.addCat(args)
  }
}
</code></pre>
<h3 id="4、定义-服务-app-service-ts"><a href="#4、定义-服务-app-service-ts" class="headerlink" title="4、定义 服务 app.service.ts"></a>4、定义 服务 app.service.ts</h3><pre><code class="typescript">import { Injectable } from '@nestjs/common';
import { Cat } from './graphql.schema';

@Injectable()
export class AppService {
  private readonly cats: Cat[] = [
    { id: 1, name: 'a', age: 1 },
    { id: 2, name: 'b', age: 2 },
  ];
  hello(): string {
    return 'Hello World!';
  }

  findCat(id: number): Cat {
    return this.cats.find(c => c.id === id);
  }

  findAll(): Cat[] {
    return this.cats;
  }

  addCat(cat: Cat): Cat {
    const newCat = { id: this.cats.length + 1, ...cat };
    console.log(newCat);
    this.cats.push(newCat);
    return newCat;
  }
}
</code></pre>
<h3 id="5、定义接口-graphql-schema-ts-（非必须）"><a href="#5、定义接口-graphql-schema-ts-（非必须）" class="headerlink" title="5、定义接口 graphql.schema.ts （非必须）"></a>5、定义接口 graphql.schema.ts （非必须）</h3><pre><code class="typescript">export class Cat {
  id: number;
  name: string;
  age: number;
}
</code></pre>
<h3 id="6、配置app-module-ts"><a href="#6、配置app-module-ts" class="headerlink" title="6、配置app.module.ts"></a>6、配置app.module.ts</h3><pre><code class="typescript">import { Module } from '@nestjs/common';
import { AppService } from './app.service';

import { GraphQLModule } from '@nestjs/graphql';
import { AppResolver } from './app.resolvers';

@Module({
  imports: [
    GraphQLModule.forRoot({
      typePaths: ['./**/*.graphql'],   //加载目录下面所有以graphql结尾的schema文件，当做固定写法
    }), 
  ],
  providers: [AppService, AppResolver],
})
export class AppModule {}
</code></pre>
<h3 id="7、操作graphql数据库"><a href="#7、操作graphql数据库" class="headerlink" title="7、操作graphql数据库"></a>7、操作graphql数据库</h3><pre><code class="typescript">// 发送
query { hello }

// 返回
{
  "data": {
    "hello": "hello nest.js"
  }
}</code></pre>
<h2 id="5、Websocket-socket-io实时通信"><a href="#5、Websocket-socket-io实时通信" class="headerlink" title="5、Websocket(socket.io实时通信)"></a>5、Websocket(socket.io实时通信)</h2><p>在 Nest 中，网关只是一个用 @WebSocketGateway() 装饰器注解的类。从技术上讲，网关与平台无关，这使得它们在创建适配器之后就可以与任何 WebSockets 库兼容。有两个开箱即用的WS平台:socket.io和ws。你可以选择最适合你需要的。另外，您可以按照本指南构建自己的适配器。</p>
<p><a href="https://docs.nestjs.com/websockets/gateways" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="1、安装-socketIo对应模块"><a href="#1、安装-socketIo对应模块" class="headerlink" title="1、安装 socketIo对应模块"></a>1、安装 socketIo对应模块</h3><pre><code class="shell">$ npm i --save @nestjs/websockets @nestjs/platform-socket.io
$ npm i --save-dev @types/socket.io      </code></pre>
<h3 id="2、生成gateway并配置socket"><a href="#2、生成gateway并配置socket" class="headerlink" title="2、生成gateway并配置socket"></a>2、生成gateway并配置socket</h3><pre><code class="shell">nest g gateway events  </code></pre>
<p>通过上面命令会在src目录下面生成events.gateway.js</p>
<p>这个里面可以自定义方法接受客户端广播</p>
<pre><code class="typescript">import { 
        SubscribeMessage, 
        WebSocketGateway, 
        WsResponse, 
        WebSocketServer 
        } from '@nestjs/websockets';
import { Observable, of } from 'rxjs';  //异步流数据处理框架
import { map } from 'rxjs/operators'
const l = console.log

@WebSocketGateway()
export class EventsGateway {
  @WebSocketServer() server;

  @SubscribeMessage('events')
  onEvent(client: any, payload: any): Observable> | any {
    // this.server.emit('resmsg', data);  // io.emit('resmsg', payload)
    let { name } = payload;
    if (name === 'ajanuw') {
      return of({
        event: 'events',
        data: {
          msg: 'hello ajanuw!'
        }
      })
    }
    if (name === 'alone') {
      return of('hi', '实打实')
        .pipe(
          map($_ =>
            ({
              event: 'events', data: {
                msg: $_
              }
            }))
        );
    }
    return of(payload);
  }

}
</code></pre>
<h3 id="3、app-module-ts"><a href="#3、app-module-ts" class="headerlink" title="3、app.module.ts"></a>3、app.module.ts</h3><pre><code class="typescript">app.module.ts
import { EventsGateway } from './events/events.gateway'
@Module({
  providers: [EventsGateway],
})
</code></pre>
<h3 id="4、socket客户端"><a href="#4、socket客户端" class="headerlink" title="4、socket客户端"></a>4、socket客户端</h3><pre><code class="javascript">    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>
  <script>
    const l = console.log
    let socket = io('http://localhost:5000');
    socket.on('connect', function () {
      console.log('链接成功');
      // 发射
      socket.emit('events', {
        name: 'ajanuw'
      });
      // 发射
      socket.emit('events', {
        name: 'alone'
      });
      // 发射
      // socket.emit('identity', 0, (response) => console.log('Identity:', response));
    });
    // 监听
    socket.on('events', (data) => {
      l(data.msg)
    });
  </script>
</code></pre>
<h3 id="5、分组广播和监听进入离开事件"><a href="#5、分组广播和监听进入离开事件" class="headerlink" title="5、分组广播和监听进入离开事件"></a>5、分组广播和监听进入离开事件</h3><pre><code class="typescript">  import { SubscribeMessage, WebSocketGateway,WebSocketServer} from '@nestjs/websockets';
  import { of } from 'rxjs';
  import * as url from "url"

  @WebSocketGateway()
  export class EventsGateway {
    @WebSocketServer() server;

    private clientsArr:any[]=[];

    handleConnection(client: any,){

      console.log('有人链接了'+client.id);   

    }

    handleDisconnect(client:any){

    }

    @SubscribeMessage('addCart')
    addCart(client: any, payload: any) {
         console.log(payload) 

        var roomid=url.parse(client.request.url,true).query.roomid;   /*获取房间号 获取桌号*/
        client.join(roomid);
        // this.server.to(roomid).emit('addCart','Server AddCart Ok');    //广播所有人包含自己

        client.broadcast.to(roomid).emit('addCart','Server AddCart Ok');   //不包括自己


    }

  }  </code></pre>
<p><strong>客户端代码:</strong></p>
<pre><code class="typescript">


    <meta charset="UTF-8">
    <title>socket.io</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.1.1/socket.io.js"></script>


<h1>socket.io的多房间1111</h1>
<input type="button" value="加入购物车" onclick="addCart()"><br>





<script type="text/javascript">

    //和服务器建立长连接
    var socket = io.connect('http://localhost:3000?roomid=1');

    //接收服务器返回的信息
    socket.on('addCart',function(data){

        console.log(data);
    });

    function addCart(){
        socket.emit('addCart','addCart');
    }

</script></code></pre>
<h2 id="6、微服务"><a href="#6、微服务" class="headerlink" title="6、微服务"></a>6、微服务</h2><p>除了传统的(有时称为单片)应用程序架构之外，Nest 还支持微服务架构风格的开发。本文档中其他地方讨论的大多数概念，如依赖项注入、装饰器、异常过滤器、管道、保护和拦截器，都同样适用于微服务。Nest 会尽可能地抽象化实现细节，以便相同的组件可以跨基于 HTTP 的平台，WebSocket 和微服务运行。</p>
<p><a href="https://docs.nestjs.com/microservices/basics" target="_blank" rel="noopener">文档</a></p>
<p>Nest 支持几种内置的传输层实现，称为传输器，负责在不同的微服务实例之间传输消息。大多数传输器本机都支持请求 - 响应和基于事件的消息样式。Nest 在规范接口的后面抽象了每个传输器的实现细节，用于请求 - 响应和基于事件的消息传递。这样可以轻松地从一个传输层切换到另一层，例如，利用特定传输层的特定可靠性或性能功能，而不会影响您的应用程序代码。</p>
<p>通俗的讲:Nestjs中的管道可以将输入数据转换为所需的输出。此外，它也可以处理验证，当数据不正确时可能会抛出异常。</p>
<h3 id="1、安装-1"><a href="#1、安装-1" class="headerlink" title="1、安装"></a><strong>1、安装</strong></h3><pre><code class="shell">$ npm i --save @nestjs/microservices        </code></pre>
<blockquote>
<p><strong>main.ts</strong></p>
</blockquote>
<pre><code class="typescript">import { NestFactory } from '@nestjs/core';
import { Transport } from '@nestjs/microservices';

import { AppModule } from './app.module';

async function bootstrap() {
    const app = await NestFactory.create(AppModule);
    app.connectMicroservice({
    transport: Transport.TCP,
    });

    await app.startAllMicroservicesAsync();
    await app.listen(5000);
}
bootstrap();</code></pre>
<blockquote>
<p><strong>app.controller.ts</strong></p>
</blockquote>
<pre><code class="typescript">import { Controller, Get, Query, UsePipes } from '@nestjs/common';
import {
  MessagePattern,
  Client,
  Transport,
  ClientProxy,
} from '@nestjs/microservices';
import { AppService } from './app.service';

import { Observable, from } from 'rxjs';

import { ValidationPipe } from './validation.pipe';

@Controller()
export class AppController {
  @Client({ transport: Transport.TCP })
  client: ClientProxy;

  constructor(private readonly appService: AppService) {}

  @UsePipes(new ValidationPipe())
  @Get()
  getHello(@Query('data') data): Observable {
    // const pattern = { cmd: 'sumObservable' };
    // const pattern = { cmd: 'sumAsync' };
    const pattern = { cmd: 'sum' };

    // 使用 send 调用微服务
    const r = this.client.send(pattern, data);
    return r;
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return data.reduce((acc, el) => acc + el);
  }

  // 返回promise异步响应
  @MessagePattern({ cmd: 'sumAsync' })
  sumAsync(data: number[]): Promise {
    const result = data.reduce((acc, el) => acc + el) + 1;
    return Promise.resolve(result);
  }

  // 程序将响应3次
  @MessagePattern({ cmd: 'sumObservable' })
  sumObservable(data: number[]): Observable {
    return from([1, 2, 3]);
  }
}</code></pre>
<blockquote>
<p><strong>validation.pipe.ts</strong></p>
</blockquote>
<pre><code class="typescript">import {
  PipeTransform,
  Injectable,
  ArgumentMetadata,
  PayloadTooLargeException,
  BadRequestException,
} from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    if (metadata.type === 'query') {
      try {
        return JSON.parse(value);
      } catch (error) {
        throw new BadRequestException();
      }
    } else {
      throw new PayloadTooLargeException();
    }
  }
}</code></pre>
<blockquote>
<p><strong>输入：</strong></p>
</blockquote>
<pre><code class="typescript">http://localhost:5000/?data=[1,2, 3] // 6</code></pre>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>Nest应用（二）</title>
    <url>/2020/04/03/Nest-dev-02/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Nest-6-x-快速指南"><a href="#Nest-6-x-快速指南" class="headerlink" title="Nest 6.x 快速指南"></a>Nest 6.x 快速指南</h1><h2 id="1、-路由-视图层"><a href="#1、-路由-视图层" class="headerlink" title="1、 路由/视图层"></a>1、 路由/视图层</h2><p>如果我们希望在Nest里面管理路由的跳转，即项目保持高耦合的前后端不分离架构，我们则需要对Nest配置模板引擎，针对目前的开发模式和要求，这种方式有很多限制，所以我推荐实行前后端分离的模式。Nest只是处理I/O，专注于提供数据接口。</p>
<h3 id="1、安装模板引擎-ejs-或者pugjs"><a href="#1、安装模板引擎-ejs-或者pugjs" class="headerlink" title="1、安装模板引擎 ejs(或者pugjs)"></a>1、安装模板引擎 ejs(或者pugjs)</h3><pre><code class="javascript">cnpm i ejs --save</code></pre>
<h3 id="2、配置模板引擎"><a href="#2、配置模板引擎" class="headerlink" title="2、配置模板引擎"></a>2、配置模板引擎</h3><pre><code class="javascript">app.setBaseViewsDir(join(__dirname, '..', 'views')) // 放视图的文件
app.setViewEngine('ejs');    </code></pre>
<h3 id="3、配置完整代码"><a href="#3、配置完整代码" class="headerlink" title="3、配置完整代码"></a>3、配置完整代码</h3><pre><code class="javascript">import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { NestExpressApplication } from '@nestjs/platform-express';
import {join} from 'path';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  // app.useStaticAssets('public'); 
  app.useStaticAssets(join(__dirname, '..', 'public'),{
    prefix: '/static/',   //设置虚拟路径---保证路径文件下文件安全性
 }); 

  app.setBaseViewsDir(join(__dirname, '..', 'views')) // 放视图的文件（模板浏览器渲染页面）
  app.setViewEngine('ejs');

  await app.listen(3000);
}
bootstrap();</code></pre>
<h3 id="3、渲染页面"><a href="#3、渲染页面" class="headerlink" title="3、渲染页面"></a>3、渲染页面</h3><p>Nestjs中 Render装饰器可以渲染模板</p>
<pre><code class="javascript">import { Get, Controller, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index') //跳转路由--指定到视图层（View）下具体存在的文件
  root() {
    return { message: 'Hello world!' };
  }
}</code></pre>
<h3 id="4、ejs"><a href="#4、ejs" class="headerlink" title="4、ejs"></a>4、ejs</h3><pre><code class="ejs"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    这是ejs演示代码
    <br>    
    <%=message%>
</body>
</html>
</code></pre>
<h2 id="2、-注解"><a href="#2、-注解" class="headerlink" title="2、 注解"></a>2、 注解</h2><p>注解：即为一个个单独的包装函数，含有特定的实现功能，和java里面Spring一样表示为“@functionName()”,并且多个注解之间没有影响，只是集成所有方法的功能。</p>
<h2 id="3、服务"><a href="#3、服务" class="headerlink" title="3、服务"></a>3、服务</h2><h3 id="1、创建服务"><a href="#1、创建服务" class="headerlink" title="1、创建服务"></a><strong>1、创建服务</strong></h3><pre><code class="shell">nest g service news</code></pre>
<p>创建好服务后就可以在服务中定义对应的方法</p>
<pre><code class="javascript">    import { Injectable } from '@nestjs/common';

    @Injectable()
    export class NewsService {    
        findAll(){    
            return [
                {"title":"新闻1"},
                {"title":"新闻2"},
            ];
        }
    }
</code></pre>
<h3 id="2、使用服务"><a href="#2、使用服务" class="headerlink" title="2、使用服务"></a><strong>2、使用服务</strong></h3><p>1、需要在根模块引入并配置</p>
<pre><code class="javascript">import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UserController } from './user/user.controller';
import { NewsService } from './news/news.service';
import { NewsController } from './news/news.controller';
import { ArticleController } from './article/article.controller';

@Module({
  imports: [],
  controllers: [AppController, UserController, NewsController, ArticleController],
  providers: [AppService, NewsService],
})
export class AppModule {}</code></pre>
<p>2、在用到的地方引入并配置</p>
<pre><code class="javascript">    import { Controller, Get ,Render} from '@nestjs/common';

    import { NewsService } from './news.service';

    @Controller('news')
    export class NewsController {

        constructor(private newsServices:NewsService){}

        @Get()
        @Render('default/news')
        index(){
            return {
                newsList:this.newsServices.findAll()
            }
        }
    }
</code></pre>
<h2 id="4-、控制器"><a href="#4-、控制器" class="headerlink" title="4 、控制器"></a>4 、控制器</h2><p>控制器注解@Controller(),控制层负责处理传入的HTTP请求。在Nest中，控制器是一个带有<code>@Controller()</code>装饰器的类。</p>
<pre><code class="javascript">import { Controller, Get, Post, HttpStatus } from '@nestjs/common';

@Controller('users')
export class UsersController {
    @Get('')  // /user
    getAllUsers() {}

    @Get(':id') // user/01
    getUser() {}

    @Post('') // /user
    addUser() {}
}</code></pre>
<blockquote>
<p>获取传值注解</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">Nest</th>
<th>Express</th>
</tr>
</thead>
<tbody><tr>
<td align="left">@Request() / @Req()</td>
<td>req</td>
</tr>
<tr>
<td align="left">@Response() @Res()</td>
<td>res</td>
</tr>
<tr>
<td align="left">@Next()</td>
<td>next</td>
</tr>
<tr>
<td align="left">@Session()</td>
<td>res.session</td>
</tr>
<tr>
<td align="left">@Param(param?:string)</td>
<td>req.params[param]</td>
</tr>
<tr>
<td align="left">@Body(param?: string)</td>
<td>req.body[param]</td>
</tr>
<tr>
<td align="left">@Query(param?: string)</td>
<td>req.query[param]</td>
</tr>
<tr>
<td align="left">@Headers(param?: string)</td>
<td>req.headers[param]</td>
</tr>
</tbody></table>
<h2 id="5、Session"><a href="#5、Session" class="headerlink" title="5、Session"></a>5、Session</h2><p>session是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而session保存在服务器上。当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key,value的键值对， 然后将key(cookie)返回到浏览器(客户)端，浏览器下次再访问时，携带key(cookie)，找到对应的session(value)。 客户的信息都保存在session中</p>
<h3 id="1、express-session-使用"><a href="#1、express-session-使用" class="headerlink" title="1、express-session 使用"></a>1、express-session 使用</h3><p><strong>1.安装 express-session</strong></p>
<pre><code class="shell">cnpm install express-session  --save</code></pre>
<p><strong>2.引入express-session</strong></p>
<pre><code class="shell">import * as session from 'express-session';</code></pre>
<p><strong>3.配置session中间件</strong></p>
<pre><code class="javascript"> app.use(session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }}))</code></pre>
<p><strong>4.nestjs中使用session</strong></p>
<pre><code class="javascript">设置值 req.session.username = "张三";
获取值 req.session.username            </code></pre>
<h3 id="2、express-session参数"><a href="#2、express-session参数" class="headerlink" title="2、express-session参数"></a>2、express-session参数</h3><pre><code class="json">secret    一个String类型的字符串，作为服务器端生成session的签名。 
name    返回客户端的key的名称，默认为connect.sid,也可以自己设置。 
resave    强制保存session即使它并没有变化,。默认为true。建议设置成false。 don't save session if unmodified 
saveUninitialized    强制将未初始化的session存储。当新建了一个session且未设定属性或值时，它就处于
未初始化状态。在设定一个cookie前，这对于登陆验证，减轻服务端存储压力，权限控制是有帮助的。（默认：true）。建议手动添加。
cookie    设置返回到前端key的属性，默认值为{ path: ‘/’, httpOnly: true, secure: false, maxAge: null }。
rolling    在每次请求时强行设置cookie，这将重置cookie过期时间（默认：false）</code></pre>
<pre><code class="javascript">app.use(session({
  secret: '12345',
  name: 'name',
  cookie: {maxAge: 60000},
  resave: false,
  saveUninitialized: true
}));</code></pre>
<h3 id="3、express-session方法"><a href="#3、express-session方法" class="headerlink" title="3、express-session方法"></a>3、express-session方法</h3><pre><code class="javascript">req.session.destroy(function(err) {   /*销毁session*/})
req.session.username='张三';     //设置session
req.session.username            //获取session
req.session.cookie.maxAge=0;    //重新设置cookie的过期时间</code></pre>
<h2 id="6、文件上传"><a href="#6、文件上传" class="headerlink" title="6、文件上传"></a>6、文件上传</h2><p>Nestjs内置了文件上传的方法，Nestjs中通过file-upload可以实现单文件上传，多文件上传</p>
<p>Nestjs <a href="https://docs.nestjs.com/techniques/file-upload" target="_blank" rel="noopener">file-upload官方文档</a></p>
<h3 id="1、前端代码"><a href="#1、前端代码" class="headerlink" title="1、前端代码"></a><strong>1、前端代码</strong></h3><p>上传图片的时候From表单中需要配置<strong>enctype=”multipart/form-data”</strong></p>
<pre><code class="ejs">    <form action="user/add" method="post" enctype="multipart/form-data">    
        <input type="text" name="title1" id="" placeholder="新闻标题"/>    

        <input type="text" name="keywords" id="" placeholder="关键词"/>       

        <input type="text" name="author" id="" placeholder="作者" />

        <input type="file" name="pic" id="" />

        <input type="text" name="status" id="" placeholder="状态" />       

        <input type="submit" value="提交">        
    </form></code></pre>
<h3 id="2、后端代码"><a href="#2、后端代码" class="headerlink" title="2、后端代码"></a><strong>2、后端代码</strong></h3><pre><code class="javascript">import { 
        Controller, 
        Get, 
        Render, 
        Post,
        UseInterceptors,
        UploadedFile
        } from '@nestjs/common';
import { FileInterceptor,FilesInterceptor } from '@nestjs/platform-express';
@Post('doAdd')
@UseInterceptors(FileInterceptor('pic'))
addUser(@UploadedFile() file,@Body() body){
        console.log(body); 
        console.log(file);     
        const writeImage = createWriteStream(join(__dirname, '..','../public/upload', `${file.originalname}`))
        writeImage.write(file.buffer)
        return '上传成功';
}</code></pre>
<p><strong>3、nestjs多文件上传</strong></p>
<pre><code class="javascript">import { 
        Controller, 
        Get, 
        Render, 
        Post,
        UseInterceptors,
        UploadedFiles
        } from '@nestjs/common';
import { FileInterceptor,FilesInterceptor } from '@nestjs/platform-express';
@Post('doAddAll')
@UseInterceptors(FilesInterceptor('pic'))
addAllUser(@UploadedFiles() files,@Body() body){
for (const file of files) {
    const writeImage = 
createWriteStream(join(__dirname, '../../', 'public/upload', `${body.name}-${Date.now()}-${file.originalname}`));
    writeImage.write(file.buffer);
}
  return '上传成功';
}</code></pre>
<h2 id="7、中间件"><a href="#7、中间件" class="headerlink" title="7、中间件"></a>7、中间件</h2><h3 id="1、创建中间件"><a href="#1、创建中间件" class="headerlink" title="1、创建中间件"></a><strong>1、创建中间件</strong></h3><pre><code class="powershell">nest g middleware init</code></pre>
<pre><code class="javascript">
import { Injectable, NestMiddleware } from '@nestjs/common';
@Injectable()
export class InitMiddleware implements NestMiddleware {
  use(req: any, res: any, next: () => void) {
    console.log('init');
    next();
  }
}</code></pre>
<h3 id="2、配置单中间件"><a href="#2、配置单中间件" class="headerlink" title="2、配置单中间件"></a><strong>2、配置单中间件</strong></h3><p>在app.module.ts中继承NestModule然后配置中间件</p>
<pre><code class="javascript">export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        consumer
        .apply(InitMiddleware)
        .forRoutes({ path: '*', method: RequestMethod.ALL })
        .apply(NewsMiddleware)
        .forRoutes({ path: 'news', method: RequestMethod.ALL })
        .apply(UserMiddleware)
        .forRoutes(
            { path: 'user', method: RequestMethod.GET },                                
            { path: '', method: RequestMethod.GET });
    }
}</code></pre>
<h3 id="2、配置多中间件"><a href="#2、配置多中间件" class="headerlink" title="2、配置多中间件"></a>2、配置多中间件</h3><pre><code class="javascript">consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);</code></pre>
<h3 id="3、函数式中间件"><a href="#3、函数式中间件" class="headerlink" title="3、函数式中间件"></a>3、函数式中间件</h3><pre><code class="javascript">export function logger(req, res, next) {
    console.log(`Request...`);
    next();
};</code></pre>
<h3 id="4、全局中间件"><a href="#4、全局中间件" class="headerlink" title="4、全局中间件"></a>4、全局中间件</h3><pre><code class="javascript">const app = await NestFactory.create(ApplicationModule);
app.use(logger);
await app.listen(3000);</code></pre>
<h2 id="8、管道"><a href="#8、管道" class="headerlink" title="8、管道"></a>8、管道</h2><p>文档：<a href="https://docs.nestjs.com/pipes" target="_blank" rel="noopener">Nestjs-Pipe</a></p>
<p>通俗的讲:Nestjs中的管道可以将输入数据转换为所需的输出。此外，它也可以处理验证，当数据不正确时可能会抛出异常。也可以是过滤filters函数。</p>
<pre><code class="javascript">const data = {...}
const filterData = data.filter((item)=>return item typeof 'string')</code></pre>
<h3 id="1、创建管道"><a href="#1、创建管道" class="headerlink" title="1、创建管道"></a><strong>1、创建管道</strong></h3><pre><code class="shell">nest g pipe user  //ng g pipe  pip/user</code></pre>
<p>管道创建完成后生成如下代码：</p>
<pre><code class="javascript">import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
@Injectable()
export class UserPipe implements PipeTransform {
        transform(value: any, metadata: ArgumentMetadata) {
        //这个里面可以修改传入的值以及验证转入值的合法性
        return value;
    }
}</code></pre>
<h3 id="2、使用管道"><a href="#2、使用管道" class="headerlink" title="2、使用管道"></a><strong>2、使用管道</strong></h3><pre><code class="javascript">import { Controller,Get,UsePipes,Query} from '@nestjs/common';
import {UserPipe} from '../../user.pipe';
@Controller('user')
export class UserController {    
    @Get()
    index(){
        return '用户页面';
    }
    @Get('pipe')
    @UsePipes(new UserPipe())
    pipe(@Query() info){
        console.log(info);
        return `this is Pipe`;
    }
}</code></pre>
</body></html>]]></content>
      <categories>
        <category>nestjs</category>
      </categories>
      <tags>
        <tag>nest</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA-Cache</title>
    <url>/2020/03/19/PWA-Cache/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="PWA-CacheStorage-API"><a href="#PWA-CacheStorage-API" class="headerlink" title="PWA-CacheStorage API"></a>PWA-CacheStorage API</h1><blockquote>
<p>Progressive Web App （PWA）是渐进增强 Web App，它能让我们在不可靠的网络上也能快速加载、能够接收桌面通知、具有桌面图标，并且可采用顶层全屏体验的方式加载。</p>
</blockquote>
<p><a href="http://cdn.semlinker.com/cache-storage-api.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/cache-storage-api.png" class="lazyload"></a></p>
<p>  在 PWA 学习笔记之 fetch API 这篇文章中，我们介绍 fetch API 相关的一些基础知识，在该文章末尾我们还介绍了它在 PWA 应用中的使用场景，在具体的使用示例中，我们应用了 CacheStorage API。CacheStorage API（缓存存储应用程序接口），顾名思义是用来实现资源存储。该接口提供缓存 Request /Response 对象对的存储机制，尽管它被定义在 service worker 的标准中，但它不一定要配合 service worker 使用，接下来我们就来会一会 CacheStorage API。<br>  首先我们来回顾一下 fetch API 文章中使用的示例：</p>
<pre><code>self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 若缓存不存在，则使用fetch API从网上获取，然后利用Cache API缓存资源。
      return response || fetch(event.request).then((response) => {
          return caches.open('v1').then((cache) => {
            cache.put(event.request, response.clone());
            return response;
          });
     }); 
   })
  );
});</code></pre><p>  这个示例中，我们监听页面的 fetch 事件，对页面请求事件进行拦截，然后使用 event.respondWith 设置响应对象。在设置响应对象时，我们会优先从缓存中获取，若请求命中，则直接从缓存中获取已缓存的对象，直接返回。若请求未命中，则通过 fetch API 从远程获取对应的资源，当资源请求成功时，我们通过 open 方法获取 v1 版本的 CacheStorage 实例，然后调用该实例的 put 方法，进行资源缓存。<br>  这里需要注意的是，在使用 cache对象的 put 方法保存资源时，我们调用 response 对象的 clone 方法，而不是直接保存 response 对象。为什么需要克隆响应对象呢？这是因为 Request 和 Response 的 body （响应体）只能被读取一次！它们有一个属性叫 bodyUsed，读取一次之后设置为 true，就不能再读取了。<br>  通过上面的示例，我们简单介绍了 CacheStorage API 中的一些常用方法。接下来我们趁热打铁，来系统地了解一下目前 CacheStorage 已有的 API。</p>
<h2 id="1-CacheStorage-API-简介"><a href="#1-CacheStorage-API-简介" class="headerlink" title="1.CacheStorage API 简介"></a>1.CacheStorage API 简介</h2><blockquote>
<p>CacheStorage.match()：返回一个 Promise 对象，用于判断给定的请求对象是否已被缓存。若匹配则返回已缓存的对象。</p>
</blockquote>
<pre><code>caches.match(request, options).then(function(response) {
  // Do something with the response
});</code></pre><blockquote>
<p>CacheStorage.has()：返回一个 Promise 对象，用于判断 cacheName 对应的 Cache 对象是否存在。若 cacheName 对应的 Cache 对象存在，则返回 true 否则返回 false。</p>
</blockquote>
<pre><code>caches.has(cacheName).then(function(boolean) {
  // true: 缓存存在
});</code></pre><blockquote>
<p>CacheStorage.open()：返回一个 Promise 对象，用于获取 cacheName 对应的 Cache 对象。若 cacheName 对应的 Cache 存在则返回对应的 Cache 对象，若不存在的话，则会创建一个新的 Cache 对象。</p>
</blockquote>
<pre><code>caches.open(cacheName).then(function(cache) {
  // Do something with your cache
});</code></pre><blockquote>
<p>CacheStorage.delete()：返回一个 Promise 对象，用于删除 cacheName 对应的 Cache 对象。若 cacheName 对应的 Cache 对象存在且被成功删除，则返回 true，否则返回 false。</p>
</blockquote>
<pre><code>caches.delete(cacheName).then(function(true) {
  //your cache is now deleted
});</code></pre><blockquote>
<p>CacheStorage.keys()：返回一个 Promise 对象，用于获取 CacheStorage 对象中已存在的缓存名称列表。</p>
</blockquote>
<pre><code>caches.keys().then(function(keyList) {
  //do something with your keyList
});</code></pre><blockquote>
<p>CacheStorage API 使用示例</p>
</blockquote>
<pre><code>CacheStorage.match()
caches.match(event.request).then(function(response) {
  return response || fetch(event.request).then(function(r) {
    caches.open('v1').then(function(cache) {
      cache.put(event.request, r);
    });
    return r.clone();
  });
}).catch(function() {
  return caches.match('/sw-test/gallery/myLittleVader.jpg');
});
CacheStorage.has()
caches.has('v1').then(function(hasCache) {
  if (!hasCache) { // v1对应的Cache对象不存在
    someCacheSetupfunction();
  } else {
    caches.open('v1').then(function(cache) {
      return cache.addAll(myAssets);
    });
  }
}).catch(function() {
  // 处理异常
});
CacheStorage.open()
var cachedResponse = caches.match(event.request)
 .catch(function() {
    return fetch(event.request);
  }).then(function(response) {
    caches.open('v1').then(function(cache) {
      cache.put(event.request, response);
  });
  return response.clone();
}).catch(function() {
  return caches.match('/sw-test/gallery/myLittleVader.jpg');
});
CacheStorage.delete() & caches.keys()
this.addEventListener('activate', function(event) {
  var cacheWhitelist = ['v2']; // 缓存的白名单
  event.waitUntil(
    caches.keys().then(function(keyList) { // 返回已缓存的缓存名称列表
      return Promise.all(keyList.map(function(key) {
        if (cacheWhitelist.indexOf(key) === -1) { // 删除不含有v2的缓存对象
          return caches.delete(key);
        }
      }));
    })
  );
});</code></pre><p>  以上 CacheStorage API 相关示例来源于 MDN - CacheStorage 缓存存储。一口气分析完了 CacheStorage 相关的 API，不知道小伙伴有没有疑问。感觉对刚了解 PWA 的小伙伴们来说，会对示例中所使用的 fetch 或 activate 事件感到疑惑，这个不用着急。后续的文章我们会来揭开它们神秘的面纱。</p>
<h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2.总结"></a>2.总结</h2><p>  本文介绍了 CacheStorage API 的相关基础知识，最后我们来介绍一个小知识 —— 如何查看已缓存的资源？其实这个很简单，容我偷个懒，这里只介绍 Chrome 浏览器如何查看。准备好了么？Follow Me！</p>
<blockquote>
<ol>
<li>打开 Chrome 浏览器；</li>
<li>打开开发者工具；</li>
<li>切换到 Application Tab 页；</li>
<li>选择左侧 Cache 菜单下的 CacheStorage 选项。</li>
<li>初探 CacheStorage API 到此结束，下一篇就是介绍我们的 Service Workers 了，它可是 PWA 的核心 “人物 ” 哟。目前刚开始学习 PWA，有误之处，请小伙伴们多多指教。</li>
</ol>
</blockquote>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>PWA-Fetch</title>
    <url>/2020/03/19/PWA-Fetch/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="PWA-fetch-API"><a href="#PWA-fetch-API" class="headerlink" title="PWA-fetch API"></a>PWA-fetch API</h1><blockquote>
<p>Progressive Web App （PWA）是渐进增强 Web App，它能让我们在不可靠的网络上也能快速加载、能够接收桌面通知、具有桌面图标，并且可采用顶层全屏体验的方式加载。</p>
</blockquote>
<p><a href="http://cdn.semlinker.com/pwa-fetch-api.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/pwa-fetch-api.png" class="lazyload"></a></p>
<h2 id="1-PWA-简介"><a href="#1-PWA-简介" class="headerlink" title="1. PWA 简介"></a>1. PWA 简介</h2><p>Progressive Web App 具有的以下主要特点：</p>
<ul>
<li>渐进式 - 适用于选用任何浏览器的所有用户，因为它是以渐进式增强作为核心宗旨来开发的。</li>
<li>自适应 - 适合任何机型：桌面设备、移动设备、平板电脑或任何未来设备。</li>
<li>持续更新 - 在服务工作线程更新进程的作用下时刻保持最新状态。</li>
<li>安全 - 通过 HTTPS 提供，以防止窥探和确保内容不被篡改。</li>
<li>可安装 - 用户可免去使用应用商店的麻烦，直接将对其最有用的应用“保留”在主屏幕上。</li>
<li>可链接 - 可通过网址轻松分享，无需复杂的安装。</li>
</ul>
<p>  PWA 基于很多新的 API 和新的技术，如 fetch API、CacheStorage API、Background Sync、Service Worker 和 IndexedDB 等。然而要想真正了解并掌握 PWA，就必须了解它背后基于的技术。因此后续的文章，我们将逐一介绍 PWA 的相关技术。有兴趣的小伙伴们赶紧上车，我们将从 fetch API 开始，开启 PWA 的学习旅程。</p>
<h2 id="2-fetch-API"><a href="#2-fetch-API" class="headerlink" title="2.fetch API"></a>2.fetch API</h2><p>  fetch 中文的意思为获取，即通过它我们可以用来获取资源。在前端的日常工作中，我们通常需要从 API 获取数据，然后对数据进行处理或展示。在与服务器交互过程中使用的数据格式一般是 JSON，接下来我们先来体验一下，利用 fetch API 获取 angular 项目的团队的前五位成员，实现代码如下：</p>
<pre><code>if("fetch" in this) {
  fetch("https://api.github.com/orgs/angular/members?page=1&per_page=5")
    .then(res => res.json())
    .then(console.dir)
}</code></pre><p>  要实现同样的功能，我们当然也可以使用 XMLHttpRequest 对象，实现代码如下：</p>
<pre><code>var xhr = new XMLHttpRequest();
xhr.open('GET', "https://api.github.com/orgs/angular/members?page=1&per_page=5");
xhr.responseType = 'json';
xhr.onload = function() {
  console.dir(xhr.response);
};
xhr.send();</code></pre><p>  是不是感觉使用 fetch 简单很多，然而我们并不能随心所欲的使用它，因为它有兼容性问题，具体如下下图所示 （详细信息可浏览  <a href="https://www.caniuse.com" target="_blank" rel="noopener" ">can i use</a>- fetch）：</p>
<p><a href="http://cdn.semlinker.com/can-i-use-fetch-api.jpg" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://cdn.semlinker.com/can-i-use-fetch-api.jpg" class="lazyload"></a></p>
<p>  对于大多数小伙伴来说，应该更熟悉 jQuery.ajax()，fetch 规范与 jQuery.ajax() 的主要区别如下：<br>  当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject。<br>  默认情况下, fetch 不会从服务端发送或接收任何 cookies，如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置credentials 选项）。<br>  除了使用 fetch API 来获取 JSON 数据，我们也可以使用它来获取其它资源，比如普通文本、图片资源等。下面我们来看一下如何使用 fetch API 来获取图片资源，并在页面中显示。</p>
<pre><code>if ("fetch" in this) {
  let myImage = document.querySelector('img');
  fetch('https://mdn.github.io/dom-examples/streams/grayscale-png/tortoise.png')
    .then(function(response) {
       return response.blob();
    })
    .then(function(myBlob) {
       let objectURL = URL.createObjectURL(myBlob);
       myImage.src = objectURL;
    });
}</code></pre><p>  前面的两个示例中，我们通过 fetch 方法分别实现 JSON 数据的读取和图片的资源的获取功能。fetch 方法是 Fetch API 的核心方法，同时定义在 window 和 WorkerGlobalScope 环境中，因此我们可以在 Service Worker 环境中使用它。</p>
<blockquote>
<p>在 Fetch 标准 中该方法的声明如下：</p>
</blockquote>
<pre><code>partial interface WindowOrWorkerGlobalScope {
  [NewObject] Promise<response> fetch(RequestInfo input, optional RequestInit init);
};</response></code></pre><p>  通过观察上面的方法签名，我们可以知道 fetch 方法支持两个参数，调用后返回一个 Promise 对象。第二个参数是一个参数对象，用来初始化 Request。该参数对象有几个重要的属性：</p>
<ul>
<li>method：请求方法，可取 “GET”, “POST” 等，默认为 “GET”。</li>
<li>mode：请求模式，可取 “no-cors”, “cors”, “same-origin”。</li>
<li>credentials：是否携带 Cookie，可取：”omit”, “same-origin”,”include”。</li>
<li>cache: 缓存模式，可取: default, no-store, reload, no-cache, force-cache, only-if-cached。</li>
</ul>
<blockquote>
<p>了解详细的信息，请阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch。" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalFetch/fetch。</a></p>
</blockquote>
<p>  在 PWA 应用中，fetch API 的用武之地在于资源（比如图片、脚本文件或样式文件等）的获取。为了能够保证用户的离线体验，我们可以在获取资源时，对资源进行缓存。<br>具体示例如下：</p>
<pre><code>self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // 若缓存不存在，则使用fetch API从网上获取，然后利用Cache API缓存资源。
      return response || fetch(event.request).then((response) => {
          return caches.open('v1').then((cache) => {
            cache.put(event.request, response.clone());
            return response;
          });
     }); 
   })
  );
});</code></pre><p>  对于 Cache API，我们下一篇会介绍。这里需要注意的是，在使用 cache.put() 保存资源时，我们调用 response 对象的 clone() 方法，而不是直接保存 response 对象。为什么需要克隆响应对象呢？这是因为 Request 和 Response 的 body （响应体）只能被读取一次！它们有一个属性叫 bodyUsed，读取一次之后设置为 true，就不能再读取了。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>本文只是简单介绍了 fetch API，其实 fetch API 还有很多东西需要进一步了解，如设置请求头、处理 Text/HTML 资源、表单提交、Cookies 与 CORS 处理等。这里就不再展开了，有兴趣的小伙伴，请自行查阅相关资料。</p>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫(二)</title>
    <url>/2020/03/21/Py-GovSpace-01/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="国家统计局统计用区划代码和城乡划分代码爬虫-二-–实现"><a href="#国家统计局统计用区划代码和城乡划分代码爬虫-二-–实现" class="headerlink" title="国家统计局统计用区划代码和城乡划分代码爬虫 (二)–实现"></a>国家统计局统计用区划代码和城乡划分代码爬虫 (二)–实现</h2><p>本文详细分析了国家统计局统计用区划代码和城乡划分代码爬虫的实现过程，这是第二篇，详细分析了爬取全过程。</p>
<h2 id="一、总体思路说明"><a href="#一、总体思路说明" class="headerlink" title="一、总体思路说明"></a>一、总体思路说明</h2><p>首先我定义了一个网页爬取函数，然后依次定义省级代码获取函数、市级代码获取函数、区级代码获取函数、街道代码获取函数、居委会代码获取函数，这些函数都会调用网页爬取函数。其中区级代码获取函数、街道代码获取函数、居委会代码获取函数这三个函数都是多线程实现爬取的。最后我将爬取得到的数据输出为 csv 格式文件。</p>
<h3 id="1、库函数导入"><a href="#1、库函数导入" class="headerlink" title="1、库函数导入"></a>1、库函数导入</h3><pre><code class="python">import requests
from lxml import etree
import csv
import time
import pandas as pd
from queue import Queue
from threading import Thread
from fake_useragent import UserAgent</code></pre>
<h3 id="2、网页爬取函数"><a href="#2、网页爬取函数" class="headerlink" title="2、网页爬取函数"></a>2、网页爬取函数</h3><pre><code class="python"># 下面加入了num_retries这个参数，经过测试网络正常一般最多retry一次就能获得结果
def getUrl(url,num_retries = 5):
    ua = UserAgent()
    headers = {'User-Agent':ua.random}
    try:
        response = requests.get(url,headers = headers)
        response.encoding = response.apparent_encoding
        data = response.text
        return data
    except Exception as e:
        if num_retries > 0:
            time.sleep(10)
            print(url)
            print("requests fail, retry!")
            return getUrl(url,num_retries-1) #递归调用
        else:
            print("retry fail!")
            print("error: %s" % e + " " + url)
            return #返回空值，程序运行报错</code></pre>
<h3 id="3、获取省级代码函数"><a href="#3、获取省级代码函数" class="headerlink" title="3、获取省级代码函数"></a>3、获取省级代码函数</h3><pre><code class="python">def getProvince(url):
    province = []
    data = getUrl(url)
    selector = etree.HTML(data)
    provinceList = selector.xpath('//tr[@class="provincetr"]')
    for i in provinceList:
        provinceName = i.xpath('td/a/text()') #这里如果采用//a/text()路径会出现问题！！
        provinceLink = i.xpath('td/a/@href')
        for j in range(len(provinceLink)):
            provinceURL = url[:-10] + provinceLink[j] #根据获取到的每个省的链接进行补全，得到真实的URL。
            province.append({'name':provinceName[j],'link':provinceURL})
    return province
pro = getProvince("http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html")
df_province = pd.DataFrame(pro)
df_province['link']
0     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
1     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
2     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
3     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
4     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
5     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
6     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
7     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
8     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
9     http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
10    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
11    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
12    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
13    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
14    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
15    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
16    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
17    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
18    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
19    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
20    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
21    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
22    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
23    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
24    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
25    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
26    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
27    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
28    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
29    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
30    http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf...
Name: link, dtype: object</code></pre>
<h4 id="信息写入-csv-文件"><a href="#信息写入-csv-文件" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_province.to_csv('province.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="4、获取市级代码函数"><a href="#4、获取市级代码函数" class="headerlink" title="4、获取市级代码函数"></a>4、获取市级代码函数</h3><pre><code class="python">def getCity(url_list):
    city_all = []
    for url in url_list:
        data = getUrl(url)
        selector = etree.HTML(data)
        cityList = selector.xpath('//tr[@class="citytr"]')
        #下面是抓取每一个城市的代码、URL
        city = []
        for i in cityList:
            cityCode = i.xpath('td[1]/a/text()')
            cityLink = i.xpath('td[1]/a/@href')
            cityName = i.xpath('td[2]/a/text()')
            for j in range(len(cityLink)):
                cityURL = url[:-7] + cityLink[j]
                city.append({'name':cityName[j],'code':cityCode[j],'link':cityURL})
        city_all.extend(city) #所有省的城市信息合并在一起
    return city_all
city = getCity(df_province['link'])
df_city = pd.DataFrame(city)
df_city</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">110100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">市辖区</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">120100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">市辖区</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石家庄市</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">唐山市</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">秦皇岛市</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">邯郸市</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">邢台市</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">保定市</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">张家口市</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">承德市</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沧州市</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">131000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">廊坊市</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">131100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">衡水市</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">139000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">省直辖县级行政区划</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">140100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">太原市</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">140200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">大同市</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">140300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阳泉市</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">140400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">长治市</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">140500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">晋城市</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">140600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">朔州市</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">140700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">晋中市</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">140800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">运城市</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">140900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">忻州市</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">141000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">临汾市</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">141100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吕梁市</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">150100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">呼和浩特市</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">150200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">包头市</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">150300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌海市</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">150400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">赤峰市</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">150500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">通辽市</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">314</td>
<td align="left">622900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">临夏回族自治州</td>
</tr>
<tr>
<td align="left">315</td>
<td align="left">623000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">甘南藏族自治州</td>
</tr>
<tr>
<td align="left">316</td>
<td align="left">630100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">西宁市</td>
</tr>
<tr>
<td align="left">317</td>
<td align="left">630200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海东市</td>
</tr>
<tr>
<td align="left">318</td>
<td align="left">632200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海北藏族自治州</td>
</tr>
<tr>
<td align="left">319</td>
<td align="left">632300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">黄南藏族自治州</td>
</tr>
<tr>
<td align="left">320</td>
<td align="left">632500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海南藏族自治州</td>
</tr>
<tr>
<td align="left">321</td>
<td align="left">632600000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">果洛藏族自治州</td>
</tr>
<tr>
<td align="left">322</td>
<td align="left">632700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">玉树藏族自治州</td>
</tr>
<tr>
<td align="left">323</td>
<td align="left">632800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">海西蒙古族藏族自治州</td>
</tr>
<tr>
<td align="left">324</td>
<td align="left">640100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">银川市</td>
</tr>
<tr>
<td align="left">325</td>
<td align="left">640200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石嘴山市</td>
</tr>
<tr>
<td align="left">326</td>
<td align="left">640300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吴忠市</td>
</tr>
<tr>
<td align="left">327</td>
<td align="left">640400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">固原市</td>
</tr>
<tr>
<td align="left">328</td>
<td align="left">640500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">中卫市</td>
</tr>
<tr>
<td align="left">329</td>
<td align="left">650100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌鲁木齐市</td>
</tr>
<tr>
<td align="left">330</td>
<td align="left">650200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">克拉玛依市</td>
</tr>
<tr>
<td align="left">331</td>
<td align="left">650400000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吐鲁番市</td>
</tr>
<tr>
<td align="left">332</td>
<td align="left">650500000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">哈密市</td>
</tr>
<tr>
<td align="left">333</td>
<td align="left">652300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">昌吉回族自治州</td>
</tr>
<tr>
<td align="left">334</td>
<td align="left">652700000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">博尔塔拉蒙古自治州</td>
</tr>
<tr>
<td align="left">335</td>
<td align="left">652800000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴音郭楞蒙古自治州</td>
</tr>
<tr>
<td align="left">336</td>
<td align="left">652900000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏地区</td>
</tr>
<tr>
<td align="left">337</td>
<td align="left">653000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">克孜勒苏柯尔克孜自治州</td>
</tr>
<tr>
<td align="left">338</td>
<td align="left">653100000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">喀什地区</td>
</tr>
<tr>
<td align="left">339</td>
<td align="left">653200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">和田地区</td>
</tr>
<tr>
<td align="left">340</td>
<td align="left">654000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">伊犁哈萨克自治州</td>
</tr>
<tr>
<td align="left">341</td>
<td align="left">654200000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔城地区</td>
</tr>
<tr>
<td align="left">342</td>
<td align="left">654300000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿勒泰地区</td>
</tr>
<tr>
<td align="left">343</td>
<td align="left">659000000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">自治区直辖县级行政区划</td>
</tr>
</tbody></table>
<h4 id="信息写入-csv-文件-1"><a href="#信息写入-csv-文件-1" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_city.to_csv('city.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="5、获取区级代码函数-—-多线程实现"><a href="#5、获取区级代码函数-—-多线程实现" class="headerlink" title="5、获取区级代码函数 — 多线程实现"></a>5、获取区级代码函数 — 多线程实现</h3><pre><code class="python">def getCounty(url_list):
    queue_county = Queue() #队列
    thread_num = 10 #进程数
    county = [] #记录区级信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_county.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_county.empty(): # 保证url遍历结束后能退出线程
            url = queue_county.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            countyList = selector.xpath('//tr[@class="countytr"]')
            #下面是爬取每个区的代码、URL
            for i in countyList:
                countyCode = i.xpath('td[1]/a/text()')
                countyLink = i.xpath('td[1]/a/@href')
                countyName = i.xpath('td[2]/a/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(countyLink)):
                    countyURL = url[:-9] + countyLink[j]
                    county.append({'code':countyCode[j],'link':countyURL,'name':countyName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return county
county = getCounty(df_city['link'])
df_county = pd.DataFrame(county)
df_county</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">130702000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">桥东区</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">130703000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">桥西区</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130705000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">宣化区</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130706000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">下花园区</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130708000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">万全区</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130709000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">崇礼区</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130722000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">张北县</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130723000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">康保县</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130724000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沽源县</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130725000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">尚义县</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130726000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">蔚县</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">130727000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阳原县</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">130602000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">竞秀区</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">130606000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">莲池区</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">130607000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">满城区</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">130608000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">清苑区</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">130609000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">徐水区</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">130623000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞水县</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">130624000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阜平县</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">130626000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定兴县</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">130627000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">唐县</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">130628000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">高阳县</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">130629000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">容城县</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">130630000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞源县</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">130631000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">望都县</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">130632000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">安新县</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">130633000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">易县</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">130634000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">曲阳县</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">130635000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">蠡县</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">130636000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">顺平县</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2822</td>
<td align="left">653128000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">岳普湖县</td>
</tr>
<tr>
<td align="left">2823</td>
<td align="left">653129000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">伽师县</td>
</tr>
<tr>
<td align="left">2824</td>
<td align="left">654221000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">额敏县</td>
</tr>
<tr>
<td align="left">2825</td>
<td align="left">652901000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏市</td>
</tr>
<tr>
<td align="left">2826</td>
<td align="left">654223000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙湾县</td>
</tr>
<tr>
<td align="left">2827</td>
<td align="left">652922000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">温宿县</td>
</tr>
<tr>
<td align="left">2828</td>
<td align="left">653130000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴楚县</td>
</tr>
<tr>
<td align="left">2829</td>
<td align="left">654224000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">托里县</td>
</tr>
<tr>
<td align="left">2830</td>
<td align="left">652923000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">库车县</td>
</tr>
<tr>
<td align="left">2831</td>
<td align="left">654225000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">裕民县</td>
</tr>
<tr>
<td align="left">2832</td>
<td align="left">653131000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔什库尔干塔吉克自治县</td>
</tr>
<tr>
<td align="left">2833</td>
<td align="left">654226000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">和布克赛尔蒙古自治县</td>
</tr>
<tr>
<td align="left">2834</td>
<td align="left">652924000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙雅县</td>
</tr>
<tr>
<td align="left">2835</td>
<td align="left">652925000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">新和县</td>
</tr>
<tr>
<td align="left">2836</td>
<td align="left">652926000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">拜城县</td>
</tr>
<tr>
<td align="left">2837</td>
<td align="left">652927000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌什县</td>
</tr>
<tr>
<td align="left">2838</td>
<td align="left">652928000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿瓦提县</td>
</tr>
<tr>
<td align="left">2839</td>
<td align="left">652929000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">柯坪县</td>
</tr>
<tr>
<td align="left">2840</td>
<td align="left">659001000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">石河子市</td>
</tr>
<tr>
<td align="left">2841</td>
<td align="left">659002000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿拉尔市</td>
</tr>
<tr>
<td align="left">2842</td>
<td align="left">659003000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">图木舒克市</td>
</tr>
<tr>
<td align="left">2843</td>
<td align="left">659004000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">五家渠市</td>
</tr>
<tr>
<td align="left">2844</td>
<td align="left">659006000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">铁门关市</td>
</tr>
<tr>
<td align="left">2845</td>
<td align="left">654301000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿勒泰市</td>
</tr>
<tr>
<td align="left">2846</td>
<td align="left">654321000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">布尔津县</td>
</tr>
<tr>
<td align="left">2847</td>
<td align="left">654322000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">富蕴县</td>
</tr>
<tr>
<td align="left">2848</td>
<td align="left">654323000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">福海县</td>
</tr>
<tr>
<td align="left">2849</td>
<td align="left">654324000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">哈巴河县</td>
</tr>
<tr>
<td align="left">2850</td>
<td align="left">654325000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">青河县</td>
</tr>
<tr>
<td align="left">2851</td>
<td align="left">654326000000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">吉木乃县</td>
</tr>
</tbody></table>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照区代码进行 “升序” 排序。</p>
<pre><code class="python">df_county_sorted = df_county.sort_values(by = ['code']) #按1列进行升序排序</code></pre>
<h4 id="信息写入-csv-文件-2"><a href="#信息写入-csv-文件-2" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_county_sorted.to_csv('county.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="6、获取街道代码函数-—-多线程实现"><a href="#6、获取街道代码函数-—-多线程实现" class="headerlink" title="6、获取街道代码函数 — 多线程实现"></a>6、获取街道代码函数 — 多线程实现</h3><pre><code class="python">def getTown(url_list):
    queue_town = Queue() #队列
    thread_num = 50 #进程数
    town = [] #记录街道信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_town.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_town.empty(): # 保证url遍历结束后能退出线程
            url = queue_town.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            townList = selector.xpath('//tr[@class="towntr"]')
            #下面是爬取每个区的代码、URL
            for i in townList:
                townCode = i.xpath('td[1]/a/text()')
                townLink = i.xpath('td[1]/a/@href')
                townName = i.xpath('td[2]/a/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(townLink)):
                    townURL = url[:-11] + townLink[j]
                    town.append({'code':townCode[j],'link':townURL,'name':townName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return town
town = getTown(df_county['link'])
df_town = pd.DataFrame(town)
df_town</code></pre>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">code</th>
<th align="left">link</th>
<th align="left">name</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">130706001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城镇街道办事处</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">130706002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">煤矿街道办事处</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">130706200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">花园乡</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">130706201000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">辛庄子乡</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">130706202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定方水乡</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">130706203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">段家堡乡</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">130702001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">红旗楼街道办事处</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">130702002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">胜利北路街道办事处</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">130702003000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">五一路街道办事处</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">130702004000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">花园街街道办事处</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">130702005000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">工业路街道办事处</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">130702101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">姚家庄镇</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">130623001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城区社区管理办公室街道办事处</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">130624100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阜平镇</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">130624101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">龙泉关镇</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">130626100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">定兴镇</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">130623100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">涞水镇</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">130624102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平阳镇</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">130624103000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">城南庄镇</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">130624104000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">天生桥镇</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">130624105000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">王林口镇</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">130624202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">台峪乡</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">130624203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">大台乡</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">130624204000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">史家寨乡</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">130624205000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">砂窝乡</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">130724100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平定堡镇</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">130724101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">小厂镇</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">130724102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">黄盖淖镇</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">130724103000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">九连城镇</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">130724200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">高山堡乡</td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">42532</td>
<td align="left">659002509000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团十六团</td>
</tr>
<tr>
<td align="left">42533</td>
<td align="left">659002511000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师水利水电工程处</td>
</tr>
<tr>
<td align="left">42534</td>
<td align="left">659002512000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师塔里木灌区水利管理处</td>
</tr>
<tr>
<td align="left">42535</td>
<td align="left">659002513000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿拉尔农场</td>
</tr>
<tr>
<td align="left">42536</td>
<td align="left">659002514000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团第一师幸福农场</td>
</tr>
<tr>
<td align="left">42537</td>
<td align="left">659002515000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">中心监狱</td>
</tr>
<tr>
<td align="left">42538</td>
<td align="left">659002516000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团一团</td>
</tr>
<tr>
<td align="left">42539</td>
<td align="left">659002517000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团农一师沙井子水利管理处</td>
</tr>
<tr>
<td align="left">42540</td>
<td align="left">659002518000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">西工业园区管理委员会</td>
</tr>
<tr>
<td align="left">42541</td>
<td align="left">659002519000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团二团</td>
</tr>
<tr>
<td align="left">42542</td>
<td align="left">659002520000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">兵团三团</td>
</tr>
<tr>
<td align="left">42543</td>
<td align="left">522701001000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">广惠街道办事处</td>
</tr>
<tr>
<td align="left">42544</td>
<td align="left">522701002000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">文峰街道办事处</td>
</tr>
<tr>
<td align="left">42545</td>
<td align="left">522701004000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">小围寨街道办事处</td>
</tr>
<tr>
<td align="left">42546</td>
<td align="left">522701005000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">沙包堡街道办事处</td>
</tr>
<tr>
<td align="left">42547</td>
<td align="left">522701006000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">绿茵湖街道办事处</td>
</tr>
<tr>
<td align="left">42548</td>
<td align="left">522701106000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">墨冲镇</td>
</tr>
<tr>
<td align="left">42549</td>
<td align="left">522701107000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">平浪镇</td>
</tr>
<tr>
<td align="left">42550</td>
<td align="left">522701110000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">毛尖镇</td>
</tr>
<tr>
<td align="left">42551</td>
<td align="left">522701111000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">匀东镇</td>
</tr>
<tr>
<td align="left">42552</td>
<td align="left">522701208000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">归兰水族乡</td>
</tr>
<tr>
<td align="left">42553</td>
<td align="left">652928100000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿瓦提镇</td>
</tr>
<tr>
<td align="left">42554</td>
<td align="left">652928101000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">乌鲁却勒镇</td>
</tr>
<tr>
<td align="left">42555</td>
<td align="left">652928102000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">拜什艾日克镇</td>
</tr>
<tr>
<td align="left">42556</td>
<td align="left">652928200000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿依巴格乡</td>
</tr>
<tr>
<td align="left">42557</td>
<td align="left">652928201000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">塔木托格拉克乡</td>
</tr>
<tr>
<td align="left">42558</td>
<td align="left">652928202000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">英艾日克乡</td>
</tr>
<tr>
<td align="left">42559</td>
<td align="left">652928203000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">多浪乡</td>
</tr>
<tr>
<td align="left">42560</td>
<td align="left">652928204000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">巴格托格拉克乡</td>
</tr>
<tr>
<td align="left">42561</td>
<td align="left">652928405000</td>
<td align="left"><a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf" target="_blank" rel="noopener">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhf</a>…</td>
<td align="left">阿克苏监狱</td>
</tr>
</tbody></table>
<h4 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h4><p>由于多线程的关系，数据的顺序已经被打乱，所以这里按照街道代码进行 “升序” 排序。</p>
<pre><code class="python">df_town_sorted = df_town.sort_values(by = ['code']) #按1列进行升序排序</code></pre>
<h4 id="信息写入-csv-文件-3"><a href="#信息写入-csv-文件-3" class="headerlink" title="信息写入 csv 文件"></a>信息写入 csv 文件</h4><pre><code class="python">df_town_sorted.to_csv('town.csv', sep=',', header=True, index=False)</code></pre>
<h3 id="7、获取居委会代码函数-—-多线程实现"><a href="#7、获取居委会代码函数-—-多线程实现" class="headerlink" title="7、获取居委会代码函数 — 多线程实现"></a>7、获取居委会代码函数 — 多线程实现</h3><pre><code class="python">def getVillage(url_list):
    queue_village = Queue() #队列
    thread_num = 200 #进程数
    town = [] #记录街道信息的字典（全局）

    def produce_url(url_list):
        for url in url_list:
            queue_village.put(url) # 生成URL存入队列，等待其他线程提取

    def getData():
        while not queue_village.empty(): # 保证url遍历结束后能退出线程
            url = queue_village.get() # 从队列中获取URL
            data = getUrl(url)
            selector = etree.HTML(data)
            villageList = selector.xpath('//tr[@class="villagetr"]')
            #下面是爬取每个区的代码、URL
            for i in villageList:
                villageCode = i.xpath('td[1]/text()')
                UrbanRuralCode = i.xpath('td[2]/text()')
                villageName = i.xpath('td[3]/text()')
                #上面得到的是列表形式的，下面将其每一个用字典存储
                for j in range(len(villageCode)):
                    town.append({'code':villageCode[j],'UrbanRuralCode':UrbanRuralCode[j],'name':villageName[j]})

    def run(url_list):
        produce_url(url_list)

        ths = []
        for _ in range(thread_num):
            th = Thread(target = getData)
            th.start()
            ths.append(th)
        for th in ths:
            th.join()

    run(url_list)
    return town
village = getVillage(df_town['link'])
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/24/140724204.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/07/27/140727400.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/10/29/141029204.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/04/150104008.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981102.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/02/150102001.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/14/09/81/140981210.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/21/150421202.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/25/150425100.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/22/150422401.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/02/150402402.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/04/30/150430207.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/01/21/150121105.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/07/22/150722105.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/15/25/26/152526103.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/21/210421209.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/04/22/210422108.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502002.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/06/03/210603007.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/02/210502010.html
requests fail, retry!
http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/21/05/03/210503005.html
requests fail, retry!</code></pre>
<p>由于数据量很大，所以这里我没有爬取完毕。</p>
</body></html>]]></content>
      <categories>
        <category>码爬</category>
      </categories>
      <tags>
        <tag>码爬</tag>
      </tags>
  </entry>
  <entry>
    <title>国家统计局统计用区划代码和城乡划分代码爬虫(一)</title>
    <url>/2020/03/21/Py-GovSpace-02/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="国家统计局统计用区划代码和城乡划分代码爬虫-一-–分析"><a href="#国家统计局统计用区划代码和城乡划分代码爬虫-一-–分析" class="headerlink" title="国家统计局统计用区划代码和城乡划分代码爬虫 (一)–分析"></a>国家统计局统计用区划代码和城乡划分代码爬虫 (一)–分析</h2><p>这里我就拿 2016 年的页面做下分析：<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html" target="_blank" rel="noopener">2016 年统计用区划代码和城乡划分代码 (截止 2016 年 07 月 31 日)</a>。</p>
<h2 id="一、省级页面分析"><a href="#一、省级页面分析" class="headerlink" title="一、省级页面分析"></a>一、省级页面分析</h2><h3 id="1、省级信息提取"><a href="#1、省级信息提取" class="headerlink" title="1、省级信息提取"></a>1、省级信息提取</h3><p>我们进入到 <a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html" target="_blank" rel="noopener">2016 年统计用区划代码和城乡划分代码 (截止 2016 年 07 月 31 日)</a> 这个页面，然后用 chrome 的 “检查” 工具看下我们要找的信息在哪。</p>
<p>这里我们需要爬取省级名称、省内市级信息的子链接这两个参数。</p>
<p>我们从图中可以发现，左边页面每一行对应的 XPath 路径为：</p>
<pre><code class="python">//tr[@class="provincetr"]</code></pre>
<p>然后一行中每个省的信息在下一级的 td 标签内：</p>
<pre><code class="python">td/a/text()
td/a/@href</code></pre>
<p><a href="https://tding.top/archives/a4d70246/%E7%9C%81%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="省级页面分析" class="fancybox"><img alt="省级页面分析" title="省级页面分析" data-src="https://tding.top/archives/a4d70246/%E7%9C%81%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取"><a href="#2、下级链接获取" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>省级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html</code></pre>
<p>下级页面的 URL（我这里以<code>浙江省</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html</code></pre>
<p>页面中提取到的信息（我这里以<code>浙江省</code>为例）：</p>
<pre><code class="python">33.html</code></pre>
<p>所以我们可以通过如下方式获取真实的 URL 保存到一个列表中：</p>
<pre><code class="python">url = "http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/index.html"
# provinceLink = "33.html"
provinceURL = url[:-10] + provinceLink</code></pre>
<h2 id="二、市级页面分析"><a href="#二、市级页面分析" class="headerlink" title="二、市级页面分析"></a>二、市级页面分析</h2><h3 id="1、市级信息提取"><a href="#1、市级信息提取" class="headerlink" title="1、市级信息提取"></a>1、市级信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html" target="_blank" rel="noopener">浙江省</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是市级页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%B8%82%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="市级页面分析" class="fancybox"><img alt="市级页面分析" title="市级页面分析" data-src="https://tding.top/archives/a4d70246/%E5%B8%82%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-1"><a href="#2、下级链接获取-1" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>市级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33.html</code></pre>
<p>下级页面的 URL（我这里以<code>杭州市</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html</code></pre>
<p>页面中提取到的信息（我这里以<code>杭州市</code>为例）：</p>
<pre><code class="python">33/3301.html</code></pre>
<h2 id="三、区级页面分析"><a href="#三、区级页面分析" class="headerlink" title="三、区级页面分析"></a>三、区级页面分析</h2><h3 id="1、区级信息提取"><a href="#1、区级信息提取" class="headerlink" title="1、区级信息提取"></a>1、区级信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html" target="_blank" rel="noopener">杭州市</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是区级页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%8C%BA%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="区级页面分析" class="fancybox"><img alt="区级页面分析" title="区级页面分析" data-src="https://tding.top/archives/a4d70246/%E5%8C%BA%E7%BA%A7%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-2"><a href="#2、下级链接获取-2" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>区级页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/3301.html</code></pre>
<p>下级页面的 URL（我这里以<code>上城区</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html</code></pre>
<p>页面中提取到的信息（我这里以<code>上城区</code>为例）：</p>
<pre><code class="python">01/330102.html</code></pre>
<h2 id="四、街道页面分析"><a href="#四、街道页面分析" class="headerlink" title="四、街道页面分析"></a>四、街道页面分析</h2><h3 id="1、街道信息提取"><a href="#1、街道信息提取" class="headerlink" title="1、街道信息提取"></a>1、街道信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html" target="_blank" rel="noopener">上城区</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是街道页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E8%A1%97%E9%81%93%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="街道页面分析" class="fancybox"><img alt="街道页面分析" title="街道页面分析" data-src="https://tding.top/archives/a4d70246/%E8%A1%97%E9%81%93%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<h3 id="2、下级链接获取-3"><a href="#2、下级链接获取-3" class="headerlink" title="2、下级链接获取"></a>2、下级链接获取</h3><p>街道页面的 URL：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/330102.html</code></pre>
<p>街道页面的 URL（我这里以<code>湖滨街道</code>为例）：</p>
<pre><code class="python">http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html</code></pre>
<p>页面中提取到的信息（我这里以<code>湖滨街道</code>为例）：</p>
<pre><code class="python">02/330102003.html</code></pre>
<h2 id="五、居委会页面分析"><a href="#五、居委会页面分析" class="headerlink" title="五、居委会页面分析"></a>五、居委会页面分析</h2><h3 id="1、居委会信息提取"><a href="#1、居委会信息提取" class="headerlink" title="1、居委会信息提取"></a>1、居委会信息提取</h3><p>我们进入到<a href="http://www.stats.gov.cn/tjsj/tjbz/tjyqhdmhcxhfdm/2016/33/01/02/330102003.html" target="_blank" rel="noopener">湖滨街道</a>中。具体的分析跟上面的省级页面分析类似，不再赘述。下面是居委会页面分析图：</p>
<p><a href="https://tding.top/archives/a4d70246/%E5%B1%85%E5%A7%94%E4%BC%9A%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" data-fancybox="group" data-caption="居委会页面分析" class="fancybox"><img alt="居委会页面分析" title="居委会页面分析" data-src="https://tding.top/archives/a4d70246/%E5%B1%85%E5%A7%94%E4%BC%9A%E9%A1%B5%E9%9D%A2%E5%88%86%E6%9E%90.png" class="lazyload"></a></p>
<p>这里已经到了最底层，没有下级链接了。</p>
</body></html>]]></content>
      <categories>
        <category>码爬</category>
      </categories>
      <tags>
        <tag>码爬</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjs中的Subjects</title>
    <url>/2020/03/01/Rxjs-Subjects/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>#彻底搞懂RxJS中的Subjects</p>
<p>  每周大约有1700万次npm下载，RxJS在JavaScript世界中非常受欢迎。如果您是Angular开发人员，则不会错过RxJS Observables，但您可能对Subjects不太熟悉。虽然它们不像简单的Observable被频繁使用，但还是非常有用的。了解它们将帮助我们编写更好，更简洁的响应式代码。</p>
<h2 id="Observables"><a href="#Observables" class="headerlink" title="Observables"></a>Observables</h2><blockquote>
<p>直观地，我们可以将Observables视为发出值流的对象，或者按照RxJS文档所述：Observables是多个值的惰性Push集合。</p>
</blockquote>
<p>例如，我们可以使用Observables每秒发出0到59之间的数字：</p>
<pre><code>import { Observable } from 'rxjs';
const observable = new Observable((subscriber) => {
  for (let i = 0; i < 60; i += 1) {
    setTimeout(() => {
      subscriber.next(i);
    }, i * 1000);
  }
});
observable.subscribe((value) => {
  console.log(`Observer receives: ${value}`);
});</code></pre><p>  需要订阅Observable才能开始计数，这与调用函数的方式相同。同样类似于函数，第二个”调用”将触发新的独立执行。如果两秒钟后再次订阅此Observable，我们将在控制台中看到两个”计数器”，第二个计数器有两秒钟的延迟。</p>
<pre><code>import { Observable } from 'rxjs';

const observable = new Observable((subscriber) => {
  for (let i = 0; i < 60; i += 1) {
    setTimeout(() => {
      subscriber.next(i);
    }, i * 1000);
  }
});

console.log('First observer subscribes');
observable.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  observable.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);</code></pre><p>  这意味着我们不能同时向两个观察者发出相同的值，至少不能使用简单的Observable。因此，需要Subject。</p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><blockquote>
<p>Subject就像一个可观察对象，但是可以多播到许多观察者。</p>
</blockquote>
<p>  Subject也是可观察的。我们可以使用Subject创建每秒发射0到59的相同计数器：</p>
<pre><code>import { Subject } from 'rxjs';

const subject = new Subject();

console.log('Observer subscribes');
subject.subscribe((value) => {
  console.log(`Observer receives: ${value}`);
});

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    subject.next(i);
  }, i * 1000);
}</code></pre><p>  您可能会发现我们之前的示例的主要区别。在声明一个Observable时，我们提供了一个函数作为参数，告诉Observable向用户发出什么。可以，因为每个新订户都将开始新的执行。另一方面，在这种情况下，我们只有一个执行，而新订户只是开始“监听”它。我们只需使用new Subject（）创建一个新对象。<br>  我们也可以订阅主题，因为主题是可观察的。然后，我们直接调用主题，因为主题是观察者。<br>  任何新订户将被添加到主题在内部保留的订户列表中，并且同时将获得与其他订户相同的值。如果我们在第一次订阅后两秒钟订阅主题，则新订阅者将错过前两个值：</p>
<pre><code>import { Subject } from 'rxjs';

const subject = new Subject();

console.log('First observer subscribes');
subject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  subject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    subject.next(i);
  }, i * 1000);
}</code></pre><p>我们可以使用Subject一次向多个观察者发出值。</p>
<h2 id="BehaviorSubject"><a href="#BehaviorSubject" class="headerlink" title="BehaviorSubject"></a>BehaviorSubject</h2><p>  Subject可能存在的问题是，观察者将仅收到订阅主题后发出的值。<br>在上一个示例中，第二个发射器未接收到值0、1和2。有时，我们需要在订阅该对象之前，知道该对象最后一次发射了哪个值。例如，如果我们发出日期，情况就是这样。任何在3月1日订阅的观察者，无论何时订阅，都将获得3月1日的订阅。在午夜，每个订阅者都会收到日期已更改的通知。<br>  对于这种情况，可以使用BehaviorSubject。BehaviorSubject保留其发出的最后一个值的内存。订阅后，观察者立即接收到最后发出的值。如果我们改编前面的示例，这意味着第二个观察者在订阅时收到值2，然后像第一个观察者一样接收之后的所有其他值。</p>
<pre><code>import { BehaviorSubject } from 'rxjs';

const behaviorSubject = new BehaviorSubject(0);

for (let i = 1; i < 60; i += 1) {
  setTimeout(() => {
    behaviorSubject.next(i);
  }, i * 1000);
}

console.log('First observer subscribes');
behaviorSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  behaviorSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);</code></pre><p>  您可能已经在示例中注意到，我们需要为BehaviorSubject提供一个初始值，而Subject则不需要。这是因为BehaviorSubject始终需要当前值。</p>
<h2 id="ReplaySubject"><a href="#ReplaySubject" class="headerlink" title="ReplaySubject"></a>ReplaySubject</h2><p>  ReplaySubjects与BehaviorSubjects非常相似。所不同的是，他们不仅记住了最后一个值，还记住了之前发出的多个值。订阅后，它们会将所有记住的值发送给新观察者。<br>在创建时不给它们任何初始值，而是定义它们应在内存中保留多少个值。在示例中，我们保留两个值：</p>
<pre><code>import { ReplaySubject } from 'rxjs';

const replaySubject = new ReplaySubject(2);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    replaySubject.next(i);
  }, i * 1000);
}

console.log('First observer subscribes');
replaySubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
    replaySubject.subscribe((value) => {
      console.log(`Second observer receives: ${value}`);
    });
}, 2000);</code></pre><p>  当第二个观察者订阅ReplaySubject时，已经发出0、1和2。由于ReplaySubject保留了最后两个值，第二个观察者立即收到1和2。</p>
<h2 id="AsyncSubject"><a href="#AsyncSubject" class="headerlink" title="AsyncSubject"></a>AsyncSubject</h2><p>  使用AsyncSubjects，在主题完成之前，观察者实际上什么也没收到。</p>
<pre><code>import { AsyncSubject } from 'rxjs';

const asyncSubject = new AsyncSubject();

console.log('First observer subscribes');
asyncSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    asyncSubject.next(i);
    if (i === 59 ) {
      asyncSubject.complete();
    }
  }, i * 1000);
}</code></pre><p>  在我们的示例中使用AsyncSubject，我们必须等待一分钟，然后观察者才能收到东西。<br>  我们必须完成主题。如果不这样做，我们的观察者将一无所获。<br>  在AsyncSubject完成后订阅的任何观察者将收到相同的值。</p>
<pre><code>import { AsyncSubject } from 'rxjs';

const asyncSubject = new AsyncSubject();

console.log('First observer subscribes');
asyncSubject.subscribe((value) => {
  console.log(`First observer receives: ${value}`);
});

setTimeout(() => {
  console.log('Second observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Second observer receives: ${value}`);
  });
}, 2000);

for (let i = 0; i < 60; i += 1) {
  setTimeout(() => {
    asyncSubject.next(i);
    if (i === 59 ) {
      asyncSubject.complete();
    }
  }, i * 1000);
}

setTimeout(() => {
  console.log('Third observer subscribes');
  asyncSubject.subscribe((value) => {
    console.log(`Third observer receives: ${value}`);
  });
}, 65000);</code></pre><p>  在此示例中，第三个观察者在AsyncSubject完成五秒钟后对其进行订阅。订阅时，它将收到最后一个值：59。<br>  这使得AsyncSubjects对于获取和缓存值很有用，例如HTTP响应，我们只希望获取一次，但是以后可以从其他位置进行访问。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>  自己尝试这些示例并对其进行修改，以了解其如何影响结果。对RxJS主题的深入了解将有助于我们在响应式编程方面编写更具可读性和更高效的代码。</p>
</body></html>]]></content>
      <categories>
        <category>Rxjs</category>
      </categories>
      <tags>
        <tag>Rxjs</tag>
        <tag>Subjects</tag>
        <tag>Angular</tag>
        <tag>响应式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>舒适访问对象深层次属性~</title>
    <url>/2020/03/24/TypeScript-GetObjectPrpos/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="舒适访问对象深层次属性"><a href="#舒适访问对象深层次属性" class="headerlink" title="舒适访问对象深层次属性~"></a>舒适访问对象深层次属性~</h2><h3 id="一、黑暗时代"><a href="#一、黑暗时代" class="headerlink" title="一、黑暗时代"></a>一、黑暗时代</h3><p>​        在前后端分离的系统中，前端页面一般通过调用 REST API 来获取服务端提供的与页面相关的数据。这里我们以获取用户基本信息的接口为例，假设该接口会返回以下数据：</p>
<pre><code>const apiResult = {
  code: 200,
  data: {
    name: "Semlinker",
    age: 30,
    address: {
      province: '福建',
      city: '厦门'
    }
  }
}</code></pre><p>如果页面中需要显示当前用户的地址信息，比如省、市信息。这时就可以通过以下方式来获取：</p>
<pre><code>const province = apiResult.data.address.province; // 福建
const city = apiResult.data.address.city; // 厦门</code></pre><p>上面的数据访问方式很直观，就是一层层的进行数据访问。然而这种方式会存在很大的隐患，比如有的用户可能未设置地址信息，那么这时候的返回的数据结构就可能是这样的：</p>
<pre><code>const apiResult = {
  code: 200,
  data: {
    name: "Semlinker",
    age: 30
  }
}</code></pre><p>这时如果我们还是使用 <code>apiResult.data.address.province</code> 的方式来访问 <code>province</code> 省份信息，页面就会抛出以下异常信息：</p>
<pre><code>Uncaught TypeError: Cannot read property 'province' of undefined</code></pre><p>针对这个问题，我们有以下几种解决方案：</p>
<p><strong>方案一：</strong></p>
<pre><code>const province =
  apiResult &&
  apiResult.data &&
  apiResult.data.address &&
  apiResult.data.address.province;</code></pre><p><strong>方案二：</strong></p>
<pre><code>const province = !apiResult
  ? undefined
  : !apiResult.data
    ? undefined
    : !apiResult.data.address
      ? undefined
      : apiResult.data.address.province;</code></pre><p><strong>方案三：</strong></p>
<pre><code>let province: string | undefined = undefined;
try {
  province = apiResult.data.address.province;
} catch (error) {
  // 执行异常处理程序
}</code></pre><p><strong>方案四：</strong></p>
<pre><code>import * as _ from 'lodash';
const province = _.get(apiResult, 'data.address.province', undefined);</code></pre><p>通过观察以上几种方案，我们发现处理多级嵌套对象的属性访问时，需要增加很多的判断逻辑，这对于我们开发者来说，是很令人抓狂的事情。值得庆幸的是，在 TypeScript 3.7 以后版本，我们就可以使用可选链（Optional Chaining）来优雅的解决上述问题。</p>
<h3 id="二、什么是可选链"><a href="#二、什么是可选链" class="headerlink" title="二、什么是可选链"></a>二、什么是可选链</h3><p>TypeScript 3.7 实现了呼声最高的 ECMAScript 功能之一：可选链（Optional Chaining）。有了可选链后，我们编写代码时如果遇到 <code>null</code> 或 <code>undefined</code> 就可以立即停止某些表达式的运行。可选链的核心是新的 <code>?.</code> 运算符，它支持以下语法：</p>
<blockquote>
<pre><code>obj?.prop
obj?.[expr]
arr?.[index]
func?.(args)</code></pre></blockquote>
<p>这里我们来举一个可选的属性访问的例子：</p>
<pre><code>const val = a?.b;</code></pre><p>为了更好的理解可选链，我们来看一下该 <code>const val = a?.b</code> 语句编译生成的 ES5 代码：</p>
<pre><code>var val = a === null || a === void 0 ? void 0 : a.b;</code></pre><p>上述的代码会自动检查对象 a 是否为 <code>null</code> 或 <code>undefined</code>，如果是的话就立即返回 <code>undefined</code>，这样就可以立即停止某些表达式的运行。介绍完可选链，前面获取省份的例子，就可以改写成以下方式：</p>
<pre><code>const province = apiResult?.data?.address?.province;</code></pre><p>同样，我们再来看一下该语句生成的 ES5 代码：</p>
<pre><code>var province = (_b = (_a = apiResult === null || apiResult === void 0 ? void 0 :
  apiResult.data) === null || _a === void 0 ? void 0 : _a.address) === null ||
    _b === void 0 ? void 0 : _b.province;</code></pre><p>对比编译前的 TypeScript 代码和编译后的 JavaScript 代码，你是不是感受到了可选链是多么的给力。</p>
<h3 id="三、-与-amp-amp-的区别"><a href="#三、-与-amp-amp-的区别" class="headerlink" title="三、?. 与 && 的区别"></a>三、?. 与 && 的区别</h3><p>你可能已经发现你可以使用 <code>?.</code> 来替代很多使用 <code>&&</code> 执行空检查的代码：</p>
<pre><code>if(a && a.b) { }

if(a?.b){ }
/**
* if(a?.b){ } 编译后的ES5代码
*
* if(
*  a === null || a === void 0
*  ? void 0 : a.b) {
* }
*/</code></pre><p>但需要注意的是，<code>?.</code> 与 <code>&&</code> 运算符行为略有不同，<code>&&</code> 专门用于检测 <code>falsy</code>值，比如空字符串、0、NaN、null 和 false 等。而 <code>?.</code> 只会验证对象是否为<code>null</code> 或 <code>undefined</code>，对于 0 或空字符串来说，并不会出现 “短路”。</p>
<h3 id="四、可选元素访问"><a href="#四、可选元素访问" class="headerlink" title="四、可选元素访问"></a>四、可选元素访问</h3><p>可选链除了支持可选属性的访问之外，它还支持可选元素的访问，它的行为类似于可选属性的访问，只是可选元素的访问允许我们访问非标识符的属性，比如任意字符串、数字索引和 Symbol：</p>
<pre><code>function tryGetArrayElement<t>(arr?: T[], index: number = 0) {
    return arr?.[index];
}</t></code></pre><p>以上代码经过编译后会生成以下 ES5 代码：</p>
<pre><code>function tryGetArrayElement(arr, index) {
    if (index === void 0) { index = 0; }
    return arr === null || arr === void 0 ? void 0 : arr[index];
}</code></pre><p>通过观察生成的 ES5 代码，很明显在 <code>tryGetArrayElement</code> 方法中会自动检测输入参数 arr 的值是否为 <code>null</code> 和 <code>undefined</code>，从而保证了我们代码的健壮性。最后我们来介绍一下可选链与函数调用。</p>
<h3 id="五、可选链与函数调用"><a href="#五、可选链与函数调用" class="headerlink" title="五、可选链与函数调用"></a>五、可选链与函数调用</h3><p>当尝试调用一个可能不存在的方法时也可以使用可选链。在实际开发过程中，这是很有用的。系统中某个方法不可用，有可能是由于版本不一致或者用户设备兼容性问题导致的。函数调用时如果被调用的方法不存在，使用可选链可以使表达式自动返回 <code>undefined</code> 而不是抛出一个异常。</p>
<p>可选调用使用起来也很简单，比如：</p>
<pre><code>let result = obj.customMethod?.();</code></pre><p>该 TypeScript 代码编译生成的 ES5 代码如下：</p>
<pre><code>var result = (_a = obj.customMethod) === null
  || _a === void 0 ? void 0 : _a.call(obj);</code></pre><p>另外在使用可选调用的时候，我们要注意以下两个注意事项：</p>
<ol>
<li>如果存在一个属性名且该属性名对应的值不是函数类型，使用 <code>?.</code> 仍然会产生一个<code>TypeError</code> 异常。</li>
<li>可选链的运算行为被局限在属性的访问、调用以及元素的访问 —— 它不会沿伸到后续的表达式中，也就是说可选调用不会阻止 <code>a?.b / someMethod()</code> 表达式中的除法运算或 <code>someMethod</code> 的方法调用。</li>
</ol>
<h3 id="六、参考资源"><a href="#六、参考资源" class="headerlink" title="六、参考资源"></a>六、参考资源</h3><ul>
<li>Using Optional Chaining in TypeScript and JavaScript</li>
<li>optional-chaining-in-typescript</li>
<li>深入理解 TypeScript</li>
<li>重磅！TypeScript 3.7 RC 发布，备受瞩目的 Optional Chaining 来了</li>
<li>MDN - 可选链</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ts</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>初识微信公众号开发</title>
    <url>/2020/03/21/Wechat-Dev-Sub/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>现如今，微信已经不再只承担着交流沟通、娱乐大众的功能，微信公众号的推出将微信逐渐转变成个人、商家、企业单位用来营销的重要工具。而微信推出的公众号开发功能，为我们码农带来很大的方便，让我们创造出更多的可能性。</p>
<h2 id="第一章：开始开发-准备阶段"><a href="#第一章：开始开发-准备阶段" class="headerlink" title="第一章：开始开发(准备阶段)"></a><strong>第一章：开始开发(准备阶段)</strong></h2><h3 id="1、-接入指南"><a href="#1、-接入指南" class="headerlink" title="1、 接入指南"></a><strong>1、 接入指南</strong></h3><p>接入微信公众平台开发，开发者需要按照如下步骤完成：</p>
<p><strong>·</strong>填写服务器配置</p>
<p><a href="./wechat-01.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-01.png" class="lazyload"></a></p>
<p><em>说明：URL是开发者用来接收微信消息和事件的接口URL，该接口尽量写成两个请求方式，1:get请求，用于验证如下地址有效性，2:post请求, 用于接收消息和事件，Token 可以随便定义用于验证接口签名有效性, EncodingAESKey是加密的密钥，下面加密方式选兼容模式或者安全模式的时候开发者可根据该密钥对数据进行加解密</em></p>
<p><strong>·</strong>验证如上URL服务器地址的有效性</p>
<p>根据官方文档的说明，微信验证接口会带下面几个参数</p>
<p><a href="./wechat-02.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-02.png" class="lazyload"></a></p>
<p>端接口接收到这些参数后进行签名验证，如下代码：</p>
<pre><code class="js">exports.check = function (req, res, next) {
// 在这里验证签名
var signature = req.query['signature'],
timestamp = req.query['timestamp'],
nonce = req.query['nonce'],
echostr = req.query['echostr'];
var sha1 = crypto.createHash('sha1'),
sha1Str = sha1.update([config.weixin.token, timestamp, nonce].sort().join('')).digest('hex');
res.writeHead(200, {'Content-Type': 'text/plain'});
res.end((sha1Str === signature) ? echostr : '');
return res;
};</code></pre>
<p><strong>·</strong>依据接口文档实现业务逻辑</p>
<p>这里就是根据业务需求，进行接口调用的编程了，下面我会一一介绍</p>
<h3 id="2、获取access-token"><a href="#2、获取access-token" class="headerlink" title="2、获取access_token"></a><strong>2、获取access_token</strong></h3><p> access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。该接口一天只能请求2000次，开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p>如下代码事例：</p>
<pre><code class="js">exports.get_token = function (fn) {
redis.get(weixin_token, function (err, token_str) {
if (token_str) {
return fn(err, JSON.parse(token_str));
} else {
request.get("https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=" + app_id + "&secret=" + app_secret, function (err, response, body) {
if (JSON.parse(body).errcode == 45009) {
return fn(err)
} else {
redis.set(weixin_token, body, function (err) {
redis.expire(weixin_token, 7000, function () {
return fn(err, JSON.parse(body));
};</code></pre>
<p>上面的事例代码中，首先我会从redis中获取到access_token，因为我最初获取access_token的时候写入到redis中了，官方给的有效时间是7200秒，我放在redis中的有效时间是7000秒，所以我这里的token不会过期，过期后会重新调用接口获取并写入redis</p>
<h2 id="第二章：自定义菜单"><a href="#第二章：自定义菜单" class="headerlink" title="第二章：自定义菜单"></a><strong>第二章：自定义菜单</strong></h2><p>实例代码中只写入创建接口的调用，查询和删除就不举例了。</p>
<h3 id="·1、自定义菜单创建接口"><a href="#·1、自定义菜单创建接口" class="headerlink" title="·1、自定义菜单创建接口"></a>·<strong>1、自定义菜单创建接口</strong></h3><p>如下代码事例以及说明：</p>
<pre><code class="js">get_token(function(err, obj){
var access_token = obj.access_token;
request.post({
url: "https://api.weixin.qq.com/cgi-bin/menu/create?access_token=" + access_token,
json: {
"button":[
{
"type":"view",
"name":"工作台",
"url":"http://worktile.com"
},
{
"name":"解决方案",
"sub_button": [
{
"type":"view",
"name":"研发",
"url":"https://pro.worktile.com/solution/dev"
}
{
"type":"view",
"name":"最佳实践",
"url":"https://worktile.com/can"
}
{
"name":"更多",
"sub_button":[
{
"type":"view",
"name":"下载应用",
"url":"http://a.app.qq.com/o/simple.jsp?pkgname=com.worktile"
},
{
"type":"click",
"name":"合作",
"key":"work_together"
}]
}, function(err, res, body){
console.log(body)
})

</code></pre>
<p>这里get_token方法就是上面第一章中＃获取access_token ，而且我这里是作为脚本执行的，这样方便以后随便修改自定义菜单内容</p>
<h3 id="2、自定义菜单查询接口"><a href="#2、自定义菜单查询接口" class="headerlink" title="2、自定义菜单查询接口"></a>2、自定义菜单查询接口</h3><p>http请求方式：GET</p>
<p><a href="https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/menu/get?access_token=ACCESS_TOKEN</a></p>
<h3 id="3、自定义菜单删除接口"><a href="#3、自定义菜单删除接口" class="headerlink" title="**3、自定义菜单删除接口"></a>**3、自定义菜单删除接口</h3><p>http请求方式：GET</p>
<p><a href="https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/menu/delete?access_token=ACCESS_TOKEN</a></p>
<h2 id="第三章：消息管理"><a href="#第三章：消息管理" class="headerlink" title="第三章：消息管理"></a><strong>第三章：消息管理</strong></h2><h3 id="1、接收消息"><a href="#1、接收消息" class="headerlink" title="1、接收消息"></a>1、接收消息</h3><p>接收的消息分为普通消息和事件消息，统一有第一章中接入指南填写的RUL接口来接收处理</p>
<blockquote>
<p>微信消息里面消息的接收和返回都是已XMl格式交互的</p>
</blockquote>
<pre><code class="js">exports.receive = function (req, res, next) {
// 在这接收消息
var xml = '';
req.setEncoding('utf8');
req.on('data', function (chunk) {
xml += chunk;
});
req.on('end', function () {
toJSON(xml, res);
});

};</code></pre>
<p>说明：receive方法就是接收用户发给公众号的消息，内容格式是xml，toJSON就是我解析xml为json的方法，如下</p>
<blockquote>
<p>xml转换json可以运用第三方工具库“xml2json”快捷进行转换</p>
</blockquote>
<pre><code class="js">//解析器
var toJSON = function (xml, res) {
var msg = {};
xml2js.parseString(xml, function (err, result) {
var data = result.xml;
msg.ToUserName = data.ToUserName[0];
msg.FromUserName = data.FromUserName[0];
msg.CreateTime = data.CreateTime[0];
msg.MsgType = data.MsgType[0];
switch (msg.MsgType) {
case 'text' :
    msg.Content = data.Content[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
    return handle_text(msg, res);
break;
case 'image' :
    msg.PicUrl = data.PicUrl[0];
    msg.MsgId = data.MsgId[0];
    msg.MediaId = data.MediaId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'voice' :
    msg.MediaId = data.MediaId[0];
    msg.Format = data.Format[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;

case 'video' :
    msg.MediaId = data.MediaId[0];
    msg.ThumbMediaId = data.ThumbMediaId[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'location' :
    msg.Location_X = data.Location_X[0];
    msg.Location_Y = data.Location_Y[0];
    msg.Scale = data.Scale[0];
    msg.Label = data.Label[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'link' :
    msg.Title = data.Title[0];
    msg.Description = data.Description[0];
    msg.Url = data.Url[0];
    msg.MsgId = data.MsgId[0];
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
case 'event' :
    msg.Event = data.Event[0];
    if (data.EventKey && _.isArray(data.EventKey) && data.EventKey.length > 0) {
        msg.EventKey = data.EventKey[0];
        return handle_event(msg, res);
    }
    res.setHeader("Content-Type", "text/plain");
    res.send("");
break;
}
});
};</code></pre>
<p><em>说明：这里我用户发过来的消息xml解释称json数据msg, 根据不同的类型做不同的处理，如上文本，图片，音频，视频，链接，事件等消息</em></p>
<pre><code class="js">var handle_text = function (msg, res) {
var text = msg.Content;
if(text.trim() == "研发"){
    var data = {
    "touser":msg.FromUserName,
    "msgtype":"news",
    "news":{
    "articles": [
    {
    "title":"重磅！Worktile 推出研发管理解决方案",
    "description":"项目进度清晰掌握，快速跟进产品Bug，多维度统计报表，文件文档有序管理",
    "url":"https://pro.worktile.com/solution/dev",
    "picurl":"https://wt-prj.oss.aliyuncs.com/b327e3a5666048279583e8e026ac6b87/4bb6e53c-8516-4466-b278-4f3b596e46db.png"
    sendMessageToUser(data);
}else if(text.trim() == "电商"){
    var data = {
    "touser":msg.FromUserName,
    "msgtype":"news",
    "news":{},
    "articles": [
    {
    "title":"Worktile 『电商解决方案』上线！",
    "description":"降低运营成本，提高团队效率。日常运营、大促筹备、售后跟踪、研发管理……尽在掌握。",
    "url":"https://pro.worktile.com/solution/ecommerce",
    "picurl":"https://cdn.worktile.com/solution/ecommerce.png"
    }]
    sendMessageToUser(data);
}
*说明：这是对文本消息的处理，如上，如果接收到 研发 字样的消息，公众号会给该用户发送一条新闻消息*

var handle_event = function (msg, res) {
    console.log("weixin receive message ===", msg)
if (msg.Event == 'CLICK' && msg.EventKey == 'work_together') {
    var text = "Hello，谢谢对 Worktile 的关注啦，请访问worktile官方网站了解。。。。。";
    var data = {
        touser : msg.FromUserName,
        msgtype: "text",
        text  : {
        content: text
sendMessageToUser(data);</code></pre>
<p><em>说明：这是对事件消息的处理，如上，如果接收到 msg.Event == ‘CLICK’ && msg.EventKey == ‘work_together’ 事件的消息，公众号会给该用户发送一条文本消息，当然事件消息有很多，如：subscribe关注公众号消息，unsubscribe取消关注，扫描带参数二维码事件，还有如上说的自定义菜单事件， 上报地理位置事件等</em></p>
<pre><code class="js">var sendMessageToUser = function ( data) {
    get_token(function (err, obj) {
        request.post({
            url  : "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token="             +obj.access_token,
            headers: {"Content-Type": "application/json"},
            json  : data
        }, function (err, res, body) {
        console.log("sendmessage....", body)
        })
    }
</code></pre>
<p><em>这个发放就是调用微信接口给用户发送消息，那接下来咱们就看下发送消息</em></p>
<h3 id="2、发送消息"><a href="#2、发送消息" class="headerlink" title="2、发送消息"></a><strong>2、发送消息</strong></h3><p>发送消息分为，发送被动消息，发送客服消息，发送模版消息</p>
<ul>
<li>被动消息如上接收消息后根据消息判断发送给用户的消息即是被动消息</li>
<li>客服消息，是公众号收到用户来的消息客服根据内容回复给用户的消息</li>
</ul>
<p>如果用户并没有给公众号发消息，此时客服是无法给用户发送消息的，这是微信做的一个限制</p>
<p>如下代码：</p>
<pre><code class="js">
wtutil.get_token(function (err, obj) {
//var text = "你好，这是一条消息，多谢支持...";
//var data = {
//  touser : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
//  msgtype: "text",
//  text  : {
//    content: text
//  }
//};
var data = {
touser : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
msgtype: "image",
"image":
{
    "media_id":"ZqQGrsR6ivb273zLApNfkEdAP3UI8nHJTJ9ekelfJ8OhKUF6UG-o6YbOBv4uWf4R"
}
};
request.post({
    url  : "https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=" + obj.access_token,
    headers: {"Content-Type": "application/json"},
    json  : data
}, function (err, res, body) {
    console.log(body);
    })
});</code></pre>
<p>msgtype: 是消息类型，上面注释掉的是文本消息，下面是个图片消息，touser是用户的openid，这里我只是取过来直接使用的，这里跟上面接收消息后处理给用户发消息有写重复，就不多介绍了</p>
<h3 id="3、模版消息"><a href="#3、模版消息" class="headerlink" title="3、模版消息"></a><strong>3、模版消息</strong></h3><p>模版消息大家肯定很熟悉，比如Worktile的微信公众号接收任务消息通知，这样的消息就是模版消息</p>
<p><a href="./wechat-03.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-03.png" class="lazyload"></a></p>
<p>模版消息相对来说复杂一下，首先要从公众号添加或者申请消息模版，如下图</p>
<p><a href="./wechat-04.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./wechat-04.png" class="lazyload"></a></p>
<p>那么有了消息模版之后就可以拿到模版ID，然后给用户发送模版消息了</p>
<pre><code class="js">get_token(function (err, obj) {
    var data = {
        "touser"   : "oy4hbwbd0MOMmn8aUtQWMcNxs8PI",
        "template_id": "z6yV_lOIAM-LQbsrG-B3hTQvwt8_4Y3wVU2PH9UW16c",
        "url"    : "https://worktile.com",
        "topcolor"  : "#FF00FF",
        "data"    : {
            "first"  : {
                "value": "测试哈哈哈，颜色可以自定义",
                "color": "#33FF00"
            },
            "one": {
                "value": "one",
                "color": "#173177"
            },
            "two": {
                "value": "two",
                "color": "#FF0033"
            },
            "three": {
                "value": "three",
                "color": "#173177"
            },
            "remark" : {
                "value": "remark，了解更多详情，关注我。。。。",
                "color": "#33FF00"
            }
        }
request.post({
    url  : "https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=" + obj.access_token,
    headers: {"Content-Type": "application/json"},
    json  : data
    }, function (err, res, body) {
        console.log(body, "----")
    })
});
</code></pre>
<p>需要说明的是参数中data里面的key(first, one, two,three, remark)是模版中定义的，这里需要根据模版内容来写，还有可以设置每个字段的颜色值等属性</p>
<h2 id="第四章：微信网页开发"><a href="#第四章：微信网页开发" class="headerlink" title="第四章：微信网页开发"></a><strong>第四章：微信网页开发</strong></h2><p>这个章节跟前面几章不同，前面几章介绍的是公众号开发的一些东西，这个章节介绍的是网页开发，主要针对h5应用或者是页面的开发，Worktile微信版就是微信网页开发完成的，下面咱们一步步的介绍。</p>
<h3 id="·微信网页授权"><a href="#·微信网页授权" class="headerlink" title="·微信网页授权"></a><strong>·微信网页授权</strong></h3><p>微信网页授权采用的是Oauth2.0的授权方式：</p>
<p><strong>第一步：访问如下链接获取code</strong></p>
<p><a href="https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect" target="_blank" rel="noopener">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&redirect_uri=REDIRECT_URI&response_type=code&scope=SCOPE&state=STATE#wechat_redirect</a></p>
<p>redirect_uri是你h5地址，授权成功后会把code加入到地址上，类似于：<a href="https://weixin.worktile.com?code=xxx这样" target="_blank" rel="noopener">https://weixin.worktile.com?code=xxx这样</a></p>
<p><strong>第二步：通过code换取网页授权access_token</strong></p>
<p>请求接口（get请求）</p>
<p><a href="https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&secret=SECRET&code=CODE&grant_type=authorization_code</a></p>
<p>返回的结果如下</p>
<pre><code class="json">{ 
    "access_token":"ACCESS_TOKEN",
    "expires_in":7200,
    "refresh_token":"REFRESH_TOKEN",
    "openid":"OPENID",
    "scope":"SCOPE" 
}</code></pre>
<p><em>access_token是用户授权的token，openid是用户对于该公众号的唯一标示，refresh_token：可以调用刷新token的接口获取最新的token</em></p>
<p><strong>第三步：获取用户信息(需scope为 snsapi_userinfo)</strong></p>
<p>请求接口(get请求)</p>
<p><a href="https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN" target="_blank" rel="noopener">https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&openid=OPENID&lang=zh_CN</a></p>
<p>通过以上3个步骤就可以获取用户的信息，进行用户的管理操作了</p>
<h3 id="·微信JS-SDK"><a href="#·微信JS-SDK" class="headerlink" title="·微信JS-SDK"></a><strong>·微信JS-SDK</strong></h3><p>网页开发中，有时候我们会自定义分享的内容，图片，音频，视频的上传，下载，地理位置，摇一摇周边，扫码，支付等的功能，这时候就需要js-sdk的开发了，下面简单介绍下js-sdk的使用，读者还可以查看官方开发文档：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842&token=&lang=zh_CN</a></p>
<h3 id="·绑定域名"><a href="#·绑定域名" class="headerlink" title="·绑定域名"></a><strong>·绑定域名</strong></h3><p>先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。</p>
<h3 id="·引入JS文件"><a href="#·引入JS文件" class="headerlink" title="·引入JS文件"></a><strong>·引入JS文件</strong></h3><p>在需要调用JS接口的页面引入如下JS文件，（支持https）：<a href="http://res.wx.qq.com/open/js/jweixin-1.0.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.0.0.js</a></p>
<p>如需使用摇一摇周边功能，请引入<a href="http://res.wx.qq.com/open/js/jweixin-1.1.0.js" target="_blank" rel="noopener">http://res.wx.qq.com/open/js/jweixin-1.1.0.js</a></p>
<h3 id="·通过config接口注入权限验证配置"><a href="#·通过config接口注入权限验证配置" class="headerlink" title="·通过config接口注入权限验证配置"></a><strong>·通过config接口注入权限验证配置</strong></h3><p>如下代码需要在网页中配置</p>
<pre><code class="js">wx.config({
debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打                开，参数信息会通过log打出，仅在pc端时才会打印。
appId: '', // 必填，公众号的唯一标识
timestamp: , // 必填，生成签名的时间戳
nonceStr: '', // 必填，生成签名的随机串
signature: '',// 必填，签名，见附录1
jsApiList: [] // 必填，需要使用的JS接口列表
});</code></pre>
<blockquote>
<p>如上代码中的timestamp, nonceStr, signature需要服务端做好签名返回给页面，这里可以使用异步调用的方式，如下为服务端签名代码</p>
</blockquote>
<pre><code class="js">
var sign = function (jsapi_ticket, url) {
var ret = {
jsapi_ticket: jsapi_ticket,
nonceStr: createNonceStr(),
timestamp: createTimestamp(),
url: url
};
var string = raw(ret);
jsSHA = require('jssha');
shaObj = new jsSHA(string, 'TEXT');
ret.signature = shaObj.getHash('SHA-1', 'HEX');
return ret;
};</code></pre>
<p><em>ret就是我们需要的签名结果，其中jsapi_ticket是调用ticket接口获取的，官方文档中也有说明<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=</a> access_token&type=jsapi, rul是获取签名的当前网页地址, nonceStr:随机字符串，timestamp：当前10位时间戳</em></p>
<pre><code class="js">var raw = function (args) {
var keys = Object.keys(args);
keys = keys.sort()
var newArgs = {};
keys.forEach(function (key) {
newArgs[key.toLowerCase()] = args[key];
});
var string = '';
for (var k in newArgs) {
string += '&' + k + '=' + newArgs[k];
}
string = string.substr(1);
return string;
};</code></pre>
<p><em>这个方法是对签名对象的一个字符串格式化算法</em></p>
<h3 id="·通过ready接口处理成功验证"><a href="#·通过ready接口处理成功验证" class="headerlink" title="·通过ready接口处理成功验证"></a><strong>·通过ready接口处理成功验证</strong></h3><blockquote>
<p>wx.ready(function(){</p>
<p>// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。</p>
</blockquote>
<p>});</p>
<h3 id="·调用接口"><a href="#·调用接口" class="headerlink" title="·调用接口"></a><strong>·调用接口</strong></h3><p>根据config里面 jsApiList的配置可以调用js-sdk的接口，如分享朋友圈，分享微信好友等。</p>
<pre><code class="js">wx.onMenuShareTimeline({
title: '', // 分享标题
link: '', // 分享链接
imgUrl: '', // 分享图标
success: function () {
// 用户确认分享后执行的回调函数
},
cancel: function () {
// 用户取消分享后执行的回调函数
}
});</code></pre>
<p>这是一个分享到朋友圈的接口，可以自定义标题，自定义链接，自定义图标</p>
<p>如果想调用更多的js-sdk的接口可以参考官方文档进行开发：<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115&token=&lang=zh_CN</a></p>
<h3 id="·微信网页开发样式库"><a href="#·微信网页开发样式库" class="headerlink" title="·微信网页开发样式库"></a><strong>·微信网页开发样式库</strong></h3><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784134&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784134&token=&lang=zh_CN</a></p>
<h3 id="·微信web开发者工具"><a href="#·微信web开发者工具" class="headerlink" title="·微信web开发者工具"></a><strong>·微信web开发者工具</strong></h3><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784140&token=&lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1455784140&token=&lang=zh_CN</a></p>
<p>以上就是微信公众号开发的一些内容，算是入门篇。其实关于微信的开发还有很多可以做的事情，而且随着需求越来越多，技术越来越完善.</p>
</body></html>]]></content>
      <categories>
        <category>微信开发</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker搭建MySQL服务</title>
    <url>/2020/04/09/docker-mysql/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="使用Docker搭建MySQL服务"><a href="#使用Docker搭建MySQL服务" class="headerlink" title="使用Docker搭建MySQL服务"></a><a href="https://www.cnblogs.com/sablier/p/11605606.html" target="_blank" rel="noopener">使用Docker搭建MySQL服务</a></h1><h3 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker#"></a>一、安装docker<a href="https://www.cnblogs.com/sablier/p/11605606.html#2145598473" target="_blank" rel="noopener">#</a></h3><p>windows 和 mac 版可以直接到官网下载 docker desktop</p>
<p>linux 的安装方法可以参考 <a href="https://www.cnblogs.com/myzony/p/9071210.html" target="_blank" rel="noopener">https://www.cnblogs.com/myzony/p/9071210.html</a></p>
<p>可以在shell中输入以下命令检查是否成功安装： <code>sudo docker version</code></p>
<h3 id="二、建立镜像"><a href="#二、建立镜像" class="headerlink" title="二、建立镜像#"></a>二、建立镜像<a href="https://www.cnblogs.com/sablier/p/11605606.html#244533582" target="_blank" rel="noopener">#</a></h3><ol>
<li><p>拉取官方镜像（我们这里选择5.7，如果不写后面的版本号则会自动拉取最新版）</p>
<pre><code class="shell">Copydocker pull mysql:5.7   # 拉取 mysql 5.7
docker pull mysql       # 拉取最新版mysql镜像</code></pre>
<p><a href="https://hub.docker.com/_/mysql/" target="_blank" rel="noopener">MySQL文档地址</a></p>
</li>
<li><p>检查是否拉取成功</p>
<pre><code>Copy$ sudo docker images</code></pre></li>
<li><p>一般来说数据库容器不需要建立目录映射</p>
<pre><code class="shell">Copysudo docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre>
<ul>
<li>–name：容器名，此处命名为<code>mysql</code></li>
<li>-e：配置信息，此处配置mysql的root用户的登陆密码</li>
<li>-p：端口映射，此处映射 主机3306端口 到 容器的3306端口</li>
</ul>
</li>
<li><p>如果要建立目录映射</p>
<pre><code class="shell">Copyduso docker run -p 3306:3306 --name mysql \
-v /usr/local/docker/mysql/conf:/etc/mysql \
-v /usr/local/docker/mysql/logs:/var/log/mysql \
-v /usr/local/docker/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7</code></pre>
<ul>
<li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录</li>
</ul>
</li>
<li><p>检查容器是否正确运行</p>
<pre><code class="shell">Copydocker container ls</code></pre>
<ul>
<li>可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字</li>
</ul>
</li>
</ol>
<h3 id="三、连接mysql"><a href="#三、连接mysql" class="headerlink" title="三、连接mysql#"></a>三、连接mysql<a href="https://www.cnblogs.com/sablier/p/11605606.html#303544512" target="_blank" rel="noopener">#</a></h3><ol>
<li><p>进入docker本地连接mysql客户端</p>
<pre><code class="shell">Copysudo docker exec -it mysql bash
mysql -uroot -p123456</code></pre>
</li>
<li><p>使用 Navicat 远程连接mysql</p>
<p>我只找到了 mac 版本的 Navicat Premiun（如下），没有找到windows和linux的。大家可以自行寻找。</p>
<p> <a href="https://pan.baidu.com/s/1bcJVyIvFneiEoMZPU-oIbA#list/path=/" target="_blank" rel="noopener">百度云连接</a> 密码: qps3 （该软件包来自著名分享网站 Pirate ，并感谢网友 chaosgod 和 jor_ivy）</p>
<p><a href="https://img-blog.csdn.net/20180801090208199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener"><img alt="img" data-src="https://img-blog.csdn.net/20180801090208199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a></p>
<p><a href="https://img-blog.csdn.net/20180801090230920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" target="_blank" rel="noopener"><img alt="img" data-src="https://img-blog.csdn.net/20180801090230920?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvcl9pdnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" class="lazyload"></a></p>
<p>安装完之后：复制中文包”zh-Hans.lproj”放到 /Contents/Resources 即可。（应用程序右键显示包内容）</p>
</li>
<li><p>使用远程连接软件时要注意一个问题</p>
<p>我们在创建容器的时候已经将容器的3306端口和主机的3306端口映射到一起，所以我们应该访问：</p>
<pre><code>Copyhost: 127.0.0.1
port: 3306
user: root
password: 123456</code></pre></li>
<li><p>如果你的容器运行正常，但是无法访问到MySQL，一般有以下几个可能的原因：</p>
<ul>
<li><p>防火墙阻拦</p>
<pre><code class="shell">Copy# 开放端口：
$ systemctl status firewalld
$ firewall-cmd  --zone=public --add-port=3306/tcp -permanent
$ firewall-cmd  --reload
# 关闭防火墙：
$ sudo systemctl stop firewalld</code></pre>
</li>
<li><p>需要进入docker本地客户端设置远程访问账号</p>
<pre><code class="shell">Copy$ sudo docker exec -it mysql bash
$ mysql -uroot -p123456
mysql> grant all privileges on *.* to root@'%' identified by "password";</code></pre>
<p>原理：</p>
<pre><code class="shell">Copy# mysql使用mysql数据库中的user表来管理权限，修改user表就可以修改权限（只有root账号可以修改）

mysql> use mysql;
Database changed

mysql> select host,user,password from user;
+--------------+------+-------------------------------------------+
| host                    | user      | password                                                                 |
+--------------+------+-------------------------------------------+
| localhost              | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |
| 192.168.1.1            | root     | *A731AEBFB621E354CD41BAF207D884A609E81F5E      |
+--------------+------+-------------------------------------------+
2 rows in set (0.00 sec)

mysql> grant all privileges  on *.* to root@'%' identified by "password";
Query OK, 0 rows affected (0.00 sec)

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)

mysql> select host,user,password from user;
+--------------+------+-------------------------------------------+
| host                    | user      | password                                                                 |
+--------------+------+-------------------------------------------+
| localhost              | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
| 192.168.1.1            | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
| %                       | root      | *A731AEBFB621E354CD41BAF207D884A609E81F5E     |
+--------------+------+-------------------------------------------+
3 rows in set (0.00 sec)</code></pre>
</li>
</ul>
</li>
</ol>
</body></html>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Flutter-Template开发规范(Flutter-go)</title>
    <url>/2020/03/30/flutter-dev-standard/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="Flutter-Template开发规范-Flutter-go"><a href="#Flutter-Template开发规范-Flutter-go" class="headerlink" title="Flutter-Template开发规范(Flutter-go)"></a>Flutter-Template开发规范(Flutter-go)</h1><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="标识符三种类型"><a href="#标识符三种类型" class="headerlink" title="标识符三种类型"></a>标识符三种类型</h3><h4 id="大驼峰"><a href="#大驼峰" class="headerlink" title="大驼峰"></a>大驼峰</h4><p>类、枚举、typedef和类型参数</p>
<pre><code class="dart">  class SliderMenu { ... }

  class HttpRequest { ... }

  typedef Predicate = bool Function<t>(T value);</t></code></pre>
<p>包括用于元数据注释的类</p>
<pre><code class="dart">  class Foo {
    const Foo([arg]);
  }

  @Foo(anArg)
  class A { ... }

  @Foo()
  class B { ... }</code></pre>
<h4 id="使用小写加下划线来命名库和源文件"><a href="#使用小写加下划线来命名库和源文件" class="headerlink" title="使用小写加下划线来命名库和源文件"></a>使用小写加下划线来命名库和源文件</h4><pre><code class="dart">  library peg_parser.source_scanner;

  import 'file_system.dart';
  import 'slider_menu.dart';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  library pegparser.SourceScanner;

  import 'file-system.dart';
  import 'SliderMenu.dart';</code></pre>
<h4 id="使用小写加下划线来命名导入前缀"><a href="#使用小写加下划线来命名导入前缀" class="headerlink" title="使用小写加下划线来命名导入前缀"></a>使用小写加下划线来命名导入前缀</h4><pre><code class="dart">  import 'dart:math' as math;
  import 'package:angular_components/angular_components'
      as angular_components;
  import 'package:js/js.dart' as js;</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  import 'dart:math' as Math;
  import 'package:angular_components/angular_components'
      as angularComponents;
  import 'package:js/js.dart' as JS;</code></pre>
<h4 id="使用小驼峰法命名其他标识符"><a href="#使用小驼峰法命名其他标识符" class="headerlink" title="使用小驼峰法命名其他标识符"></a>使用小驼峰法命名其他标识符</h4><pre><code class="javascript">  var item;

  HttpRequest httpRequest;

  void align(bool clearItems) {
    // ...
  }</code></pre>
<h4 id="优先使用小驼峰法作为常量命名"><a href="#优先使用小驼峰法作为常量命名" class="headerlink" title="优先使用小驼峰法作为常量命名"></a>优先使用小驼峰法作为常量命名</h4><pre><code class="dart">  const pi = 3.14;
  const defaultTimeout = 1000;
  final urlScheme = RegExp('^([a-z]+):');

  class Dice {
    static final numberGenerator = Random();
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  const PI = 3.14;
  const DefaultTimeout = 1000;
  final URL_SCHEME = RegExp('^([a-z]+):');

  class Dice {
    static final NUMBER_GENERATOR = Random();
  }</code></pre>
<h4 id="不使用前缀字母"><a href="#不使用前缀字母" class="headerlink" title="不使用前缀字母"></a>不使用前缀字母</h4><p>因为Dart可以告诉您声明的类型、范围、可变性和其他属性，所以没有理由将这些属性编码为标识符名称。</p>
<pre><code class="javascript">  defaultTimeout</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="javascript">  kDefaultTimeout</code></pre>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>为了使你的文件前言保持整洁，我们有规定的命令，指示应该出现在其中。每个“部分”应该用空行分隔。</p>
<h4 id="在其他引入之前引入所需的dart库"><a href="#在其他引入之前引入所需的dart库" class="headerlink" title="在其他引入之前引入所需的dart库"></a>在其他引入之前引入所需的dart库</h4><pre><code class="dart">  import 'dart:async';
  import 'dart:html';

  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';</code></pre>
<h4 id="在相对引入之前先引入在包中的库"><a href="#在相对引入之前先引入在包中的库" class="headerlink" title="在相对引入之前先引入在包中的库"></a>在相对引入之前先引入在包中的库</h4><pre><code class="dart">  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';

  import 'util.dart';</code></pre>
<h4 id="第三方包的导入先于其他包"><a href="#第三方包的导入先于其他包" class="headerlink" title="第三方包的导入先于其他包"></a>第三方包的导入先于其他包</h4><pre><code class="dart">  import 'package:bar/bar.dart';
  import 'package:foo/foo.dart';

  import 'package:my_package/util.dart';</code></pre>
<h4 id="在所有导入之后，在单独的部分中指定导出"><a href="#在所有导入之后，在单独的部分中指定导出" class="headerlink" title="在所有导入之后，在单独的部分中指定导出"></a>在所有导入之后，在单独的部分中指定导出</h4><pre><code class="dart">  import 'src/error.dart';
  import 'src/foo_bar.dart';

  export 'src/error.dart';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  import 'src/error.dart';
  export 'src/error.dart';
  import 'src/foo_bar.dart';</code></pre>
<h3 id="所有流控制结构，请使用大括号"><a href="#所有流控制结构，请使用大括号" class="headerlink" title="所有流控制结构，请使用大括号"></a>所有流控制结构，请使用大括号</h3><p>这样做可以避免悬浮的else问题</p>
<pre><code class="dart">  if (isWeekDay) {
    print('Bike to work!');
  } else {
    print('Go dancing or read a book!');
  }</code></pre>
<h4 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h4><p>一个if语句没有else子句，其中整个if语句和then主体都适合一行。在这种情况下，如果你喜欢的话，你可以去掉大括号</p>
<pre><code class="dart">  if (arg == null) return defaultValue;</code></pre>
<p>如果流程体超出了一行需要分划请使用大括号：</p>
<pre><code class="dart">  if (overflowChars != other.overflowChars) {
    return overflowChars < other.overflowChars;
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  if (overflowChars != other.overflowChars)
    return overflowChars < other.overflowChars;</code></pre>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><h3 id="要像句子一样格式化"><a href="#要像句子一样格式化" class="headerlink" title="要像句子一样格式化"></a>要像句子一样格式化</h3><p>除非是区分大小写的标识符，否则第一个单词要大写。以句号结尾(或“!”或“?”)。对于所有的注释都是如此：doc注释、内联内容，甚至TODOs。即使是一个句子片段。</p>
<pre><code class="dart">  greet(name) {
    // Assume we have a valid name.
    print('Hi, $name!');
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  greet(name) {
    /* Assume we have a valid name. */
    print('Hi, $name!');
  }</code></pre>
<p>可以使用块注释(/…/)临时注释掉一段代码，但是所有其他注释都应该使用//</p>
<h3 id="Doc注释"><a href="#Doc注释" class="headerlink" title="Doc注释"></a>Doc注释</h3><p>使用///文档注释来记录成员和类型。</p>
<p>使用doc注释而不是常规注释，可以让dartdoc找到并生成文档。</p>
<pre><code class="dart">  /// The number of characters in this chunk when unsplit.
  int get length => ...</code></pre>
<blockquote>
<p>由于历史原因，达特茅斯学院支持道格评论的两种语法:///(“C#风格”)和/<strong>…* /(“JavaDoc风格”)。我们更喜欢/// 因为它更紧凑。/</strong>和<em>/在多行文档注释中添加两个无内容的行。在某些情况下，///语法也更容易阅读，例如文档注释包含使用</em>标记列表项的项目符号列表。</p>
</blockquote>
<h3 id="考虑为私有api编写文档注释"><a href="#考虑为私有api编写文档注释" class="headerlink" title="考虑为私有api编写文档注释"></a>考虑为私有api编写文档注释</h3><p>Doc注释并不仅仅针对库的公共API的外部使用者。它们还有助于理解从库的其他部分调用的私有成员</p>
<h4 id="用一句话总结开始doc注释"><a href="#用一句话总结开始doc注释" class="headerlink" title="用一句话总结开始doc注释"></a>用一句话总结开始doc注释</h4><p>以简短的、以用户为中心的描述开始你的文档注释，以句号结尾。</p>
<pre><code class="dart">/// Deletes the file at [path] from the file system.
void delete(String path) {
  ...
}</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  /// Depending on the state of the file system and the user's permissions,
  /// certain operations may or may not be possible. If there is no file at
  /// [path] or it can't be accessed, this function throws either [IOError]
  /// or [PermissionError], respectively. Otherwise, this deletes the file.
  void delete(String path) {
    ...
  }</code></pre>
<h4 id="“doc注释”的第一句话分隔成自己的段落"><a href="#“doc注释”的第一句话分隔成自己的段落" class="headerlink" title="“doc注释”的第一句话分隔成自己的段落"></a>“doc注释”的第一句话分隔成自己的段落</h4><p>在第一个句子之后添加一个空行，把它分成自己的段落</p>
<pre><code class="dart">  /// Deletes the file at [path].
  ///
  /// Throws an [IOError] if the file could not be found. Throws a
  /// [PermissionError] if the file is present but could not be deleted.
  void delete(String path) {
    ...
  }</code></pre>
<h2 id="Flutter-Go-使用参考"><a href="#Flutter-Go-使用参考" class="headerlink" title="Flutter_Go 使用参考"></a>Flutter_Go 使用参考</h2><h3 id="库的引用"><a href="#库的引用" class="headerlink" title="库的引用"></a>库的引用</h3><p>flutter go 中，导入lib下文件库，统一指定包名，避免过多的<code>../../</code></p>
<pre><code class="dart">package:flutter_go/</code></pre>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><h4 id="使用相邻字符串连接字符串文字"><a href="#使用相邻字符串连接字符串文字" class="headerlink" title="使用相邻字符串连接字符串文字"></a>使用相邻字符串连接字符串文字</h4><p>如果有两个字符串字面值(不是值，而是实际引用的字面值)，则不需要使用+连接它们。就像在C和c++中，简单地把它们放在一起就能做到。这是创建一个长字符串很好的方法但是不适用于单独一行。</p>
<pre><code class="dart">raiseAlarm(
    'ERROR: Parts of the spaceship are on fire. Other '
    'parts are overrun by martians. Unclear which are which.');</code></pre>
<p>不推荐如下写法:</p>
<pre><code class="dart">raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' +
    'parts are overrun by martians. Unclear which are which.');</code></pre>
<h4 id="优先使用模板字符串"><a href="#优先使用模板字符串" class="headerlink" title="优先使用模板字符串"></a>优先使用模板字符串</h4><pre><code class="dart">'Hello, $name! You are ${year - birth} years old.';</code></pre>
<h4 id="在不需要的时候，避免使用花括号"><a href="#在不需要的时候，避免使用花括号" class="headerlink" title="在不需要的时候，避免使用花括号"></a>在不需要的时候，避免使用花括号</h4><pre><code class="dart">  'Hi, $name!'
  "Wear your wildest $decade's outfit."</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  'Hi, ${name}!'
  "Wear your wildest ${decade}'s outfit."</code></pre>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="尽可能使用集合字面量"><a href="#尽可能使用集合字面量" class="headerlink" title="尽可能使用集合字面量"></a>尽可能使用集合字面量</h4><p>如果要创建一个不可增长的列表，或者其他一些自定义集合类型，那么无论如何，都要使用构造函数。</p>
<pre><code class="dart">  var points = [];
  var addresses = {};
  var lines = <lines>[];</lines></code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  var points = List();
  var addresses = Map();</code></pre>
<h4 id="不要使用-length查看集合是否为空"><a href="#不要使用-length查看集合是否为空" class="headerlink" title="不要使用.length查看集合是否为空"></a>不要使用.length查看集合是否为空</h4><pre><code class="dart">if (lunchBox.isEmpty) return 'so hungry...';
if (words.isNotEmpty) return words.join(' ');</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  if (lunchBox.length == 0) return 'so hungry...';
  if (!words.isEmpty) return words.join(' ');</code></pre>
<h4 id="考虑使用高阶方法转换序列"><a href="#考虑使用高阶方法转换序列" class="headerlink" title="考虑使用高阶方法转换序列"></a>考虑使用高阶方法转换序列</h4><p>如果有一个集合，并且希望从中生成一个新的修改后的集合，那么使用.map()、.where()和Iterable上的其他方便的方法通常更短，也更具有声明性</p>
<pre><code class="dart">  var aquaticNames = animals
      .where((animal) => animal.isAquatic)
      .map((animal) => animal.name);</code></pre>
<h4 id="避免使用带有函数字面量的Iterable-forEach"><a href="#避免使用带有函数字面量的Iterable-forEach" class="headerlink" title="避免使用带有函数字面量的Iterable.forEach()"></a>避免使用带有函数字面量的Iterable.forEach()</h4><p>在Dart中，如果你想遍历一个序列，惯用的方法是使用循环。</p>
<pre><code class="dart">for (var person in people) {
  ...
}</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  people.forEach((person) {
    ...
  });</code></pre>
<h4 id="不要使用List-from-，除非打算更改结果的类型"><a href="#不要使用List-from-，除非打算更改结果的类型" class="headerlink" title="不要使用List.from()，除非打算更改结果的类型"></a>不要使用List.from()，除非打算更改结果的类型</h4><p>给定一个迭代，有两种明显的方法可以生成包含相同元素的新列表</p>
<pre><code class="dart">var copy1 = iterable.toList();
var copy2 = List.from(iterable);</code></pre>
<p>明显的区别是第一个比较短。重要的区别是第一个保留了原始对象的类型参数</p>
<pre><code class="dart">// Creates a List<int>:
var iterable = [1, 2, 3];

// Prints "List<int>":
print(iterable.toList().runtimeType);</int></int></code></pre>
<pre><code class="dart">// Creates a List<int>:
var iterable = [1, 2, 3];

// Prints "List<dynamic>":
print(List.from(iterable).runtimeType);</dynamic></int></code></pre>
<h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><h4 id="使用-将命名参数与其默认值分割开"><a href="#使用-将命名参数与其默认值分割开" class="headerlink" title="使用=将命名参数与其默认值分割开"></a>使用=将命名参数与其默认值分割开</h4><p>由于遗留原因，Dart均允许“:”和“=”作为指定参数的默认值分隔符。为了与可选的位置参数保持一致，使用“=”。</p>
<pre><code class="dart">  void insert(Object item, {int at = 0}) { ... }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  void insert(Object item, {int at: 0}) { ... }</code></pre>
<h4 id="不要使用显式默认值null"><a href="#不要使用显式默认值null" class="headerlink" title="不要使用显式默认值null"></a>不要使用显式默认值null</h4><p>如果参数是可选的，但没有给它一个默认值，则语言隐式地使用null作为默认值，因此不需要编写它</p>
<pre><code class="dart">void error([String message]) {
  stderr.write(message ?? '\n');
}</code></pre>
<p>不推荐如下写法:</p>
<pre><code class="dart">void error([String message = null]) {
  stderr.write(message ?? '\n');
}</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="不要显式地将变量初始化为空"><a href="#不要显式地将变量初始化为空" class="headerlink" title="不要显式地将变量初始化为空"></a>不要显式地将变量初始化为空</h4><p>在Dart中，未显式初始化的变量或字段自动被初始化为null。不要多余赋值null</p>
<pre><code class="dart">  int _nextId;

  class LazyId {
    int _id;

    int get id {
      if (_nextId == null) _nextId = 0;
      if (_id == null) _id = _nextId++;

      return _id;
    }
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  int _nextId = null;

  class LazyId {
    int _id = null;

    int get id {
      if (_nextId == null) _nextId = 0;
      if (_id == null) _id = _nextId++;

      return _id;
    }
  }</code></pre>
<h4 id="避免储存你能计算的东西"><a href="#避免储存你能计算的东西" class="headerlink" title="避免储存你能计算的东西"></a>避免储存你能计算的东西</h4><p>在设计类时，您通常希望将多个视图公开到相同的底层状态。通常你会看到在构造函数中计算所有视图的代码，然后存储它们:</p>
<p>应该避免的写法：</p>
<pre><code class="dart">  class Circle {
    num radius;
    num area;
    num circumference;

    Circle(num radius)
        : radius = radius,
          area = pi * radius * radius,
          circumference = pi * 2.0 * radius;
  }</code></pre>
<p>如上代码问题：</p>
<ul>
<li>浪费内存</li>
<li>缓存的问题是无效——如何知道何时缓存过期需要重新计算？</li>
</ul>
<p>推荐的写法如下：</p>
<pre><code class="dart">  class Circle {
    num radius;

    Circle(this.radius);

    num get area => pi * radius * radius;
    num get circumference => pi * 2.0 * radius;
  }</code></pre>
<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><h4 id="不要把不必要地将字段包装在getter和setter中"><a href="#不要把不必要地将字段包装在getter和setter中" class="headerlink" title="不要把不必要地将字段包装在getter和setter中"></a>不要把不必要地将字段包装在getter和setter中</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var _contents;
    get contents => _contents;
    set contents(value) {
      _contents = value;
    }
  }</code></pre>
<h4 id="优先使用final字段来创建只读属性"><a href="#优先使用final字段来创建只读属性" class="headerlink" title="优先使用final字段来创建只读属性"></a>优先使用final字段来创建只读属性</h4><p>尤其对于 <code>StatelessWidget</code></p>
<h4 id="在不需要的时候不要用this"><a href="#在不需要的时候不要用this" class="headerlink" title="在不需要的时候不要用this"></a>在不需要的时候不要用this</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var value;

    void clear() {
      this.update(null);
    }

    void update(value) {
      this.value = value;
    }
  }</code></pre>
<p>推荐如下写法：</p>
<pre><code class="dart">  class Box {
    var value;

    void clear() {
      update(null);
    }

    void update(value) {
      this.value = value;
    }
  }</code></pre>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="尽可能使用初始化的形式"><a href="#尽可能使用初始化的形式" class="headerlink" title="尽可能使用初始化的形式"></a>尽可能使用初始化的形式</h4><p>不推荐如下写法：</p>
<pre><code class="dart">  class Point {
    num x, y;
    Point(num x, num y) {
      this.x = x;
      this.y = y;
    }
  }</code></pre>
<p>推荐如下写法：</p>
<pre><code class="dart">class Point {
  num x, y;
  Point(this.x, this.y);
}</code></pre>
<h4 id="不要使用new"><a href="#不要使用new" class="headerlink" title="不要使用new"></a>不要使用new</h4><p>Dart2使new 关键字可选</p>
<p>推荐写法：</p>
<pre><code class="dart">  Widget build(BuildContext context) {
    return Row(
      children: [
        RaisedButton(
          child: Text('Increment'),
        ),
        Text('Click!'),
      ],
    );
  }</code></pre>
<p>不推荐如下写法：</p>
<pre><code class="dart">  Widget build(BuildContext context) {
    return new Row(
      children: [
        new RaisedButton(
          child: new Text('Increment'),
        ),
        new Text('Click!'),
      ],
    );
  }</code></pre>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><h4 id="优先使用async-await代替原始的futures"><a href="#优先使用async-await代替原始的futures" class="headerlink" title="优先使用async/await代替原始的futures"></a>优先使用async/await代替原始的futures</h4><p>async/await语法提高了可读性，允许你在异步代码中使用所有Dart控制流结构。</p>
<pre><code class="dart">  Future<int> countActivePlayers(String teamName) async {
    try {
      var team = await downloadTeam(teamName);
      if (team == null) return 0;

      var players = await team.roster;
      return players.where((player) => player.isActive).length;
    } catch (e) {
      log.error(e);
      return 0;
    }
  }</int></code></pre>
<h4 id="当异步没有任何用处时，不要使用它"><a href="#当异步没有任何用处时，不要使用它" class="headerlink" title="当异步没有任何用处时，不要使用它"></a>当异步没有任何用处时，不要使用它</h4><p>如果可以在不改变函数行为的情况下省略异步，那么就这样做。、</p>
<pre><code class="dart">  Future afterTwoThings(Future first, Future second) {
    return Future.wait([first, second]);
  }</code></pre>
<p>不推荐写法：</p>
<pre><code class="dart">  Future afterTwoThings(Future first, Future second) async {
    return Future.wait([first, second]);
  }</code></pre>
</body></html>]]></content>
  </entry>
  <entry>
    <title>GIS数据获取途径</title>
    <url>/2020/04/26/gis-data/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="GIS数据获取途径"><a href="#GIS数据获取途径" class="headerlink" title="GIS数据获取途径"></a>GIS数据获取途径</h1><h2 id="卫星数据平台"><a href="#卫星数据平台" class="headerlink" title="卫星数据平台"></a>卫星数据平台</h2><p>航天世景</p>
<p>长光卫星</p>
<p>遥感集市</p>
<p>欧比特</p>
<h2 id="数据展示平台"><a href="#数据展示平台" class="headerlink" title="数据展示平台"></a>数据展示平台</h2><p>Digitalglobe <a href="https://discover.digitalglobe.com/" target="_blank" rel="noopener">https://discover.digitalglobe.com/</a></p>
<p>欧比特轨迹<a href="http://obtdata.com/track.html" target="_blank" rel="noopener">http://obtdata.com/track.html</a></p>
<p>实时地球<a href="http://www.1010earth.com/index" target="_blank" rel="noopener">http://www.1010earth.com/index</a></p>
<p>实时江西<a href="http://jx.1010earth.com/" target="_blank" rel="noopener">http://jx.1010earth.com/</a></p>
<p>Cesium 3D地球展示实例<a href="http://api.rivermap.cn/cesium/rivermap/map.html" target="_blank" rel="noopener">http://api.rivermap.cn/cesium/rivermap/map.html</a></p>
<p>Cesium 3D地球功能实例<a href="https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=3D%20Tiles%20Feature%20Picking.html" target="_blank" rel="noopener">https://cesiumjs.org/Cesium/Build/Apps/Sandcastle/?src=3D%20Tiles%20Feature%20Picking.html</a></p>
<h2 id="星座轨道计算（TLE二行根数）"><a href="#星座轨道计算（TLE二行根数）" class="headerlink" title="星座轨道计算（TLE二行根数）"></a>星座轨道计算（TLE二行根数）</h2><p>长光卫星Plus(轨道)</p>
<p>3D地球自转<a href="http://wow.techbrood.com/fiddle/7152?vm=full" target="_blank" rel="noopener">http://wow.techbrood.com/fiddle/7152?vm=full</a></p>
<p>卫星星历<a href="http://www.celestrak.com/" target="_blank" rel="noopener">http://www.celestrak.com/</a></p>
<p>卫星轨迹生成<a href="http://www.orbitalpredictor.com/home/" target="_blank" rel="noopener">http://www.orbitalpredictor.com/home/</a></p>
<h2 id="国内第三方地图api"><a href="#国内第三方地图api" class="headerlink" title="国内第三方地图api"></a>国内第三方地图api</h2><p>高德地图<a href="https://lbs.amap.com/api/javascript-api/example/map/map-show" target="_blank" rel="noopener">https://lbs.amap.com/api/javascript-api/example/map/map-show</a></p>
<p>百度地图<a href="http://lbsyun.baidu.com/jsdemo.htm#a1_2" target="_blank" rel="noopener">http://lbsyun.baidu.com/jsdemo.htm#a1_2</a></p>
<p>腾讯地图<a href="http://lbs.qq.com/javascript_v2/demo.html" target="_blank" rel="noopener">http://lbs.qq.com/javascript_v2/demo.html</a></p>
<p>天地图<a href="http://lbs.tianditu.gov.cn/api/js4.0/examples.html" target="_blank" rel="noopener">http://lbs.tianditu.gov.cn/api/js4.0/examples.html</a></p>
<h2 id="云量相关"><a href="#云量相关" class="headerlink" title="云量相关"></a>云量相关</h2><p>ventusky： <a href="https://www.ventusky.com" target="_blank" rel="noopener">https://www.ventusky.com</a></p>
<p>windy：<a href="https://www.windy.com/" target="_blank" rel="noopener">https://www.windy.com/</a></p>
<p>中国气象天气数值预测<a href="http://data.cma.cn/Market/Detail/code/F.0003.0001/type/0.html" target="_blank" rel="noopener">http://data.cma.cn/Market/Detail/code/F.0003.0001/type/0.html</a></p>
<p>心知天气<a href="http://blog.seniverse.com/1903" target="_blank" rel="noopener">http://blog.seniverse.com/1903</a></p>
</body></html>]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>瞧!技术汇总</title>
    <url>/2020/05/14/it-summary/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>成为一名专业程序员的道路上，需要坚持练习、学习与积累，技术方面既要有一定的广度，更要有自己的深度。</p>
<p>笔者作为一位tool mad，将工作以来用到的各种优秀资料、神器及框架整理在此，毕竟好记性不如烂键盘，此项目可以作为自己的不时之需。</p>
<p>本人喜欢折腾，记录的东西也比较杂，各方面都会有一些，内容按重要等级排序，大家各取所需。</p>
<p>这里的东西会持续积累下去，欢迎Star，也欢迎发PR给我。</p>
<p><a href="https://github.com/thonatos" target="_blank" rel="noopener">Thonatos.Yang</a>整理的GitBook版本，阅读体验更佳：<a href="https://thonatos.gitbooks.io/be-a-professional-programmer/" target="_blank" rel="noopener">https://thonatos.gitbooks.io/be-a-professional-programmer/</a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


<ul>
<li><a href="#%E8%B5%84%E6%96%99%E7%AF%87">资料篇</a><ul>
<li><a href="#%E6%8A%80%E6%9C%AF%E7%AB%99%E7%82%B9">技术站点</a></li>
<li><a href="#%E5%BF%85%E7%9C%8B%E4%B9%A6%E7%B1%8D">必看书籍</a></li>
<li><a href="#%E5%A4%A7%E7%89%9B%E5%8D%9A%E5%AE%A2">大牛博客</a></li>
<li><a href="#github%E7%AF%87">GitHub篇</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E5%85%B7%E7%AF%87">工具篇</a><ul>
<li><a href="#%E5%B9%B3%E5%8F%B0%E5%B7%A5%E5%85%B7%E6%A1%86%E6%9E%B6">平台工具&框架</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7">常用工具</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%8D%E5%8A%A1">第三方服务</a></li>
<li><a href="#%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3%E5%A5%BD%E7%8E%A9%E7%9A%84%E5%B7%A5%E5%85%B7">爬虫相关(好玩的工具)</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3">安全相关</a></li>
<li><a href="#web%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8">Web服务器性能/压力测试工具/负载均衡器</a></li>
</ul>
</li>
<li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%88%86%E5%B8%83%E5%BC%8F%E5%B7%A5%E5%85%B7">大数据处理/数据分析/分布式工具</a></li>
<li><a href="#web%E5%89%8D%E7%AB%AF">Web前端</a></li>
<li><a href="#%E8%AF%AD%E8%A8%80%E7%AF%87">语言篇</a><ul>
<li><a href="#scala">Scala</a></li>
<li><a href="#java">Java</a></li>
<li><a href="#python">Python</a></li>
<li><a href="#swift">Swift</a></li>
<li><a href="#net">.NET</a></li>
<li><a href="#c--c">C & C++</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a><ul>
<li><a href="#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3">游戏开发相关</a></li>
<li><a href="#%E6%97%A5%E5%BF%97%E8%81%9A%E5%90%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86">日志聚合，分布式日志收集</a></li>
<li><a href="#rtp%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%9F%B3%E8%A7%86%E9%A2%91">RTP,实时传输协议与音视频</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->

<h2 id="资料篇"><a href="#资料篇" class="headerlink" title="资料篇"></a>资料篇</h2><h3 id="技术站点"><a href="#技术站点" class="headerlink" title="技术站点"></a>技术站点</h3><ul>
<li>在线学习：<a href="https://www.coursera.org/" target="_blank" rel="noopener">Coursera</a>、<a href="https://www.edx.org/" target="_blank" rel="noopener">edX</a>、<a href="https://cn.udacity.com/" target="_blank" rel="noopener">Udacity</a>、<a href="https://ocw.mit.edu/index.htm" target="_blank" rel="noopener">MIT公开课</a>、<a href="http://mooc.guokr.com/course/" target="_blank" rel="noopener">MOOC学院</a>、<a href="http://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></li>
<li><a href="https://news.ycombinator.com/" target="_blank" rel="noopener">Hacker News</a>：非常棒的针对编程的链接聚合网站</li>
<li><a href="https://www.techmeme.com/" target="_blank" rel="noopener">Techmeme</a>：美国知名科技新闻和博客聚集网站，类似的还有（Panda, Hacker & Designer News）</li>
<li><a href="https://www.reddit.com/r/programming/" target="_blank" rel="noopener">Reddit - Programming板块</a>：同上</li>
<li>Java牛人必备：<a href="http://www.programcreek.com/" target="_blank" rel="noopener">Program Creek</a></li>
<li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a>：IT技术问答网站</li>
<li><a href="https://segmentfault.com/" target="_blank" rel="noopener">SegmentFault</a>：中文的技术问答社区</li>
<li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>：全球最大的源代码管理平台，很多知名开源项目都在上面，如<a href="https://github.com/torvalds/linux" target="_blank" rel="noopener">Linux内核</a>，<a href="https://github.com/openstack/openstack" target="_blank" rel="noopener">OpenStack</a>等</li>
<li><a href="https://git.oschina.net/" target="_blank" rel="noopener">码云</a>：支持中文可免费创建私有项目的代码托管平台，可作为备选</li>
<li><a href="https://leetcode.com/" target="_blank" rel="noopener">LeetCode</a>：来做做这些题吧，看看自己的算法水平如何？这可比什么面试宝典强多了。</li>
<li><a href="https://www.lintcode.com/" target="_blank" rel="noopener">LintCode</a>：支持中文的编程题在线训练平台，可作为备选</li>
<li><a href="https://www.kaggle.com/" target="_blank" rel="noopener">Kaggle</a>,<a href="https://www.topcoder.com/" target="_blank" rel="noopener">Topcoder</a>: 机器学习、大数据竞赛</li>
<li><a href="https://gold.xitu.io/" target="_blank" rel="noopener">掘金</a>：高质量的技术社区</li>
<li><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a></li>
<li><a href="http://www.infoq.com/cn" target="_blank" rel="noopener">InfoQ</a>：企业级应用，关注软件开发领域</li>
<li><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX: way to explore</a></li>
<li>国内老牌技术社区：<a href="https://www.oschina.net/" target="_blank" rel="noopener">OSChina</a>、<a href="http://www.cnblogs.com/" target="_blank" rel="noopener">博客园</a>、<a href="http://www.csdn.net/" target="_blank" rel="noopener">CSDN</a>、<a href="http://www.51cto.com/" target="_blank" rel="noopener">51CTO</a></li>
<li>免费的it电子书：<a href="http://it-ebooks.info/" target="_blank" rel="noopener">http://it-ebooks.info/</a></li>
<li>在线学习：<a href="http://www.udemy.com/" target="_blank" rel="noopener">http://www.udemy.com/</a></li>
<li>优质学习资源：<a href="http://plus.mojiax.com/" target="_blank" rel="noopener">http://plus.mojiax.com/</a></li>
<li>代码练习：<a href="http://exercism.io/" target="_blank" rel="noopener">http://exercism.io/</a>   and  <a href="https://www.codingame.com" target="_blank" rel="noopener">https://www.codingame.com</a></li>
<li><a href="http://www.devstore.cn/" target="_blank" rel="noopener">DevStore</a>:开发者服务商店</li>
<li><a href="https://msdn.microsoft.com/zh-cn" target="_blank" rel="noopener">MSDN</a>：微软相关的官方技术集中地，主要是文档类</li>
<li><a href="https://developers.google.cn/" target="_blank" rel="noopener">谷歌开发者</a></li>
<li><a href="http://www.ctolib.com/" target="_blank" rel="noopener">码库</a> - 收录了实用的开源项目及资源</li>
<li><a href="http://coding.net" target="_blank" rel="noopener">Coding</a> 基于Git的国内代码托管平台，支持私有项目，有项目管理相关功能</li>
</ul>
<h3 id="必看书籍"><a href="#必看书籍" class="headerlink" title="必看书籍"></a>必看书籍</h3><ul>
<li>SICP(<a href="https://mitpress.mit.edu/sicp/" target="_blank" rel="noopener">Structure and Interpretation of Computer Programs</a>)</li>
<li>深入理解计算机系统</li>
<li>代码大全2</li>
<li>人件</li>
<li>人月神话</li>
<li>软件随想录</li>
<li>算法导论（麻省理工学院出版社）</li>
<li>编程之美</li>
<li><a href="https://book.douban.com/subject/30155731/" target="_blank" rel="noopener">算法之美</a>，作者：[美]布莱恩·克里斯汀，汤姆·格里菲思</li>
<li>离散数学及其应用</li>
<li>设计模式</li>
<li>黑客与画家</li>
<li>编程珠玑</li>
<li>The Little Schemer</li>
<li>Simply Scheme_Introducing_Computer_Science</li>
<li>C++ Primer</li>
<li>Effective C++</li>
<li>TCP/IP详解</li>
<li>Unix 编程艺术</li>
<li>技术的本质</li>
<li>软件随想录</li>
<li>计算机程序设计艺术</li>
<li>程序员的自我修养：链接、装载与库</li>
<li>程序员修炼之道</li>
<li>高效能程序员的修炼</li>
<li>《精神分析引论》弗洛伊德</li>
<li>《失控》《科技想要什么》《技术元素》凯文凯利</li>
<li>程序开发心理学</li>
<li>天地一沙鸥</li>
<li>搞定：无压力工作的艺术</li>
</ul>
<h3 id="大牛博客"><a href="#大牛博客" class="headerlink" title="大牛博客"></a>大牛博客</h3><ul>
<li><a href="https://github.com/rekihattori/awesome-programmers" target="_blank" rel="noopener">awesome-programmers</a>: 各领域大牛，值得纪念的程序员们</li>
<li><a href="http://blog.codingnow.com/" target="_blank" rel="noopener">云风</a>: 游戏界大牛</li>
<li><a href="http://www.yinwang.org/" target="_blank" rel="noopener">王垠</a>: 不少文章喷到蛮有道理</li>
<li><a href="http://tianchunbinghe.blog.163.com/" target="_blank" rel="noopener">冰河-伞哥</a>: Lisp大牛</li>
<li><a href="https://zhuanlan.zhihu.com/p/25042028" target="_blank" rel="noopener">R大</a>: 【干货满满】RednaxelaFX写的文章/回答的导航帖]</li>
<li><a href="http://coolshell.cn/" target="_blank" rel="noopener">陈皓</a>: 左耳朵耗子</li>
<li><a href="https://blog.codinghorror.com/" target="_blank" rel="noopener">Jeff Atwood</a>: 国外知名博主</li>
<li><a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a>: 黑客与画家译者，Web</li>
<li><a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">廖雪峰</a>: 他的Python、Git教程不少人都看过</li>
<li><a href="https://zhuanlan.zhihu.com/taosay" target="_blank" rel="noopener">道哥的黑板报</a>: 安全</li>
<li><a href="https://github.com/search?l=&o=desc&p=1&q=location%3AChina&ref=advsearch&s=followers&type=Users&utf8=%E2%9C%93" target="_blank" rel="noopener">国内GitHub上关注度较高的开发者</a></li>
</ul>
<h3 id="GitHub篇"><a href="#GitHub篇" class="headerlink" title="GitHub篇"></a>GitHub篇</h3><p>** Awesome **</p>
<ul>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">Awesome</a>: 这是个Awesome合集，常见的资料这里面都能找到</li>
<li><a href="https://github.com/jnv/lists" target="_blank" rel="noopener">杂七杂八、有用没用的Awesome合集</a></li>
<li><a href="https://github.com/bayandin/awesome-awesomeness" target="_blank" rel="noopener">Awesomeness</a> - 非常不错的语言类学习资料集合</li>
<li><a href="https://github.com/xingshaocheng/architect-awesome" target="_blank" rel="noopener">architect-awesome</a> - 后端架构师技术图谱</li>
<li><a href="https://github.com/cjwirth/awesome-ios-ui" target="_blank" rel="noopener">awesome-ios-ui</a></li>
<li><a href="https://github.com/wasabeef/awesome-android-ui" target="_blank" rel="noopener">awesome-android-ui</a></li>
<li><a href="https://github.com/lightSky/Awesome-MaterialDesign" target="_blank" rel="noopener">Awesome-MaterialDesign</a></li>
<li><a href="https://github.com/caesar0301/awesome-public-datasets" target="_blank" rel="noopener">awesome-public-datasets</a></li>
<li><a href="https://github.com/paragonie/awesome-appsec" target="_blank" rel="noopener">awesome-AppSec(系统安全)</a></li>
<li><a href="https://github.com/okulbilisim/awesome-datascience" target="_blank" rel="noopener">awesome-datascience</a></li>
<li><a href="https://github.com/fasouto/awesome-dataviz" target="_blank" rel="noopener">awesome-dataviz</a> - 数据可视化库及资料</li>
<li><a href="https://github.com/jacksu/awesome-es" target="_blank" rel="noopener">awesome-es</a></li>
<li><a href="https://github.com/Blankj/awesome-comment" target="_blank" rel="noopener">awesome-comment</a> - 神注释大全</li>
<li><a href="https://github.com/carpedm20/awesome-hacking" target="_blank" rel="noopener">awesome-hacking</a> - 黑客工具箱</li>
<li><a href="https://github.com/jacksu/machine-learning" target="_blank" rel="noopener">awesome-machine-learning</a> - 机器学习资料</li>
<li><a href="https://github.com/redhatxl/awesome-kubernetes-notes" target="_blank" rel="noopener">awesome-kubernetes-notes</a> - kubernetes学习资料</li>
</ul>
<p>** 书籍资料 **</p>
<ul>
<li><a href="https://github.com/mr-mig/every-programmer-should-know" target="_blank" rel="noopener">Every Programmer Should Know</a></li>
<li><a href="https://people.eecs.berkeley.edu/~rcs/research/interactive_latency.html" target="_blank" rel="noopener">Latency Numbers Every Programmer Should Know</a></li>
<li><a href="https://github.com/donnemartin/system-design-primer" target="_blank" rel="noopener">system-design-primer</a>: 系统设计入门</li>
<li><a href="https://github.com/bingwen/free-programming-books/blob/master/free-programming-books-ch.md" target="_blank" rel="noopener">free-programming-books</a> <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">中文版</a></li>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">免费的编程中文书籍索引</a></li>
<li><a href="https://github.com/julycoding/The-Art-Of-Programming-By-July" target="_blank" rel="noopener">《程序员编程艺术 — 面试和算法心得》</a></li>
<li><a href="https://github.com/dariubs/GoBooks" target="_blank" rel="noopener">GoBooks</a></li>
<li><a href="https://github.com/papers-we-love/papers-we-love" target="_blank" rel="noopener">Papers we love</a></li>
<li><a href="https://github.com/JustFollowUs/Natural-Language-Processing" target="_blank" rel="noopener">自然语言处理NLP推荐学习路线及参考资料</a></li>
<li><a href="https://github.com/josephmisiti/awesome-machine-learning" target="_blank" rel="noopener">超级棒的机器学习资料（框架，库，软件）</a>, <a href="http://www.oschina.net/news/53818/awesome-machine-learning" target="_blank" rel="noopener">中文翻译版</a></li>
<li><a href="http://news.cnblogs.com/n/504467/" target="_blank" rel="noopener">机器学习(Machine Learning)&深入学习(Deep Learning)资料</a></li>
<li><a href="http://special.csdncms.csdn.net/BeDocker/" target="_blank" rel="noopener">Docker资料合集</a></li>
<li><a href="https://github.com/apache/incubator-storm/tree/master/examples/storm-starter" target="_blank" rel="noopener">学习使用Strom</a></li>
<li><a href="http://ercoppa.github.io/HadoopInternals/" target="_blank" rel="noopener">Hadoop Internals</a></li>
<li><a href="https://github.com/JerryLead/SparkInternals/tree/master/markdown" target="_blank" rel="noopener">Spark Internals</a></li>
<li><a href="http://hadoop.readthedocs.org/en/latest/" target="_blank" rel="noopener">大数据时代的数据分析与数据挖掘 – 基于Hadoop实现</a></li>
<li><a href="http://samypesse.gitbooks.io/how-to-create-an-operating-system/index.html" target="_blank" rel="noopener">如何制作操作系统</a></li>
<li><a href="https://github.com/zhuangbiaowei/learn-with-open-source" target="_blank" rel="noopener">借助开源项目学习软件开发</a></li>
<li><a href="http://code.csdn.net/news/2821842" target="_blank" rel="noopener">几个不错的开源游戏引擎</a></li>
<li><a href="https://github.com/hit9/PyZh" target="_blank" rel="noopener">一起写Python文章，一起看Python文章</a></li>
<li><a href="http://blog.fens.me/series-r/" target="_blank" rel="noopener">R的极客理想系列文章</a></li>
<li><a href="https://github.com/bolasblack/http-api-guide" target="_blank" rel="noopener">HTTP接口设计指南</a></li>
<li><a href="https://github.com/foru17/front-end-collect" target="_blank" rel="noopener">分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者</a></li>
<li><a href="https://github.com/rxin/db-readings" target="_blank" rel="noopener">Readings in Databases</a></li>
<li><a href="https://github.com/rushter/data-science-blogs" target="_blank" rel="noopener">Data Science blogs</a></li>
<li><a href="https://github.com/oldratlee/translations/blob/master/log-what-every-software-engineer-should-know-about-real-time-datas-unifying/README.md" target="_blank" rel="noopener">日志：每个软件工程师都应该知道的有关实时数据的统一概念</a></li>
<li><a href="http://guides.codepath.com/android" target="_blank" rel="noopener">Android Code Path</a></li>
<li><a href="https://github.com/GeniusVJR/LearningNotes" target="_blank" rel="noopener">Android Learn Notes</a></li>
<li><a href="https://github.com/ziadoz/awesome-php" target="_blank" rel="noopener">PHP 类库框架，资料集合</a></li>
</ul>
<p>** 优秀项目 **</p>
<ul>
<li><a href="http://news.cnblogs.com/n/506775/" target="_blank" rel="noopener">最值得关注的10个C语言开源项目</a></li>
<li><a href="http://code.csdn.net/news/2822568" target="_blank" rel="noopener">15款值得学习的小型开源项目</a></li>
<li><a href="https://github.com/Aufree/trip-to-iOS" target="_blank" rel="noopener">iOS-100个开源组件</a></li>
<li><a href="http://code.csdn.net/news/2822753" target="_blank" rel="noopener">十大Material Design开源项目</a></li>
<li><a href="https://github.com/Trinea/android-open-project" target="_blank" rel="noopener">Android开源项目分类汇总</a></li>
<li><a href="https://github.com/gothinkster/realworld" target="_blank" rel="noopener">The mother of all demo apps</a></li>
</ul>
<p>** 前端 & Node.js **</p>
<ul>
<li><a href="https://github.com/moklick/frontend-stuff" target="_blank" rel="noopener">前端资源</a></li>
<li><a href="https://github.com/w3crange/Front-End-Develop-Guide" target="_blank" rel="noopener">前端开发指南</a></li>
<li><a href="http://html5ify.com/fks/" target="_blank" rel="noopener">前端技能汇总</a></li>
<li><a href="http://www.daqianduan.com/nav" target="_blank" rel="noopener">前端资源大导航</a></li>
<li><a href="https://github.com/lisposter/frontend-books" target="_blank" rel="noopener">收集前端方面的书籍</a></li>
<li><a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions" target="_blank" rel="noopener">2014年最新前端开发面试题</a></li>
<li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">简单清晰的JavaScript语言教程，代码示例</a></li>
<li><a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">JavaScript编程规范</a></li>
<li><a href="https://github.com/bolshchikov/js-must-watch" target="_blank" rel="noopener">JavaScript必看视频</a></li>
<li><a href="http://javascript.ruanyifeng.com/" target="_blank" rel="noopener">JavaScript标准参考教程（阮一峰的，整理的不错）</a></li>
<li><a href="https://github.com/bolshchikov/js-must-watch" target="_blank" rel="noopener">JS必看</a></li>
<li><a href="https://github.com/jmcunningham/AngularJS-Learning/blob/master/ZH-CN.md" target="_blank" rel="noopener">AngularJS Guide的中文分支</a></li>
<li><a href="https://github.com/timjacobi/angular2-education" target="_blank" rel="noopener">Angular2学习资料</a></li>
<li><a href="https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md" target="_blank" rel="noopener">AngularJS应用的最佳实践和风格指南</a></li>
<li><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="noopener">React-Native学习指南</a></li>
<li><a href="http://nqdeng.github.io/7-days-nodejs/" target="_blank" rel="noopener">七天学会NodeJS</a></li>
<li><a href="https://github.com/sergtitov/NodeJS-Learning/blob/master/cn_resource.md" target="_blank" rel="noopener">node.js中文资料导航</a></li>
<li><a href="http://blog.fens.me/nodejs-roadmap/" target="_blank" rel="noopener">Nodejs学习路线图</a></li>
<li><a href="http://stackoverflow.com/questions/2353818/how-do-i-get-started-with-node-js/9629682#9629682" target="_blank" rel="noopener">如何学习nodejs</a></li>
</ul>
<p>** 工作，工具 **</p>
<ul>
<li><a href="https://godbolt.org/" target="_blank" rel="noopener">Compiler Explorer</a></li>
<li><a href="https://github.com/kahun/awesome-sysadmin" target="_blank" rel="noopener">系统管理员工具集合</a></li>
<li><a href="http://git-scm.com/book/zh" target="_blank" rel="noopener">Pro Git</a></li>
<li><a href="https://github.com/taobao/nginx-book" target="_blank" rel="noopener">Nginx开发从入门到精通</a></li>
<li><a href="https://github.com/justjavac/Google-IPs.git" target="_blank" rel="noopener">Google 全球 IP 地址库</a></li>
<li><a href="https://github.com/greatghoul/remote-working" target="_blank" rel="noopener">收集整理远程工作相关的资料</a></li>
<li><a href="https://github.com/chriskempson/base16" target="_blank" rel="noopener">Color schemes for hackers</a></li>
<li><a href="https://github.com/ellisonleao/magictools" target="_blank" rel="noopener">游戏开发工具集，MagicTools</a></li>
<li><a href="https://github.com/ripienaar/free-for-dev" target="_blank" rel="noopener">开发者工具箱， free-for-dev</a></li>
<li><a href="https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md" target="_blank" rel="noopener">GitHub秘籍</a></li>
<li><a href="https://github.com/agis-/git-style-guide" target="_blank" rel="noopener">Git风格指南</a></li>
<li><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="noopener">Best-App</a></li>
<li><a href="http://dingba.top/" target="_blank" rel="noopener">OSINT:dingba.top</a>, <a href="https://github.com/jivoi/awesome-osint" target="_blank" rel="noopener">awesome-osint</a></li>
<li>加壳、脱壳工具：Armadillo, ASProtect, Themida, Execryptor, VMProtect, Obsidium</li>
</ul>
<h2 id="工具篇"><a href="#工具篇" class="headerlink" title="工具篇"></a>工具篇</h2><h3 id="平台工具-amp-框架"><a href="#平台工具-amp-框架" class="headerlink" title="平台工具&框架"></a>平台工具&框架</h3><ul>
<li>云：Rancher > Kubernetes(k8s) > Docker（镜像库：registry，Harbor，JFrog Artifactory）</li>
<li><a href="http://jupyter.org/" target="_blank" rel="noopener">Jupyter</a>: IPython Notebook, 有个子项目sparkmagic，可以和Spark集合在一起，类似spark-notebook项目</li>
<li><a href="http://swagger.io/" target="_blank" rel="noopener">Swagger</a>: RESTful API设计工具，前后端分离项目必备，顺便推荐下<a href="https://www.easy-mock.com/" target="_blank" rel="noopener">Easy Mock</a></li>
<li><a href="https://flutter.io/" target="_blank" rel="noopener">Flutter</a>: Google出品，高性能跨平台移动应用开发框架</li>
<li><a href="https://zipkin.io/" target="_blank" rel="noopener">OpenZipkin</a>: 分布式Trace系统，可用于分析服务调用链间的消耗</li>
<li><a href="https://sentry.io" target="_blank" rel="noopener">Sentry</a>: 系统监控与错误日志跟踪系统</li>
<li>基于Web技术的跨平台应用开发框架：<a href="https://github.com/tauri-apps/tauri" target="_blank" rel="noopener">tauri:Rust开发，小而快</a>，<a href="https://sciter.com/" target="_blank" rel="noopener">sciter</a>，<a href="https://github.com/electron/electron" target="_blank" rel="noopener">electron</a></li>
<li><a href="https://secure.phabricator.com/" target="_blank" rel="noopener">Phabricator</a>: 软件开发平台，Facebook出品，现已开源，CodeReview神器（从这个往下一直到GitLab之间的工具统统可以忽略了）</li>
<li>Redmine/Trac：项目管理平台</li>
<li>Jenkins/Jira(非开源)：持续集成系统（Apache Continuum，这个是Apache下的CI系统，还没来得及研究）</li>
<li>git，svn：源代码版本控制系统</li>
<li>GitLab/Gitorious：构建自己的GitHub服务器</li>
<li><a href="https://ci.appveyor.com/" target="_blank" rel="noopener">AppVeyor</a> - 云端持续集成工具，可以与GitHub搭配使用</li>
<li>Postman:RESTful，api测试工具，HTTP接口开发必备神器；可替代工具：<a href="https://insomnia.rest/" target="_blank" rel="noopener">Insomnia</a></li>
<li><a href="http://airbnb.design/lottie/" target="_blank" rel="noopener">Lottie</a>: AE动画变原生代码，设计师必备</li>
<li>Sonar：代码质量管理平台</li>
<li><a href="https://jmeter.apache.org/" target="_blank" rel="noopener">JMeter</a>: 测试框架，还有<a href="https://locust.io/" target="_blank" rel="noopener">Locust</a></li>
<li>Nessus: 系统漏洞扫描器</li>
<li>gitbook：<a href="https://www.gitbook.io/" target="_blank" rel="noopener">https://www.gitbook.io/</a>写书的好东西，当然用来写文档也很不错的（发现不少产品的文档就是用的它）</li>
<li>Travis-ci：开源项目持续集成必备，和GitHub相结合，<a href="https://travis-ci.org/" target="_blank" rel="noopener">https://travis-ci.org/</a></li>
<li>Trello：简单高效的项目管理平台，注重看板管理</li>
<li>日志聚合：graylog、ELK（推荐新一代的graylog，基本上算作是开源的Splunk了）</li>
<li>开源测试工具、社区（Selenium、OpenQA.org）</li>
<li>Puppet:一个自动管理引擎，可以适用于Linux、Unix以及Windows平台。所谓配置管理系统，就是管理机器里面诸如文件、用户、进程、软件包这些资源。无论是管理1台，还是上万台机器Puppet都能轻松搞定。其他类似工具：CFEngine、SaltStack、Ansible</li>
<li><a href="http://www.jumpserver.org/" target="_blank" rel="noopener">jumpserver</a>: 开源堡垒机</li>
<li><a href="https://prometheus.io/" target="_blank" rel="noopener">Prometheus</a> 监控系统+时序数据库，一般搭配Grafana使用。类似的系统还有Nagios,Zabbix,Ganglia</li>
<li>fleet：分布式init系统</li>
<li>Ansible：能够大大简化Unix管理员的自动化配置管理与流程控制方式。</li>
<li>GeoLite免费数据库</li>
<li>jsHint:js代码验证工具</li>
<li>haproxy: 高可用负载均衡（此外类似的系统还有nginx，lvs）</li>
<li>linux OS性能分析工具：dstat，iostat，iotop，nmon</li>
<li>kimono：将网页信息转换为api接口的工具</li>
<li>集群管理工具：pdsh，ClusterSSH，mussh（可以用它快速管理Hadoop集群）ipa-server做统一的认证管理</li>
<li>influxdb: 分布式时序数据库，结合Grafana可以进行实时数据分析</li>
<li>dot: 程序员绘图利器（是种语言，也是个工具）</li>
<li>Graph::Easy: （Ascii Art工具）字符流程图绘制，实乃程序员装逼神器。其他类似的工具Asciiflow, vi插件：drawit!</li>
<li>spf13-vim: 让你的vim飞起来！</li>
<li>Kubernetes: 容器集群管理系统</li>
<li><a href="https://gatling.io/" target="_blank" rel="noopener">Gatling</a>: 服务器性能压力测试工具，类似的还有<a href="https://github.com/wg/wrk" target="_blank" rel="noopener">wrk</a></li>
<li>systemtap: Linux内核探测工具、内核调试神器</li>
<li>Cygwin：Windows下的类UNIX模拟环境</li>
<li>MinGW：Windows下的GNU工具集</li>
</ul>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ul>
<li><a href="http://editorconfig.org/" target="_blank" rel="noopener">EditorConfig</a>: 让我们在各种不同IDE或编辑器下写代码保持风格一致</li>
<li><a href="https://github.com/hzlzh/Best-App" target="_blank" rel="noopener">Mac下的神兵利器</a></li>
<li><a href="https://asciinema.org/" target="_blank" rel="noopener">asciinema</a>: 终端录屏神器</li>
<li>Fiddler：非常好用的Web前端调试工具，当然是针对底层http协议的，一般情况使用Chrome等自带的调试工具也足够了，特殊情况还得用它去处理</li>
<li>Charles: Mac上的Web代理调试工具，类似Fiddler</li>
<li><a href="https://fir.im/" target="_blank" rel="noopener">fir.im</a>免费的移动App内测托管平台</li>
<li>wireshark：知名的网络数据包分析工具</li>
<li>PowerCmd:替代Windows Cmd的利器，类似的还有<a href="http://cmder.net/" target="_blank" rel="noopener">cmder</a></li>
<li><a href="https://mobaxterm.mobatek.net/" target="_blank" rel="noopener">MobaXterm</a>: Windows下的全能终端神器</li>
<li><a href="https://sourceforge.net/projects/xming/" target="_blank" rel="noopener">Xming</a>: Windows下的X Window Server，结合putty可以实现linux的图形化软件直接跑在Windows上 </li>
<li>RegexBuddy:强大的正则表达式测试工具</li>
<li>Source Insight：源代码阅读神器</li>
<li>SublimeText：程序员最爱的编辑器</li>
<li>Database.NET：一个通用的关系型数据库客户端，基于.NET 4.0开发的，做简单的处理还是蛮方便的</li>
<li>Navicat Premium：支持MySql、PostgreSQL、Oracle、Sqlite和SQL Server的客户端，通用性上不如Database.NET，但性能方面比Database.NET好很多，自带备份功能也用于数据库定时备份。</li>
<li>Synergy : 局域网内一套键盘鼠标控制多台电脑</li>
<li>DameWare：远程协助工具集（我在公司主要控制大屏幕用）</li>
<li>Radmin: 远程控制工具，用了一段时间的DameWare，还要破解，对Win7支持的不好，还是发现这个好用</li>
<li>Listary：能极大幅度提高你 Windows 文件浏览与搜索速度效率的「超级神器」</li>
<li>Clover：给资源管理器加上多标签，我平时工作的时候就用它，像Chrome一样使用资源管理器，甚是方便啊（这是Windows平台的）</li>
<li>WinLaunch：模拟Mac OS的Launch工具</li>
<li>OllyDbg: OD大名鼎鼎的反汇编工具，Win平台</li>
<li>Fritzing：绘制电路图</li>
<li>LICEcap：gif教程制作</li>
<li>Enigma Virtual Box（将exe，dll等封装成一个可执行程序）</li>
<li>Open DBDiff(针对SqlServer)数据库同步</li>
<li>SymmetricDS：数据库同步</li>
<li>BIEE,Infomatica，SPSS，weka，R语言：数据分析</li>
<li>CodeSmith，LightSwitch：代码生成</li>
<li>Pandoc：Markdown转换工具，出书用的。以前玩过docbook，不过现在还是Markdown盛行啊。</li>
<li>Window Magnet[Mac]：增强Mac窗口管理功能，想Win7一样具有窗口拖放到屏幕边缘自动调整的功能</li>
<li>log explorer：查看SqlServer日志</li>
<li>dependency walker：查询Windows应用程序dll依赖项</li>
<li>Shairport4w：将iPhone，iPad，iPod上的音频通过AirPlay协议传输到PC上</li>
<li>ngrok：内网穿透工具</li>
<li>Axure:快速原型制作工具，还有个在线作图的工具国内的一个创业团队做的，用着很不错<a href="http://www.processon.com/" target="_blank" rel="noopener">http://www.processon.com/</a></li>
<li>Origami: 次世代交互设计神器</li>
<li>百度脑图：<a href="http://naotu.baidu.com/" target="_blank" rel="noopener">http://naotu.baidu.com/</a></li>
<li>tinyproxy:（Linux）小型的代理服务器支持http和https协议</li>
<li>EaseUS Partition Master：超级简单的分区调整工具，速度还是蛮快的，C盘不够用了就用它从D盘划点空间吧，不用重装系统这么折腾哦。</li>
<li>CheatEngine：玩游戏修改内存值必备神器（记得我在玩轩辕剑6的时候就用的它，超级方便呢）</li>
<li>ApkIDE: Android反编译神器（类似的还有apktool）</li>
<li>HandShaker: 锤子的良心之作：为解决安卓手机与Mac当中文件传输问题，专门开发的SmartFinder文件管理器改进版</li>
<li>翻、墙工具（自|由|门、天行浏览器，免费的VPN：<a href="http://www.mangovpn.com/）,发现最方便还属Lantern，免费用起来超级方便（更新于2015-08-22）" target="_blank" rel="noopener">http://www.mangovpn.com/）,发现最方便还属Lantern，免费用起来超级方便（更新于2015-08-22）</a></li>
<li>设计工具：Sketch、OmniGraffle</li>
<li>MindManger：思维导图</li>
<li>MagicDraw: Uml图工具</li>
<li>innotop：MySql状态监测工具</li>
<li>墨刀：比Axure更为简单的原型工具，可以快速制作原型</li>
<li>Karabiner: Mac专用，修改键盘键位的神器，机械键盘必备</li>
<li>Timing：Mac专用，统计你的时间都花在哪了</li>
<li>LaTeX: 基于ΤΕΧ的排版系统, 让写论文更方便</li>
<li>Antlr：开源的语法分析器，可以让你毫无压力的写个小parser</li>
</ul>
<h3 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h3><ul>
<li><a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a>: 免费、自动化、开放的证书签发服务</li>
<li>DnsPod：一个不错的智能DNS服务解析提供商</li>
<li>DigitalOcean：海外的云主机提供商，价格便宜，磁盘是SSD的，用过一段时间整体上还可以，不过毕竟是海外的，网速比较慢。国内的就是阿里云了。还有个比较知名的是：Linode，据说速度上比DigitalOcean好很多</li>
<li>移动端推送服务：个推、JPush、云巴</li>
<li><a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>：移动应用开发服务，包括:数据存储、用户管理、消息推送、应用统计、社交分享、实时聊天等服务</li>
<li><a href="http://www.colorhunt.co/" target="_blank" rel="noopener">Color Hunt</a>: 漂亮炫酷的配色网站，程序员的福音</li>
<li><a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku: PaaS平台</a></li>
</ul>
<h3 id="爬虫相关-好玩的工具"><a href="#爬虫相关-好玩的工具" class="headerlink" title="爬虫相关(好玩的工具)"></a>爬虫相关(好玩的工具)</h3><ul>
<li>Phantomjs(Web自动化测试，服务端渲染等)</li>
<li>berserkJS(基于Phantomjs的改进版本)</li>
<li>SlimerJS</li>
<li>CasperJS</li>
<li>selenium</li>
<li>HtmlUnit（开源的java 页面分析工具，也是个Headless的浏览器）</li>
</ul>
<h3 id="安全相关"><a href="#安全相关" class="headerlink" title="安全相关"></a>安全相关</h3><ul>
<li>sql注入检测：sqlmap、haviji</li>
<li>端口扫描：nmap, </li>
<li><a href="https://github.com/robertdavidgraham/masscan" target="_blank" rel="noopener">masscan</a>：据说可以6分钟中扫遍整个互联网的端口扫描器</li>
<li>渗透测试：BurpLoader</li>
<li>sqltools: sql漏洞利用工具</li>
<li>snort: 入侵检测</li>
</ul>
<h3 id="Web服务器性能-压力测试工具-负载均衡器"><a href="#Web服务器性能-压力测试工具-负载均衡器" class="headerlink" title="Web服务器性能/压力测试工具/负载均衡器"></a>Web服务器性能/压力测试工具/负载均衡器</h3><ul>
<li>ab: ab是apache自带的一款功能强大的测试工具</li>
<li>curl-loader: 真实模拟、测试Web负载</li>
<li>http_load: 程序非常小，解压后也不到100K</li>
<li>webbench: 是Linux下的一个网站压力测试工具，最多可以模拟3万个并发连接去测试网站的负载能力。</li>
<li>Siege: 一款开源的压力测试工具，可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。</li>
<li>squid（前端缓存），nginx（负载），nodejs（没错它也可以，自己写点代码就能实现高性能的负载均衡器）：常用的负载均衡器</li>
<li>Piwik：开源网站访问量统计系统</li>
<li>ClickHeat：开源的网站点击情况热力图</li>
<li>HAProxy：高性能TCP /HTTP负载均衡器</li>
<li>ElasticSearch：搜索引擎基于Lucene</li>
<li>Page Speed SDK和YSLOW</li>
<li>HAR Viewer: HAR分析工具</li>
<li>protractor：E2E（end to end）自动化测试工具</li>
</ul>
<h2 id="大数据处理-数据分析-分布式工具"><a href="#大数据处理-数据分析-分布式工具" class="headerlink" title="大数据处理/数据分析/分布式工具"></a>大数据处理/数据分析/分布式工具</h2><ul>
<li>Hadoop：分布式的文件系统，结合其MapReduce编程模型可以用来做海量数据的批处理（Hive，Pig，HBase啥的就不说了），值得介绍的是Cloudera的Hadoop分支CDH5，基于YARN MRv2集成了Spark可直接用于生产环境的Hadoop，对于企业快速构建数据仓库非常有用。</li>
<li>Spark：大规模数据处理框架（可以应付企业中常见的三种数据处理场景：复杂的批量数据处理（batch data processing）；基于历史数据的交互式查询（interactive query）；基于实时数据流的数据处理（streaming data processing））</li>
<li>除了Spark，其他几个不错的计算框架还有：Kylin，Flink，Drill</li>
<li>Ignite: In-Memory Data Fabric</li>
<li>CarbonData: 华为的孵化项目，支持索引的列式存储</li>
<li>Ceph:Linux分布式文件系统（特点：无中心）</li>
<li>Storm：实时流数据处理，可以看下IBM的一篇介绍 （还有个Yahoo的S4，也是做流数据处理的）</li>
<li>Druid: 实时数据分析存储系统</li>
<li>Ambari: 大数据平台搭建、监控利器；类似的还有CDH</li>
<li>Tachyon：分布式内存文件系统</li>
<li><a href="http://greenplum.org/" target="_blank" rel="noopener">Greenplum</a>: 基于PostgreSQL的分布式MPP数据库</li>
<li>Mesos：计算框架一个集群管理器，提供了有效的、跨分布式应用或框架的资源隔离和共享</li>
<li>Impala：新一代开源大数据分析引擎，提供Sql语义，比Hive强在速度上</li>
<li>presto: facebook的开源工具，大数据分布式sql查询引擎</li>
<li>SNAPPY：快速的数据压缩系统，适用于Hadoop生态系统中</li>
<li>Kafka:高吞吐量的分布式消息队列系统</li>
<li>ActiveMQ:是Apache出品，最流行的，能力强劲的开源消息总线</li>
<li>MQTT:Message Queuing Telemetry Transport，消息队列遥测传输）是IBM开发的一个即时通讯协议，有可能成为物联网的重要组成部分</li>
<li>RabbitMQ：记得OpenStack就是用的这个东西吧</li>
<li>ZeroMQ：宣称是将分布式计算变得更简单，是个分布式消息队列，可以看下云风的一篇文章的介绍</li>
<li>开源的日志收集系统：scribe、chukwa、kafka、flume。这有一篇对比文章</li>
<li>Zookeeper：可靠的分布式协调的开源项目</li>
<li>Databus：LinkedIn 实时低延迟数据抓取系统</li>
<li>数据源获取：Flume、Google Refine、Needlebase、ScraperWiki、BloomReach</li>
<li>序列化技术：JSON、BSON、Thrift、Avro、Google Protocol Buffers</li>
<li>NoSql：ScyllaDB（宣称是世界上最快的NoSql）、Apache Casandra、MongoDB、Apache CouchDB、Redis、BigTable、HBase、Hypertable、Voldemort、Neo4j</li>
<li>MapReduce相关：Hive、Pig、Cascading、Cascalog、mrjob、Caffeine、S4、MapR、Acunu、Flume、Kafka、Azkaban、Oozie、Greenplum </li>
<li>数据处理：R、Yahoo! Pipes、Mechanical Turk、Solr/ Lucene、ElasticSearch、Datameer、Bigsheets、Tinkerpop</li>
<li>NLP自然语言处理：Natural Language Toolkit、Apache OpenNLP、Boilerpipe、OpenCalais</li>
<li>机器学习：TensorFlow（Google出品），WEKA、Mahout、scikits.learn、SkyTree</li>
<li>可视化技术：GraphViz、Processing、Protovis、Google Fusion Tables、Tableau、Highcharts、EChats（百度的还不错）、Raphaël.js</li>
<li>Kettle：开源的ETL工具</li>
<li>Pentaho：以工作流为核心的开源BI系统</li>
<li>Mondrian：开源的Rolap服务器</li>
<li>Oozie：开源hadoop的工作流调度引擎，类似的还有：Azkaban</li>
<li>开源的数据分析可视化工具：Weka、Orange、KNIME</li>
<li>Cobar：阿里巴巴的MySql分布式中间件</li>
<li>数据清洗：data wrangler， Google Refine</li>
</ul>
<h2 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h2><ul>
<li><a href="https://material.io/" target="_blank" rel="noopener">Material Design</a>: 谷歌出品，必属精品</li>
<li>Vue.js: 借鉴了Angular及React的JS框架，设计理念较为先进</li>
<li><a href="https://github.com/jsplumb/jsplumb" target="_blank" rel="noopener">jsplumb</a>: 流程图可视化库</li>
<li><a href="https://github.com/cytoscape/cytoscape.js" target="_blank" rel="noopener">cytoscape.js</a>: 关系图谱可视化库</li>
<li><a href="https://github.com/d3/d3" target="_blank" rel="noopener">d3</a>: 非常知名的数据可视化库（类似的还有NVD3，P5.js，Highcharts，Echart，Flot等）</li>
<li><a href="https://vega.github.io/vega/" target="_blank" rel="noopener">Vega</a>: 基于D3的可视化语法</li>
<li><a href="https://github.com/densitydesign/raw" target="_blank" rel="noopener">Raw</a>：非常不错的一款高级数据可视化工具</li>
<li>Rickshaw: 时序图表库，可用于构建实时图表</li>
<li>JavaScript InfoVis Toolkit：另一款Web数据可视化插件</li>
<li>Pdf.js，在html中展现pdf</li>
<li>ACE，CodeMirror：Html代码编辑器（ACE甚好啊）</li>
<li>NProcess：绚丽的加载进度条</li>
<li>impress.js：让你制作出令人眩目的内容展示效果(类似的还有reveal)</li>
<li>Threejs：3DWeb库</li>
<li>Hightopo：基于Html5的2D、3D可视化UI库</li>
<li>jQuery.dataTables.js:高度灵活的表格插件</li>
<li>Raphaël：js，canvas绘图库，后来发现百度指数的图形就是用它绘出来的</li>
<li>director.js：js路由模块，前端路由，Nodejs后端路由等，适合构造单页应用</li>
<li>pace.js：页面加载进度条</li>
<li>bower：Web包管理器</li>
<li>jsnice：有趣的js反编译工具，猜压缩后的变量名，<a href="http://www.jsnice.org/" target="_blank" rel="noopener">http://www.jsnice.org/</a></li>
<li>Zepto.js：移动端替代jQuery的东东，当然也可以使用jquery-mobile.</li>
<li>UI框架：Foundation，Boostrap，Pure，EasyUI，Polymer</li>
<li>前端UI设计师必去的几个网站：Dribbble，awwwards，unmatchedstyle，UIMaker</li>
<li>Mozilla 开发者中心：<a href="https://developer.mozilla.org/en-US/" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/</a></li>
<li>图标资源：IcoMoon（我的最爱），Font Awesome, Themify Icons，FreePik，Glyphicons</li>
<li>artDialog:非常漂亮的对话框</li>
<li>AdminLTE：github上的一个开源项目，基于Boostrap3的后台管理页面框架</li>
<li>Respond.js：让不懂爱的IE6-8支持响应式设计</li>
<li>require.js: js模块加载库</li>
<li>select2：比chosen具有更多特性的选择框替代库</li>
<li>AngularUI：集成angular.js的UI库</li>
<li>normalize.css: 采用了现代化标准让各浏览器渲染出的html保持一致的库</li>
<li>CreateJS：Html5游戏引擎</li>
<li>Less,Compass:简化CSS开发</li>
<li>emojify.js:用于自动识别网页上的Emoji文字并将其显示为图像</li>
<li>simditor:一个不错的开源的html编辑器，简洁高效</li>
<li>Sencha:  基于html5的移动端开发框架</li>
<li>SuperScrollorama+TweenMax+skrollr:打造超酷的视差滚动效果网页动画</li>
<li>jquery-smooth-scroll:同上，平滑滚动插件</li>
<li>Animate.css:实现了各种动画效果的css库</li>
<li>Emmet:前端工程师必备，前身为 Zen Coding</li>
<li>React: facebook出品的js UI库</li>
<li>highlight.js：专门用来做语法高亮的库</li>
<li>GoJS: Html5交互式图表库，看demo更适合层次结构的图表。</li>
<li>10 Pure CSS (Mostly) Flat Mobile Devices: <a href="http://marvelapp.github.io/devices.css/" target="_blank" rel="noopener">http://marvelapp.github.io/devices.css/</a></li>
<li>CodePen: <a href="http://codepen.io/" target="_blank" rel="noopener">http://codepen.io/</a></li>
<li>jsfiddle: <a href="http://jsfiddle.net/" target="_blank" rel="noopener">http://jsfiddle.net/</a> 前端js，html，css测试利器</li>
</ul>
<h2 id="语言篇"><a href="#语言篇" class="headerlink" title="语言篇"></a>语言篇</h2><p>折腾中：Scala、Python、Lua、JavaScript、Go</p>
<p>待折腾：</p>
<ul>
<li><a href="http://racket-lang.org/" target="_blank" rel="noopener">Racket</a></li>
<li><a href="http://ocaml.org/" target="_blank" rel="noopener">OCaml</a></li>
<li><a href="https://www.rust-lang.org" target="_blank" rel="noopener">Rust</a></li>
<li><a href="http://julialang.org/" target="_blank" rel="noopener">Julia</a></li>
</ul>
<h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><ul>
<li><a href="http://www.scala-lang.org/api/current/" target="_blank" rel="noopener">Scala Standard Library API</a></li>
<li><a href="http://twitter.github.io/scala_school/" target="_blank" rel="noopener">Scala School!</a>: A Scala tutorial by Twitter</li>
<li><a href="http://docs.scala-lang.org/tutorials/tour/tour-of-scala.html" target="_blank" rel="noopener">A Tour of Scala</a>: Tutorial introducing the main concepts of Scala</li>
<li><a href="http://stackoverflow.com/tags/scala/info" target="_blank" rel="noopener">Scala Overview on StackOverflow</a>: A list of useful questions sorted by topic</li>
<li><a href="http://www.artima.com/pins1ed/" target="_blank" rel="noopener">Programming in Scala</a>，最新的第3版，还没有电子版，电子版是第一版</li>
<li>《Scala for the Impatient》</li>
<li>《Scala in Depth》</li>
<li>《Programming Scala》Dean Wampler and Alex Payne. O’Reilly 2009</li>
<li><a href="http://www.scala-lang.org/docu/files/ScalaByExample.pdf" target="_blank" rel="noopener">Scala By Example</a></li>
<li><a href="http://docs.scala-lang.org/cheatsheets/" target="_blank" rel="noopener">Scala Cheatsheet</a>学习模式匹配的好资料</li>
<li><a href="http://docs.scala-lang.org/glossary/" target="_blank" rel="noopener">Glossary of Scala and FP terms</a></li>
<li><a href="https://github.com/lihaoyi/Metascala" target="_blank" rel="noopener">Metascala: A JVM written in Scala</a></li>
<li><a href="https://scala-lms.github.io/" target="_blank" rel="noopener">LMS: Program Generation and Embedded Compilers in Scala</a></li>
<li><a href="https://github.com/sirthias/parboiled2" target="_blank" rel="noopener">parboiled2</a>: 性能很好的parser</li>
</ul>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><ul>
<li>常用的IDE：<a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>(强烈推荐)，Eclipse，Netbeans</li>
<li><a href="http://fastutil.di.unimi.it/" target="_blank" rel="noopener">fastutil</a>: 性能更好的Java集合框架</li>
<li><a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava</a>: 谷歌的Java工具包，应用广泛</li>
<li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="noopener">JMH</a>: Java Benchmark性能测试框架</li>
<li><a href="https://vertx.io/" target="_blank" rel="noopener">Vert.x</a>: 性能彪悍的异步非阻塞编程框架</li>
<li><a href="https://www.lagomframework.com/" target="_blank" rel="noopener">Lagom</a>: 微服务框架，提供了Java、Scala API</li>
<li>jOOQ：java Orm框架</li>
<li>Janino: 超级小又快的Java编译器，Spark的Tungsten引起用的它</li>
<li>Curator：Netflix公司开源的一个Zookeeper client library，用于简化Zookeeper客户端编程，现在已经是apache下的一个独立项目了。Spark的HA也用的这货。</li>
<li>Rx(Reactive Extensions)框架：RxJava(Android中用的比较多),  Quasar</li>
<li>FindBugs: 代码静态分析工具，找出代码缺陷</li>
<li>Java反编译工具：Luyten，JD-Gui,Procyon-Decompiler</li>
<li>Drools: 规则引擎</li>
<li>Jersey: Java RESTful 框架</li>
<li>canal: 阿里巴巴出品，binlog增量订阅&消费组件</li>
<li>Web开发相关：Tomcat、Resin、Jetty、WebLogic等，常用的组件Struts，Spring，Hibernate</li>
<li>Netty: 异步事件驱动网络应用编程框架，用于高并发网络编程比较好（NIO框架，spark 1.2.0就用netty替代了nio）</li>
<li>MINA：简单地开发高性能和高可靠性的网络应用程序（也是个NIO框架），不少手游服务端是用它开发的</li>
<li>Activiti:工作流引擎，类似的还有jBPM、Snaker</li>
<li>Perfuse:是一个用户界面包用来把有结构与无结构数据以具有交互性的可视化图形展示出来.</li>
<li>Gephi:复杂网络分析软件, 其主要用于各种网络和复杂系统，动态和分层图的交互可视化与探测开源工具</li>
<li>Nutch:知名的爬虫项目，hadoop就是从这个项目中发展出来的</li>
<li>web-harvest：Web数据提取工具</li>
<li>POM工具：Maven+Artifactory</li>
<li>Akka:一款基于actor模型实现的 并发处理框架</li>
<li>EclEmma：覆盖测试工具</li>
<li>Shiro:安全框架</li>
<li>joda-time:简化时间处理</li>
<li>parboiled:表达式解析</li>
<li>dozer: 深拷贝神器</li>
<li>dubbo: 阿里巴巴出品的分布式服务框架</li>
<li>jackson databind: json序列化工具(fastjson,simplejson)</li>
<li>Atomikos: 分布式事务管理</li>
<li>BoneCP：性能很赞的数据库连接池组件，据说比c3p0快好多</li>
<li>ProGuard: obconfuscation tool, 强大的混淆工具</li>
<li>S-99：Scala相关的99个问题</li>
</ul>
<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><ul>
<li>PyCharm：最佳Python IDE</li>
<li>Eric,Eclipse+pydev,比较不错的Python IDE</li>
<li>PyWin:Win32 api编程包</li>
<li>numpy:科学计算包，主要用来处理大型矩阵计算等，此外还有SciPy，Matplotlib</li>
<li>GUI相关：PyQt，PyQwt</li>
<li>supervisor:进程监控工具</li>
<li>PyGame: 基于Python的多媒体开发和游戏软件开发模块</li>
<li>Web框架: Django 开源web开发框架，它鼓励快速开发,并遵循MVC设计</li>
</ul>
<h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul>
<li><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="noopener">Swift精选资料</a></li>
<li><a href="http://www.csdn.net/article/2015-01-09/2823502-swift-open-source-libs" target="_blank" rel="noopener">43个优秀的开源项目</a></li>
</ul>
<p><strong>客户端</strong></p>
<ul>
<li><a href="https://github.com/YANGReal/JokeClient-Swift" target="_blank" rel="noopener">糗事百科 Swift</a></li>
<li><a href="https://github.com/amitburst/HackerNews" target="_blank" rel="noopener">HackerNews Swift</a></li>
<li><a href="https://github.com/jxd001/Swift-ZhihuDaily" target="_blank" rel="noopener">知乎日报app</a></li>
</ul>
<p><strong>Framework</strong></p>
<ul>
<li><a href="https://github.com/mattdonnelly/Swifter" target="_blank" rel="noopener">Twitter框架</a></li>
<li><a href="https://github.com/glock45/swifter" target="_blank" rel="noopener">Mac下简单HTTP Server Swifter</a></li>
</ul>
<p><strong>小工具</strong></p>
<ul>
<li><a href="https://github.com/ChrisChares/swift-alarm" target="_blank" rel="noopener">Swift Alarm</a></li>
<li><a href="https://github.com/mslathrop/SwiftNote" target="_blank" rel="noopener">Swift Note</a></li>
<li><a href="https://github.com/wantedly/swift-rss-sample" target="_blank" rel="noopener">Swift RSS Reader</a></li>
<li><a href="https://github.com/sxyx2008/Swift-PM25" target="_blank" rel="noopener">Swift-PM2.5查询app</a></li>
</ul>
<p><strong>游戏</strong></p>
<ul>
<li><a href="https://github.com/fullstackio/FlappySwift" target="_blank" rel="noopener">Flappy Swift</a></li>
<li><a href="https://github.com/geek5nan/FanFanSwift" target="_blank" rel="noopener">FanFan Swift</a></li>
</ul>
<h3 id="NET"><a href="#NET" class="headerlink" title=".NET"></a>.NET</h3><ul>
<li>Xilium.CefGlue:基于CEF框架的.NET封装，基于.NET开发Chrome内核浏览器</li>
<li>CefSharp：同上，有一款WebKit的封装，C#和Js交互会更简单</li>
<li>netz:免费的 .NET 可执行文件压缩工具</li>
<li>SmartAssembly:变态的.net代码优化混淆工具</li>
<li>NETDeob0：.net反混淆工具，真是魔高一尺道高一丈啊(还有个de4dot，在GitHub上，都是开源的)</li>
<li>ILMerge：将所有引用的DLL和exe文件打成一个exe文件</li>
<li>ILSpy:开源.net程序反编译工具</li>
<li>Javascript.NET：很不错的js执行引擎，对v8做了封装</li>
<li>NPOI: Excel操作</li>
<li>DotRAS:远程访问服务的模块</li>
<li>WinHtmlEditor: Winform下的html编辑器</li>
<li>SmartThreadPool:使用C#实现的，带高级特性的线程池</li>
<li>Snoop: WPF Spy Utility</li>
<li>Autofac: 轻量级IoC框架</li>
<li>HtmlAgilityPack：Html解析利器</li>
<li>Quartz.NET：Job调度</li>
<li>HttpLib：@CodePlex，简化http请求</li>
<li>SuperSocket：简化Socket操作，基于他的还有个SuperWebSocket，可以开发独立的WebSocket服务器了</li>
<li>DocX：未安装Office的情况下操作Word文件</li>
<li>Dapper：轻量级的ORM类，性能不错</li>
<li>HubbleDotNet：支持接入数据库的全文搜索系统</li>
<li>fastJSON：@CodeProject，高性能的json序列化类</li>
<li>ZXing.NET：@CodePlex，QR，条形码相关</li>
<li>Nancy：轻量级Http服务器，做个小型的Web应用可以摆脱IIS喽(Nancy.Viewengines.Razor,可以加入Razor引擎)</li>
<li>AntiXSS：微软的XSS防御库Microsoft Web Protection Library</li>
<li>Jint：JavaScript解释器</li>
<li>CS-Script：将C#代码文件作为脚本执行</li>
<li>Jexus：Linux下 高性能、易用、免费的ASP.NET服务器</li>
<li>Clay：将dynamic发挥的更加灵活，像写js一样写C#</li>
<li>DynamicJSON：不必定义数据模型获取json数据</li>
<li>SharpPcap：C#版的WinPcap调用端，牛逼的网络包分析库（自带PacketNotNet用于包协议分析）</li>
<li>Roslyn：C#，VB编译器</li>
<li>ImageResizer: 服务端自由控制图片大小，真乃神器也，对手机端传小图，PC端传大图，CMS用它很方便</li>
<li>UI相关：DevExpress, Fluent(Office 07风格), mui（Modern UI for WPF）</li>
<li>NetSparkle：应用自动更新组件</li>
<li>ConfuserEx: 开源.net混淆工具</li>
<li>ServiceStack: 开源高性能Web服务框架，可用于构建高性能的REST服务</li>
<li>Expression Evaluator：Eval for C#,处理字符串表达式</li>
<li><a href="http://nugetmusthaves.com/" target="_blank" rel="noopener">http://nugetmusthaves.com/</a></li>
<li>Reactive Extensions (Rx):异步，事件驱动编程包， Rx = Observables + LINQ + Schedulers</li>
</ul>
<h3 id="C-amp-C"><a href="#C-amp-C" class="headerlink" title="C & C++"></a>C & C++</h3><ul>
<li>Thrift:用来进行可扩展且跨语言的服务的开发(类似的还有个Avro，Google protobuf)。</li>
<li>libevent:是一个事件触发的网络库，适用于windows、linux、bsd等多种平台，内部使用select、epoll、kqueue等系统调用管理事件机制。（对了还有个libev呢）</li>
<li>Boost:不多说了，准C++标准库</li>
<li>Valgrind\Ptmalloc\Purify: 调试工具</li>
<li>NetworkServer架构：acceptor->dispatcher->worker(这个不算工具哦)</li>
<li><a href="https://pocoproject.org/" target="_blank" rel="noopener">POCO</a> - 开源的C++类库及应用程序框架的集合,它主要提供简单的、快速的网络和可移植应用程序</li>
<li>breakpad:崩溃转储和分析模块，很多crashreport会用到</li>
<li>UI界面相关：MFC、BCG和QT这类的就不说了，高端一点的还有Html和DirectUI技术：libcef（基于chrome内核的，想想使用html5开发页面，还真有点小激动呢）、HtmlLayout、Duilib、Bolt，非C++的，还有node-webkit也不错，集成了node和webkit内核。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="游戏开发相关"><a href="#游戏开发相关" class="headerlink" title="游戏开发相关"></a>游戏开发相关</h3><ul>
<li>MINA：使用Java开发手游和页游服务器(对了还有Netty，也很猛的，都是基于NIO的)</li>
<li>HP-Socket：见有有些页游服务器使用这个构建的</li>
<li>Unreal: 虚幻引擎，C++，基于这个引擎的游戏很多</li>
<li>OGRE：大名鼎鼎的3D图形渲染引擎，天龙八部OL、火炬之光等不少游戏都用了这个引擎</li>
<li>OpenVDB：梦工厂C++的特效库，开源的</li>
<li>cocos2d：跨平台2D游戏引擎</li>
<li>unity3d：跨平台3D游戏引擎，很火的哦</li>
<li>Nodejs：也有不少使用它来开发手游和页游服务器（网易的Pomelo）</li>
</ul>
<h3 id="日志聚合，分布式日志收集"><a href="#日志聚合，分布式日志收集" class="headerlink" title="日志聚合，分布式日志收集"></a>日志聚合，分布式日志收集</h3><ul>
<li>Scribe：Facebook的（nodejs + scribe + inotify 同步日志）</li>
<li>logstash:强大的日志收集系统，可以基于logstash+kibana+elasticsearch+redis开发强大的日志分析平台</li>
<li>log.io: nodejs开发的实时日志收集系统</li>
<li>Graylog: 易用、功能丰富的日志管理系统， 部署、维护、搜索比<code>ELK</code>简单</li>
</ul>
<h3 id="RTP-实时传输协议与音视频"><a href="#RTP-实时传输协议与音视频" class="headerlink" title="RTP,实时传输协议与音视频"></a>RTP,实时传输协议与音视频</h3><ul>
<li>RTP，RTCP，RTSP-> librtp，JRTPLIB(遵循了RFC1889标准)</li>
<li>环形缓冲区，实时数据传输用</li>
<li>SDL,ffmpeg,live555,Speex</li>
<li>Red5:用Java开发开源的Flash流媒体服务器。它支持：把音频（MP3）和视频（FLV）转换成播放流； 录制客户端播放流（只支持FLV）；共享对象；现场直播流发布；远程调用。</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>整理</category>
      </categories>
      <tags>
        <tag>整理</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年2月末端</title>
    <url>/2020/02/29/leapYear/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>四年一遇的日子<br>我数着远处多汁的河流<br>树木、车辆、人影<br>灯火和建筑<br>我数着一切热爱和悲伤<br>窗外突然下起小雨<br>淅淅沥沥<br>少年悄悄低头<br>在记事本上写下了心里的秘密<br>留给，四年后的自己~</p>
</body></html>]]></content>
  </entry>
  <entry>
    <title>lerna 包管理</title>
    <url>/2020/04/09/lerna/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="lerna（大型前端项目模块管理工具）"><a href="#lerna（大型前端项目模块管理工具）" class="headerlink" title="lerna（大型前端项目模块管理工具）"></a>lerna（大型前端项目模块管理工具）</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p><a href="https://github.com/lerna/lerna" target="_blank" rel="noopener">Lerna</a>是一个工具，它优化了使用git和npm管理多包存储库的工作流；vue、babel、react等都在用。</p>
<h2 id="2、工作模式"><a href="#2、工作模式" class="headerlink" title="2、工作模式"></a>2、工作模式</h2><p>lerna有2种工作模式</p>
<ul>
<li><h3 id="Fixed-Locked-mode-default"><a href="#Fixed-Locked-mode-default" class="headerlink" title="Fixed/Locked mode (default)"></a>Fixed/Locked mode (default)</h3></li>
</ul>
<p>vue,babel都是用这种，在<code>publish</code>的时候,会在<code>lerna.json</code>文件里面<code>"version": "0.1.5",</code>,依据这个号，进行增加，只选择一次，其他有改动的包自动更新版本号，会统一的使用这一个发布的版本号。</p>
<ul>
<li><h3 id="Independent-mode"><a href="#Independent-mode" class="headerlink" title="Independent mode"></a>Independent mode</h3></li>
</ul>
<pre><code class="javascript">lerna init --independent`初始化项目。
`lerna.json`文件里面`"version": "independent",</code></pre>
<p>每次<code>publish</code>时，您都将得到一个提示符，提示每个已更改的包，以指定是补丁、次要更改、主要更改还是自定义更改。</p>
<p><a href="01.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="01.png" class="lazyload"></a></p>
<h2 id="3、快速开始"><a href="#3、快速开始" class="headerlink" title="3、快速开始"></a>3、快速开始</h2><pre><code class="javascript">    $ npm install lerna -g
    $ mkdir lerna-gp && cd $_
    $ npm lerna init # 用的默认的固定模式，vue babel等都是这个

     # Add packages
    $ cd packages
    $ mkdir daybyday gpnode gpwebpack
    ...
    #分别进入三个目录初始化成包
    $ cd daybyday
    $ npm init -y 
    $ cd ../gpnode
    $ npm init -y
    $ cd ../gpwebpack
    $ npm init -y</code></pre>
<h3 id="4-、-项目结构"><a href="#4-、-项目结构" class="headerlink" title="4 、 项目结构"></a>4 、 项目结构</h3><pre><code class="json">➜  lerna-gp git:(master) ✗ tree
.
├── lerna.json
├── package.json
└── packages
    ├── daybyday
    │   └── package.json
    ├── gpnode
    │   └── package.json
    └── gpwebpack
        └── package.json

4 directories, 5 files</code></pre>
<h2 id="5、-Set-up"><a href="#5、-Set-up" class="headerlink" title="5、 Set up"></a>5、 Set up</h2><h3 id="Set-up-git-npm"><a href="#Set-up-git-npm" class="headerlink" title="Set up git + npm"></a>Set up git + npm</h3><pre><code class="javascript">✗ git remote add origin git@gitlab.yourSite.com:gaopo/lerna-gp.git

#查看是否登录
✗ npm whoami
gp0320

#没有则登录 
npm login 
# 输入username password 
Logged in as gp0320 on https://registry.npmjs.org/. # succeed</code></pre>
<h3 id="Set-up-yarn的workspaces模式"><a href="#Set-up-yarn的workspaces模式" class="headerlink" title="Set up yarn的workspaces模式"></a>Set up yarn的workspaces模式</h3><blockquote>
<p>默认是npm, 而且每个子package都有自己的<code>node_modules</code>，通过这样设置后，只有顶层有一个<code>node_modules</code></p>
</blockquote>
<ul>
<li>修改顶层 <code>package.json and lerna.json</code></li>
</ul>
<pre><code class="json"># package.json 文件加入
 "private": true,
  "workspaces": [
    "packages/*"
  ],

# lerna.json 文件加入
"useWorkspaces": true,
"npmClient": "yarn",
</code></pre>
<h2 id="6-、Lerna-Script"><a href="#6-、Lerna-Script" class="headerlink" title="6 、Lerna Script"></a>6 、Lerna Script</h2><h3 id="lerna-create-loc"><a href="#lerna-create-loc" class="headerlink" title="lerna create  [loc]"></a>lerna create <name> [loc]</name></h3><blockquote>
<p>创建一个包，name包名，loc 位置可选</p>
</blockquote>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="javascript"># 根目录的package.json 
 "workspaces": [
    "packages/*",
    "packages/@gp0320/*"
  ],

# 创建一个包gpnote默认放在 workspaces[0]所指位置
lerna create gpnote 

# 创建一个包gpnote指定放在 packages/@gp0320文件夹下，注意必须在workspaces先写入packages/@gp0320，看上面
lerna create gpnote packages/@gp0320</code></pre>
<h3 id="lerna-add-version-–dev-–exact"><a href="#lerna-add-version-–dev-–exact" class="headerlink" title="lerna add [@version] [–dev] [–exact]"></a>lerna add <package>[@version] [–dev] [–exact]</package></h3><blockquote>
<p>增加本地或者远程<code>package</code>做为当前项目<code>packages</code>里面的依赖</p>
</blockquote>
<ul>
<li><code>--dev</code> devDependencies 替代 <code>dependencies</code></li>
<li><code>--exact</code> 安装准确版本，就是安装的包版本前面不带<code>^</code>, Eg: <code>"^2.20.0" ➜ "2.20.0"</code></li>
</ul>
<h4 id="Examples-1"><a href="#Examples-1" class="headerlink" title="Examples"></a>Examples</h4><pre><code class="javascript"># Adds the module-1 package to the packages in the 'prefix-' prefixed folders
lerna add module-1 packages/prefix-*

# Install module-1 to module-2
lerna add module-1 --scope=module-2

# Install module-1 to module-2 in devDependencies
lerna add module-1 --scope=module-2 --dev

# Install module-1 in all modules except module-1
lerna add module-1

# Install babel-core in all modules
lerna add babel-core</code></pre>
<h3 id="lerna-bootstrap"><a href="#lerna-bootstrap" class="headerlink" title="lerna bootstrap"></a>lerna bootstrap</h3><p>默认是npm i,因为我们指定过yarn，so,run yarn install,会把所有包的依赖安装到根<code>node_modules</code>.</p>
<h3 id="lerna-list"><a href="#lerna-list" class="headerlink" title="lerna list"></a>lerna list</h3><p>列出所有的包，如果与你文夹里面的不符，进入那个包运行<code>yarn init -y</code>解决</p>
<pre><code>➜  lerna-gp git:(master) ✗ lerna list
lerna notice cli v3.14.1
daybyday
gpnode
gpnote
gpwebpack
lerna success found 4 packages</code></pre><h3 id="lerna-import"><a href="#lerna-import" class="headerlink" title="lerna import "></a>lerna import <path-to-external-repository></path-to-external-repository></h3><p>导入本地已经存在的包</p>
<p><a href="02.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="02.png" class="lazyload"></a></p>
<h3 id="lerna-run"><a href="#lerna-run" class="headerlink" title="lerna run"></a>lerna run</h3><pre><code>lerna run < script > -- [..args] # 运行所有包里面的有这个script的命令
$ lerna run --scope my-component test</code></pre><h3 id="lerna-exec"><a href="#lerna-exec" class="headerlink" title="lerna exec"></a>lerna exec</h3><p>运行任意命令在每个包</p>
<pre><code>$ lerna exec -- < command > [..args] # runs the command in all packages
$ lerna exec -- rm -rf ./node_modules
$ lerna exec -- protractor conf.js
lerna exec --scope my-component -- ls -la</code></pre><h3 id="lerna-link"><a href="#lerna-link" class="headerlink" title="lerna link"></a>lerna link</h3><p>项目包建立软链，类似npm link</p>
<h3 id="lerna-clean"><a href="#lerna-clean" class="headerlink" title="lerna clean"></a>lerna clean</h3><p>删除所有包的node_modules目录<br><a href="03.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="03.png" class="lazyload"></a></p>
<h3 id="lerna-changed"><a href="#lerna-changed" class="headerlink" title="lerna changed"></a>lerna changed</h3><p>列出下次发版<code>lerna publish</code> 要更新的包。</p>
<p>原理：<br>需要先git add,git commit 提交。<br>然后内部会运行<code>git diff --name-only v版本号</code>，搜集改动的包，就是下次要发布的。并不是网上人说的所有包都是同一个版全发布。</p>
<pre><code>➜  lerna-repo git:(master) ✗ lerna changed                                     
info cli using local version of lerna
lerna notice cli v3.14.1
lerna info Looking for changed packages since v0.1.4
daybyday #只改过这一个 那下次publish将只上传这一个
lerna success found 1 package ready to publish</code></pre><h3 id="lerna-publish"><a href="#lerna-publish" class="headerlink" title="lerna publish"></a>lerna publish</h3><p>会打tag，上传git,上传npm。<br>如果你的包名是带scope的例如：<code>"name": "@gp0320/gpwebpack",</code><br>那需要在packages.json添加</p>
<pre><code> "publishConfig": {
    "access": "public"
  },
lerna publish 
lerna info current version 0.1.4
#这句意思是查找从v0.1.4到现在改动过的包
lerna info Looking for changed packages since v0.1.4 

? Select a new version (currently 0.1.4) Patch (0.1.5)

Changes:
 - daybyday: 0.1.3 => 0.1.5 #只改动过一个

...

Successfully published:
 - daybyday@0.1.5
lerna success published 1 package</code></pre></body></html>]]></content>
      <categories>
        <category>包管理（前端）</category>
      </categories>
      <tags>
        <tag>lerna</tag>
      </tags>
  </entry>
  <entry>
    <title>H5移动端适配</title>
    <url>/2020/04/08/mobile-adpat-pixel/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="media-H5移动端屏幕适配"><a href="#media-H5移动端屏幕适配" class="headerlink" title="@media H5移动端屏幕适配"></a>@media H5移动端屏幕适配</h1><h2 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h2><pre><code>name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"</code></pre><blockquote>
<ul>
<li>viewport ：用户网页的可视区域.</li>
<li>width：控制viewport的大小，可以指定一个值，如600，或者特殊的值，如device-width为设备的宽度（单位为缩放100%时的CSS的像素）。</li>
<li>height：和 width 相对应，指定高度。</li>
<li>initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li>
<li>maximum-scale：允许用户缩放到的最大比例。</li>
<li>user-scalable：用户是否可以手动缩放。</li>
</ul>
</blockquote>
<h2 id="移动端手机尺寸"><a href="#移动端手机尺寸" class="headerlink" title="移动端手机尺寸"></a>移动端手机尺寸</h2><h3 id="1-phone4-iphone5-SE-width是一样"><a href="#1-phone4-iphone5-SE-width是一样" class="headerlink" title="1. phone4/iphone5/SE(width是一样)"></a>1. phone4/iphone5/SE(width是一样)</h3><pre><code class="scss">// 特殊场景，写法不一，比如：
1. @media screen and (max-width:320px ){}
2. @media screen and (max-height:480px ){}
3. @media screen and (max-width:320px ) and (max-height:480px ){}</code></pre>
<h3 id="2-iphone6-7-8"><a href="#2-iphone6-7-8" class="headerlink" title="2. iphone6/7/8"></a>2. iphone6/7/8</h3><pre><code class="scss">// 有时候我们只需要获取width 或者height 其中一个即可
1. @media screen and (max-width:375px ){}
2. @media screen and (max-height:667px ){}</code></pre>
<h3 id="3-iphone6-7-8-Plus"><a href="#3-iphone6-7-8-Plus" class="headerlink" title="3. iphone6/7/8 Plus"></a>3. iphone6/7/8 Plus</h3><pre><code class="scss">1. @media screen and (max-width:414px ){}
2. @media screen and (max-height:736px ){}</code></pre>
<h3 id="4-iPhone-XS-5-8-英寸"><a href="#4-iPhone-XS-5-8-英寸" class="headerlink" title="4. iPhone XS: 5.8 英寸"></a>4. iPhone XS: 5.8 英寸</h3><pre><code class="scss">@media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3){}</code></pre>
<h3 id="5-iPhone-XR-6-1-英寸"><a href="#5-iPhone-XR-6-1-英寸" class="headerlink" title="5. iPhone XR: 6.1 英寸"></a>5. iPhone XR: 6.1 英寸</h3><pre><code class="css">@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2){}</code></pre>
<h3 id="6-iPhone-XS-Max-6-5-英寸"><a href="#6-iPhone-XS-Max-6-5-英寸" class="headerlink" title="6. iPhone XS Max: 6.5 英寸"></a>6. iPhone XS Max: 6.5 英寸</h3><pre><code class="css">@media only screen and (device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3){}</code></pre>
<h2 id="获取屏幕尺寸"><a href="#获取屏幕尺寸" class="headerlink" title="获取屏幕尺寸"></a>获取屏幕尺寸</h2><pre><code class="dart">// 屏幕可以大小
screen.availWidth+"/"+screen.availHeight
// 屏幕分辨率
screen.width+"/"+screen.height
// 网页可见区域
document.body.clientWidth +"/"+ document.body.clientHeight
// 网页可见区域(包括边线的宽)
document.body.offsetWidth +"/"+ document.body.offsetHeight</code></pre>
</body></html>]]></content>
      <categories>
        <category>移动端</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title>基于docker、nginx配置通过http/https访问服务</title>
    <url>/2020/04/22/nginx-http-https/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="基于docker、nginx配置通过http-https访问服务"><a href="#基于docker、nginx配置通过http-https访问服务" class="headerlink" title="基于docker、nginx配置通过http/https访问服务"></a>基于docker、nginx配置通过http/https访问服务</h1><h2 id="1-下载nginx镜像"><a href="#1-下载nginx镜像" class="headerlink" title="1. 下载nginx镜像"></a>1. 下载nginx镜像</h2><pre><code class="ruby">$ docker pull nginx:latest</code></pre>
<h2 id="2-启动nginx容器"><a href="#2-启动nginx容器" class="headerlink" title="2. 启动nginx容器"></a>2. 启动nginx容器</h2><p>运行如下命令来启动nginx container</p>
<pre><code class="jsx">docker run --detach 
        --name wx-nginx 
        -p 443:443
        -p 80:80 
        -v /home/evan/workspace/wxserver/nginx/data:/usr/share/nginx/html:rw
        -v /home/evan/workspace/wxserver/nginx/config/nginx.conf:/etc/nginx/nginx.conf/:rw
        -v /home/evan/workspace/wxserver/nginx/config/conf.d/default.conf:/etc/nginx/conf.d/default.conf:rw
        -v /home/evan/workspace/wxserver/nginx/logs:/var/log/nginx/:rw
        -v /home/evan/workspace/wxserver/nginx/ssl:/ssl/:rw
        -d nginx</code></pre>
<ul>
<li>映射端口443，用于https请求</li>
<li>映射端口80，用于http请求；</li>
<li>nginx的默认首页html的存放目录映射到host盘的目录， /home/evan/workspace/wxserver/nginx/data</li>
<li>nginx的配置文件映射到host盘的文件，/home/evan/workspace/wxserver/nginx/config/nginx.conf</li>
</ul>
<p>这里需要准备如下几个文件，</p>
<ol>
<li>nginx的配置文件<br>首先是nginx.conf文件，默认的配置文件如下</li>
</ol>
<pre><code class="php">#运行nginx的用户
user  nginx;
#启动进程设置成和CPU数量相等
worker_processes  1;

#全局错误日志及PID文件的位置
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

#工作模式及连接数上限
events {
        #单个后台work进程最大并发数设置为1024
    worker_connections  1024;
}


http {
        #设定mime类型
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

        #设定日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

        #设置连接超时的事件
    keepalive_timeout  65;

        #开启GZIP压缩
    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}</code></pre>
<p>可以看到最后一行还要包含另一个配置文件conf.d/default.conf，用来配置server字段</p>
<pre><code class="bash">server {
    listen    80;       #侦听80端口，如果强制所有的访问都必须是HTTPs的，这行需要注销掉
    server_name  www.buagengen.com;             #域名

    #charset koi8-r;
    #access_log  /var/log/nginx/host.access.log  main;

        # 定义首页索引目录和名称
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }

    #定义错误提示页面
    #error_page  404              /404.html;

    #重定向错误页面到 /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}</code></pre>
<ol>
<li>nginx的默认首页的html文件<br>这个html可以自己定义一个，任意的都可以。</li>
</ol>
<p>这个时候直接通过IP地址就可以访问nginx定义的这个html文件了。但是这个时候的访问只是http的，https的访问还是不行的，需要添加证书到nginx服务器。</p>
<h2 id="3-通过openssl生成证书"><a href="#3-通过openssl生成证书" class="headerlink" title="3. 通过openssl生成证书"></a>3. 通过openssl生成证书</h2><ul>
<li>设置server.key，这里需要设置两遍密码:</li>
</ul>
<pre><code class="csharp">openssl genrsa -des3 -out server.key 1024 </code></pre>
<ul>
<li>参数设置，首先这里需要输入之前设置的密码:</li>
</ul>
<pre><code class="csharp">openssl req -new -key server.key -out server.csr</code></pre>
<p>然后需要输入如下的信息，大概填一下就可以了，反正是测试用的</p>
<pre><code class="dart">Country Name (2 letter code) [AU]: 国家名称
State or Province Name (full name) [Some-State]: 省
Locality Name (eg, city) []: 城市
Organization Name (eg, company) [Internet Widgits Pty Ltd]: 公司名
Organizational Unit Name (eg, section) []: 
Common Name (e.g. server FQDN or YOUR name) []: 网站域名
Email Address []: 邮箱

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []: 这里要求输入密码
An optional company name []:</code></pre>
<ul>
<li>写RSA秘钥（这里也要求输入之前设置的密码）:</li>
</ul>
<pre><code class="css">openssl rsa -in server.key -out server_nopwd.key</code></pre>
<ul>
<li>获取私钥:</li>
</ul>
<pre><code class="css">openssl x509 -req -days 365 -in server.csr -signkey server_nopwd.key -out server.crt</code></pre>
<p>完成这一步之后就得到了我们需要的证书文件和私钥了</p>
<ul>
<li>server.crt</li>
<li>server.key</li>
</ul>
<h2 id="4-配置nginx服务器，支持https访问"><a href="#4-配置nginx服务器，支持https访问" class="headerlink" title="4. 配置nginx服务器，支持https访问"></a>4. 配置nginx服务器，支持https访问</h2><p>把前面一步生成的文件拷贝到host上的ssl目录，/home/evan/workspace/wxserver/nginx/ssl。<br>然后修改配置文件default.conf，添加ssl支持，</p>
<pre><code class="csharp">server {
    listen    80;       #侦听80端口，如果强制所有的访问都必须是HTTPs的，这行需要注销掉
    listen    443 ssl;
    server_name  www.buagengen.com;             #域名

    # 增加ssl
    #ssl on;        #如果强制HTTPs访问，这行要打开
    ssl_certificate /ssl/server.crt;
    ssl_certificate_key /ssl/server.key;

    ssl_session_cache    shared:SSL:1m;
    ssl_session_timeout  5m;

     # 指定密码为openssl支持的格式
     ssl_protocols  SSLv2 SSLv3 TLSv1.2;

     ssl_ciphers  HIGH:!aNULL:!MD5;  # 密码加密方式
     ssl_prefer_server_ciphers  on;   # 依赖SSLv3和TLSv1协议的服务器密码将优先于客户端密码

     # 定义首页索引目录和名称
     location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
     }

    #重定向错误页面到 /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}</code></pre>
<p>重启nginx容器，现在就可以通过https来访问nginx的服务器了</p>
</body></html>]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>使用node从零搭建自动化部署管理平台</title>
    <url>/2019/12/02/node-h5-cicd/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="抛弃jenkins，使用node从零搭建自动化部署管理平台"><a href="#抛弃jenkins，使用node从零搭建自动化部署管理平台" class="headerlink" title="抛弃jenkins，使用node从零搭建自动化部署管理平台"></a>抛弃jenkins，使用node从零搭建自动化部署管理平台</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>  H5页面由于其具有发布灵活、跨平台、易于传播等突出特点，所以H5页面是引流拉新、宣传推广的重要渠道和方式，备受各公司的青睐。<br>  在整个开发周期中，结合我司的一些情况，我总结了H5活动页面的以下特点：</p>
<blockquote>
<ul>
<li>面向用户，流量大；</li>
</ul>
</blockquote>
<ul>
<li>各端展示方案不同，需要兼容各端（比如活动规则、展示模块，ios和android不一样）；</li>
<li>需求变更频繁；</li>
<li>合作方较多（需要跟各个业务线合作联调）；</li>
<li>排期紧张；</li>
<li>所以开发测试期间，部署效率就显得特别重要了。</li>
</ul>
<p>  由于我司的CDN发布平台，需要手动创建模板、粘贴代码，部署效率比较低下；并且活动页面代码分散，无法统一管理和实现工程化，所以决定实现一套自动化部署系统，目前已经投入使用半年时间了，极大地提高了我们的工作效率。我称这个自动化部署系统为【H5 活动管理平台】。</p>
<h2 id="2-实现方案"><a href="#2-实现方案" class="headerlink" title="2. 实现方案"></a>2. 实现方案</h2><p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B201.png)
</p>

<p>  该平台实现主要依赖于本地开发工程、gitlab，三者之间通过通信交互，实现的自动化部署。</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B202.png)
</p>

<p>  最终达到的效果就是：当本地开发分支merge到测试分支devTest或者master分支时，该平台会自动拉取最新代码，构建目标文件，然后将目标文件部署到对应的服务器目录，另外提供了上下线、版本回滚、定时上下线等常用功能。</p>
<p>整体架构流程图：</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B203.png)
</p>

<h3 id="1-本地开发工程"><a href="#1-本地开发工程" class="headerlink" title="1. 本地开发工程"></a>1. 本地开发工程</h3><p>  我们的本地开发工程，是使用node + webpack + babel等相关技术搭建的多页面开发工程，不同的活动位于不同的目录。因为要做自动化构建部署处理，跟【H5活动管理平台】交互，所以有以下要点需要注意（可根据自己项目情况，自由调整方案）。</p>
<p>  本地开发工程作为自动化构建部署的源头，需要提供构建命令行用于构建测试文件和线上文件，便于后面shell命令调用。如在package.json中加入如下命令：</p>
<pre><code>"scripts": {
    "local": "cross-env NODE_ENV=local node build.js", // 本地开发命令
    "build": "cross-env NODE_ENV=product node build.js", // 构建上线文件
    "test": "cross-env NODE_ENV=test node build.js" // 构建测试文件
}</code></pre><p>  提供构建配置文件dev-config.js，用于过滤webpack构建时的入口目录，只构建编译当前正在开发的活动页面，提高构建速度。</p>
<pre><code>//dev-config.js
module.exports = {
    devPages: ['test']   //  当前自己正在开发页面目录，不写时会编译所有活动页面
}</code></pre><p>  提供活动页面目录信息配置config.json，该配置信息用于【H5活动管理平台】的展示，也就是效果图中的信息源。</p>
<pre><code>// config.json
{
  "pages": [
        {
            "folder": "lion",
            "desc": "前端名狮",
            "author": "诀九",
            "user": "juejiu"
        },
        {
            "folder": "test",
            "desc": "活动测试页面",
            "author": "诀九",
            "user": "juejiu"
        }
    ]
}</code></pre><p>  构建生成的 JS 和 HTML 文件，存放在 dist 目录下的对应活动目录中。构建生成的目录结构如下：</p>
<pre><code>|--dist
   |-- lion
       |-- lion_app.js
       |-- index.html
   |--test
       |-- test_app.js
       |-- index.html</code></pre><p>  提测时，将开发分支merge到devTest分支，上线时，将开发分支merge到master分支。<br>工程目录结构</p>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B204.png)
</p>

<h3 id="2-gitlab服务器"><a href="#2-gitlab服务器" class="headerlink" title="2. gitlab服务器"></a>2. gitlab服务器</h3><p>  Gitlab作为企业代码版本管理工具，提供了Webhook的功能配置，Webhook顾名思义，其实就是一钩子。当我们在Gitlab上做出某些特定操作时，可以触发钩子，去进行一些我们事先设定好的脚本，以达到某些特定功能（例如–前端项目自动发布）。</p>
<p>  实际上可以把它理解为回调，或者委托，或者事件通知，归根揭底它就是一个消息通知机制。当gitlab触发某个事件时，它会向你的所配置的http服务发送Post请求。</p>
<blockquote>
<p>注意：</p>
</blockquote>
<ul>
<li>URL处填写的是【H5活动管理平台】部署的服务器IP;</li>
<li>IP后面跟的merge是该平台提供的一个接口，用于触发钩子后，gitlab服务器向这个接口发送Post请求；</li>
<li>Secret Token处填写的是一个token，主要用于merge接口请求做安全校验，可以随便设置。<br>具体配置如下图：</li>
</ul>
<p align="center">
![markdown](http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B205.png)
</p>

<p>  我们项目是设置的merge钩子，下面只贴一下Merge request events请求传递的数据信息：</p>
<pre><code>Request header:

X-Gitlab-Event: Merge Request Hook
Request body:

{
  "object_kind": "merge_request",
  "user": {
    "name": "Administrator",
    "username": "root",
    "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon"
  },
  "object_attributes": {
    "id": 99,
    "target_branch": "master",
    "source_branch": "ms-viewport",
    "source_project_id": 14,
    "author_id": 51,
    "assignee_id": 6,
    "title": "MS-Viewport",
    "created_at": "2013-12-03T17:23:34Z",
    "updated_at": "2013-12-03T17:23:34Z",
    "st_commits": null,
    "st_diffs": null,
    "milestone_id": null,
    "state": "opened",
    "merge_status": "unchecked",
    "target_project_id": 14,
    "iid": 1,
    "description": "",
    "source":{
      "name":"Awesome Project",
      "description":"Aut reprehenderit ut est.",
      "web_url":"http://example.com/awesome_space/awesome_project",
      "avatar_url":null,
      "git_ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "git_http_url":"http://example.com/awesome_space/awesome_project.git",
      "namespace":"Awesome Space",
      "visibility_level":20,
      "path_with_namespace":"awesome_space/awesome_project",
      "default_branch":"master",
      "homepage":"http://example.com/awesome_space/awesome_project",
      "url":"http://example.com/awesome_space/awesome_project.git",
      "ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "http_url":"http://example.com/awesome_space/awesome_project.git"
    },
    "target": {
      "name":"Awesome Project",
      "description":"Aut reprehenderit ut est.",
      "web_url":"http://example.com/awesome_space/awesome_project",
      "avatar_url":null,
      "git_ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "git_http_url":"http://example.com/awesome_space/awesome_project.git",
      "namespace":"Awesome Space",
      "visibility_level":20,
      "path_with_namespace":"awesome_space/awesome_project",
      "default_branch":"master",
      "homepage":"http://example.com/awesome_space/awesome_project",
      "url":"http://example.com/awesome_space/awesome_project.git",
      "ssh_url":"git@example.com:awesome_space/awesome_project.git",
      "http_url":"http://example.com/awesome_space/awesome_project.git"
    },
    "last_commit": {
      "id": "da1560886d4f094c3e6c9ef40349f7d38b5d27d7",
      "message": "fixed readme",
      "timestamp": "2012-01-03T23:36:29+02:00",
      "url": "http://example.com/awesome_space/awesome_project/commits/da1560886d4f094c3e6c9ef40349f7d38b5d27d7",
      "author": {
        "name": "GitLab dev user",
        "email": "gitlabdev@dv6700.(none)"
      }
    },
    "work_in_progress": false,
    "url": "http://example.com/diaspora/merge_requests/1",
    "action": "open",
    "assignee": {
      "name": "User1",
      "username": "user1",
      "avatar_url": "http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\u0026d=identicon"
    }
  }
}</code></pre><h2 id="3-H5-活动管理平台"><a href="#3-H5-活动管理平台" class="headerlink" title="3. H5 活动管理平台"></a>3. H5 活动管理平台</h2><p>  当开发者merge代码到GitLab服务器，会触发merge事件，GitLab会发送一个POST请求连带数据（数据格式）给webhooks指定的URL，该平台接收到URL请求后，就涉及如下关键技术点：</p>
<h3 id="1-根据post请求头信息和和body数据，我们能得到如下信息："><a href="#1-根据post请求头信息和和body数据，我们能得到如下信息：" class="headerlink" title="1. 根据post请求头信息和和body数据，我们能得到如下信息："></a>1. 根据post请求头信息和和body数据，我们能得到如下信息：</h3><blockquote>
<ul>
<li>merge的目标分支：req.body.object_attributes.target_branch；</li>
</ul>
</blockquote>
<ul>
<li>安全校验token：req.headers[‘x-gitlab-token’]；</li>
<li>gitlab工程仓库地址：req.body.project.git_ssh_url</li>
<li>触发的钩子行为类型：req.body.object_attributes.action</li>
</ul>
<pre><code>// gitlab触发merge请求
router.post('/merge', function (req, res, next) {
    let git_ssh_url = req.body.project.git_ssh_url;
    let name = req.body.project.name;
    // 上线merge分支master
    if (req.headers['x-gitlab-token'] == 'mergeRequest' && req.body.object_attributes.target_branch == 'master' && req.body.object_attributes.action == 'merge') {
        if (config[name] && config[name].git_ssh_url == git_ssh_url) {
            mergeTaskQueue.addTask(function () {
                getCode.init(git_ssh_url, name, 'master').then(function (data) {
                    console.log(data);
                    mergeTaskQueue.run();
                }).catch(function (error) {
                    console.log(error);
                    mergeTaskQueue.run();
                })
            }.bind(null, git_ssh_url, name));
        }
        res.end('receive request');
        // 测试merge分支dev
    } else if (req.headers['x-gitlab-token'] == 'mergeRequest' && req.body.object_attributes.target_branch == config[name].testEnv.targetBranch && req.body.object_attributes.action == 'merge') {
        if (config[name] && config[name].git_ssh_url == git_ssh_url) {
            mergeTaskQueue.addTask(function () {
                getCode.init(git_ssh_url, name, req.body.object_attributes.target_branch).then(function (data) {
                    console.log(data);
                    mergeTaskQueue.run();
                }).catch(function (error) {
                    console.log(error);
                    mergeTaskQueue.run();
                })
            }.bind(null, git_ssh_url, name));
        }
        res.end('receive request');
    } else {
        return res.end('receive request');
    }
})</code></pre><h3 id="2-执行脚本"><a href="#2-执行脚本" class="headerlink" title="2. 执行脚本"></a>2. 执行脚本</h3><p>  脚本这块没有使用shell脚本，而是使用了node版本的shell.js库，这个库可以让我们控制执行逻辑，更友好的处理错误信息，帮助平台有更友好的信息展示。</p>
<p>拉取最新代码进行构建出目标文件，大致逻辑如下图：</p>
<p align="center">

</p><p><a href="http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B206.png" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="http://q7hgnfyvz.bkt.clouddn.com/node%E9%83%A8%E7%BD%B206.png" class="lazyload"></a></p>
<p></p>

<p>目标代码</p>
<pre><code>function init(git_ssh_url, projectName, targetBranch) {
    deferred = Q.defer();
    if (!git_ssh_url || !projectName) {
        return deferred.reject('项目地址或者项目名称为空');
    }
    repository = git_ssh_url;
    repositoryName = projectName;
    clonePath = path.join(__dirname, '../projects/' + projectName);

    shell.exec('exit 0');
    if (shell.test('-e', clonePath)) {
        shell.cd(clonePath);
        let currentBranch = shell.exec('git symbolic-ref --short -q HEAD', {async: false, silent: true}).stdout;
        if(currentBranch != targetBranch) {
            let outInfo = shell.exec('git branch', {async: false, silent: true}).stdout;
            let gitcmd = outInfo.indexOf(targetBranch) >= 0 ? ('git checkout ' + targetBranch) : ('git checkout -b ' + targetBranch + ' origin/' + targetBranch);
            shell.exec('git pull && ' + gitcmd, {async: false, silent: true});
        }
        shell.exec('git pull', {async: false, silent: true}, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('git pull error');
            }
            console.log(stdout);
            console.log('git pull run success');
            return buildTest(projectName, targetBranch);
        })
    } else {
        if (!fs.existsSync(projects_path)) {
            fs.mkdirSync(projects_path);
        }
        shell.cd(projects_path);
        shell.exec('git clone ' + repository, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('git clone error');
            }
            console.log('git clone success');
            shell.cd(clonePath);
            let outInfo = shell.exec('git branch', {async: false, silent: true}).stdout;
            let gitcmd = outInfo.indexOf(targetBranch) >= 0 ? ('git checkout ' + targetBranch) : ('git checkout -b ' + targetBranch + ' origin/' + targetBranch);
            shell.exec(gitcmd, {async: false, silent: true});
            return buildTest(projectName, targetBranch);
        })
    }
    return deferred.promise;
}</code></pre><pre><code>
// 构建项目
function buildTest(projectName, targetBranch) {
    shell.cd(clonePath);
    shell.exec('npm config set registry https://registry.npm.taobao.org && npm install', {async: true, silent: true}, function (code, stdout, stderr) {
        if (code != 0) {
            console.log(stderr);
            return deferred.reject('npm install error');
        }
        console.log('npm install success');
        shell.rm('-rf', path.join(clonePath, 'dist'));
        let testCommand = config[repositoryName].commands.test || 'npm run test'; //构建测试文件命令行
        shell.exec(testCommand, {async: true, silent: true}, function (code, stdout, stderr) {
            if (code != 0) {
                console.log(stderr);
                return deferred.reject('npm run test fail');
            }
            console.log('npm run test success');
            copyPage(repositoryName, 'test'); // copy到测试目录
            if(targetBranch != 'master') {
                shell.exec('exit 0');
                deferred.resolve('build success and finish');
                return; // 提测时只构建测试文件
            }
            // 构建最终上线文件
            shell.rm('-rf', path.join(clonePath, 'dist'));
            let buildCommand = config[repositoryName].commands.build || 'npm run build'; //构建预上线文件命令行
            shell.exec(buildCommand, {async: true, silent: true}, function (code, stdout, stderr) {
                if (code != 0) {
                    console.log(stderr);
                    return deferred.reject('npm run build fail');
                }
                console.log('npm run build success');
                copyPage(repositoryName, 'online'); //copy到上线正式目录

                // 每次合并master构建后，都切换到测试分支，便于平台读取config.json信息（测试分支是最新的）
                shell.exec('git checkout ' + config[projectName].testEnv.targetBranch, {async: false, silent: false}); 
                shell.exec('exit 0');
                deferred.resolve('build success and finish');
            })
        })
    })
}</code></pre><h3 id="3-动态扩展项目"><a href="#3-动态扩展项目" class="headerlink" title="3. 动态扩展项目"></a>3. 动态扩展项目</h3><p>  通过修改项目配置文件，接入不同的项目，配置信息有每个项目要上传的CDN路径、构建命令、项目目录展示信息文件路径（config.json），如下图：</p>
<pre><code>// 接入该平台的项目列表
module.exports = {
    'h5-activity-cms': {
        git_ssh_url: 'git@example.com:awesome_space/awesome_project.git',
        desc: '前端名狮项目',
        tabContent: '前端名狮', //页面中tab展示文字
        onlineParam: { //上传cdn的参数，根据自己项目设置
            html: {
                domain: '',
                path: ''
            },
            js: {
                domain: '',
                path: ''
            }
        },
        commands: { //构建脚本命令行
            test: 'npm run test',
            build: 'npm run build'
        },

        configFile: 'config.json', // 活动页面列表信息
    }
}</code></pre><h3 id="4-队列处理"><a href="#4-队列处理" class="headerlink" title="4. 队列处理"></a>4. 队列处理</h3><p>  构建目标文件的过程中，很多生成文件、压缩、copy的异步操作，不同的merge请求，有可能操作的是同一个文件，所以需要对merge请求做队列处理。</p>
<pre><code>class TaskQueue {
    constructor() {
        this.list = [];
        this.isRunning = false;
    }
    addTask(task) {
        this.list.push(task);
        if(this.isRunning) {
            return;
        }
        this.start();
    }
    shift() {
        return this.list.length > 0 ? this.list.shift() : null;
    }
    run() {
        let task = this.shift();
        if(!task) {
            this.isRunning = false;
            return;
        }
        task();
    }
    start() {
        this.isRunning = true;
        this.run();
    }
}
module.exports = TaskQueue;</code></pre><h3 id="5-CDN-发布"><a href="#5-CDN-发布" class="headerlink" title="5. CDN 发布"></a>5. CDN 发布</h3><p>  这个需要后端同学提供一个服务接口，用于推送文件到CDN上或者服务器上。我们这边是借助于一个服务端接口，我们通过node上传到他们的服务器，接口方会定时推送文件到CDN，具体每个人的情况处理吧哈。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><blockquote>
<ul>
<li>该平台使用node实现了一个微型的、类似jenkins功能的部署管理平台，具有如下突出的优点：</li>
</ul>
</blockquote>
<ul>
<li>该平台打通了本地开发环境和测试环境部署，实现了测试部署自动化，节省了人工上传粘贴代码的时间，大大地提高了工作效率；</li>
<li>基于项目工程划分的类别，便于开发者高效率的查找页面；</li>
<li>支持动态扩展，可以通过添加配置文件，接入其他gitlab项目；</li>
<li>可以根据需要定制化平台操作页面，比使用jenkins更灵活，更轻便；</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub 精选前端项目</title>
    <url>/2020/04/29/resourseTip/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="GitHub-精选前端项目"><a href="#GitHub-精选前端项目" class="headerlink" title="GitHub 精选前端项目"></a>GitHub 精选前端项目</h2><p align="center">最新更新</p>

<p>codepen 一个在线编辑前端项目的网站，其中有一些前端大神的作品，也有很多令人惊艳的前端效果，可以浏览和下载使用。</p>
<p><a href="./1.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./1.png" class="lazyload"></a></p>
<p>codrops 一系列具有相当具有创意且有趣的前端效果的集合，是非常棒的学习资料，可以欣赏和下载使用。并且有些项目，也托管到了github仓库中</p>
<p><a href="./2.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./2.png" class="lazyload"></a><br>docschina 印记中文网收集了由社区翻译的比较流行的前端相关框架、工具的中文版文档。为学习一些新的框架扫平了语言障碍。</p>
<p><a href="./3.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./3.png" class="lazyload"></a></p>
<p>toby 超级赞的收集与协作管理书签的chrome插件，前端开发应该都会用chrome。全球超过10W+的用户。</p>
<p><a href="./4.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./4.png" class="lazyload"></a></p>
<p>microjs 可以让你选择微型的js类库的网站，该网站里的库都是压缩后不大于5KB的，非常实用，该网站的资源都托管到了github。</p>
<p><a href="./5.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./5.png" class="lazyload"></a></p>
<p>plainjs 该仓库都是用原生js写的插件和组件，非常实用，该网站的资源都托管到了github。</p>
<p><a href="./6.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="./6.png" class="lazyload"></a></p>
<h5 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h5><ul>
<li><p>综合/资源</p>
</li>
<li><p>面试相关</p>
</li>
<li><p>样式/UI/css</p>
</li>
<li><p>构建工具/预编译</p>
</li>
<li><p>测试/工具</p>
</li>
<li><p>canvas/数据可视化</p>
</li>
<li><p>动画插件框架、库和组件</p>
</li>
<li><p>移动端</p>
</li>
<li><p>Node.js相关</p>
</li>
<li><p>模板引擎</p>
</li>
<li><p>WEB编辑器</p>
</li>
<li><p>React相关</p>
</li>
<li><p>编程软实力</p>
</li>
<li><p>浏览器兼容方案</p>
</li>
</ul>
<h5 id="综合-资源"><a href="#综合-资源" class="headerlink" title="综合/资源"></a>综合/资源</h5><ul>
<li>frontend-dev-bookmarks 一个巨大的前端开发资源清单  star: 24705</li>
<li>Awsome-Front-End-learning-resource github最全的前端资源汇总仓库  star: 4158</li>
<li>mobile-web-favorites 移动端H5开发经验、资源、以及踩坑汇总  star: 1307</li>
<li>Front-end-tutorial 最全的资源教程-前端涉及的所有知识体系  star: 3667</li>
<li>awesome-javascript 一系列很棒的javascript库、插件、资源  star: 15222</li>
<li>front-end-collect 作者分享自己长期关注的前端开发相关的优秀网站、博客、以及活跃开发者  star: 3877</li>
<li>javascript airbnb出品写js最佳的姿势，已成众多公司js代码风格的标准  star: 75330</li>
<li>Mars 腾讯移动web前端知识库  star: 7278</li>
<li>awesome-wechat-weapp 小程序开发资源汇总，应有尽有  star: 17357</li>
<li>gold-miner 掘金翻译计划，可能是世界最大最好的英译中技术社区，最懂读者和译者的翻译平台  star: 15949 view</li>
<li>Blog 前端大牛的博文，优质文章  star: 7146</li>
<li>Best-App 收集&推荐优秀的 Apps/硬件/技巧/周边等（与前端无关）  star: 11578</li>
</ul>
<h5 id="面试相关"><a href="#面试相关" class="headerlink" title="面试相关"></a>面试相关</h5><ul>
<li>FE-interview 收集的前端面试题和答案  star: 3722</li>
<li>resources 知名互联网企业内推，需要换工作的小伙伴擦亮眼睛了  star: 1644</li>
<li>CS-Interview-Knowledge-Map 一份前端面试资源，作者很用心，还配有专门的网页  star: 10690 view</li>
<li>node-interview 如何进入饿了么前端团队，node面试题集合  star: 7274 view</li>
</ul>
<h5 id="样式-UI-css"><a href="#样式-UI-css" class="headerlink" title="样式/UI/css"></a>样式/UI/css</h5><ul>
<li>materialize materialize 是material design一套轻量级的纯CSS框架。material design 是Goole提出的一套UI设计方案，并应Goole用于所有产品中  star: 33784 view</li>
<li>Semantic-UI 让你使用任何html标签 来表现ui控件，这是一款语义化设计的前端框架，为攻城师而制作的可复用的开源前端框架  star: 42654</li>
<li>uikit 一个轻量级的、模块化前端框架，它被用于快速开发强大的web界面。也是一款优秀的响应式html5框架  star: 13018</li>
<li>primer github站点所使用的一套css框架  star: 7567</li>
<li>weui 为微信web服务量身设计的一套ui框架  star: 19880</li>
<li>pure 一组很小的，响应式的css组件，你可以在网页的项目上到处使用  star: 18978</li>
<li>normalize.css 一个可定制的css文件，使浏览器呈现的所有元素，更一致和符合现代标准。支持IE8+  star: 32195</li>
<li>iCSS 一系列css有趣的话题，有开发中常用css代码gists  star: 3807</li>
<li>css-doodle 一个用css绘制图形的web组件。非常酷！请看demo作品  star: 1201 view</li>
</ul>
<h5 id="构建工具-预编译"><a href="#构建工具-预编译" class="headerlink" title="构建工具/预编译"></a>构建工具/预编译</h5><ul>
<li>parcel 一个零配置的新一代前端构建工具，识别各种常用类型文件，最优加载模块，代码拆包等，非常值得尝试的一款打包工具 recommand star: 26158</li>
<li>webpack 一个模块打包工具，你可以使用webpack管理你的模块依赖，并编绎输出模块们所需的静态文件 recommand star: 43589</li>
<li>gulp 基于node.js流构建系统，只有原生几个api，和庞大的插件生态，使用非常简单  star: 30196</li>
<li>yo 基于node的一个强健的项目脚手架工具，可以非常方便的构建一个初始项目，有各种类型的项目的脚手架  star: 2598 view</li>
<li>TypeScript 有类型的js预编译语言，非常强大的预编译与代码报错提示，赋予了JS构建大型项目的可能 recommand star: 38380 view</li>
<li>babel 是一款为了写下一代js的编译器，无需等待浏览器支持就可以使用各种ES6，ES7新的语法 recommand star: 29302</li>
<li>stylus 富有表现力的，健壮的css预编译语言, 除了代码简洁，可读性强外，函数功能非常强大，可与js混合使用，实现动态css编程 recommand star: 9404</li>
<li>less.js 轻量级的，动态CSS预编语言，具有CSS所有特性，并提供了动态编程方式编写CSS代码。也是各大UI框架所选用的样式语言，比如bootstrap,ant design等  star: 15698</li>
<li>node-sass 动态CSS预编语言, 并有拥有强大sass compass的生态圈，可以直接引入并使用，sass是由ruby编写的，node-sass是node重构版本，方便npm直接使用  star: 5445</li>
<li>postcss 用js插件来对css样式文件，进行转换、预编译等操作，并且实现了模块化，支持非常多插架 recommand star: 19215</li>
</ul>
<h5 id="测试-工具"><a href="#测试-工具" class="headerlink" title="测试/工具"></a>测试/工具</h5><ul>
<li>mocha 一个简单、灵活有趣的 javascript 测试框架，用于 nodejs 和浏览器上的 js 应用测试  star: 16125</li>
<li>casperjs 一个基于 phantomjs 的开源导航脚本和测试工具  star: 7242</li>
<li>karma 自动化完成单元测试，允许你在多个浏览器里执行js代码。让你的 tdd 变得简单，快速，有趣  star: 10128</li>
<li>jasmine 是一个简易的 js 单元测试框架， 用来测试 javascript 代码  star: 13800</li>
<li>chai 一个针对 nodejs 和浏览器的 tdd (测试驱动开发)/ bdd(行为驱动开发)的断言框架，可与任何 javascript 测试框架集成 recommand star: 5664</li>
<li>csscss css代码冗余分析工具，用于分析css存在的冗余  star: 2938</li>
<li>async 一个工具模块，提供了直接而强大的 javascript 异步功能。虽然是为 nodejs 设计的，但是它也可以直接在浏览器中使用  star: 24543</li>
<li>HTMLHint html 静态代码分析工具，可以集成到代码编辑器或编译系统中  star: 1955</li>
<li>eslint js 静态代码分析工具，可以帮你检测 js 语法错误和潜在的问题，可以集成到代码编辑器或编译系统中 recommand star: 12222</li>
<li>stylelint 分析和优化你的css样式表的工具，支持多种类型的css文件 recommand star: 5318</li>
<li>stylint 由于 stylus 官方团队并没有实现 .styl 文件检查工具，第三方实现了sytlus文件的代码风格检查工具  star: 296</li>
<li>headroom.js 是强大的基准测试库，几乎适用于所有js平台。支持high-resolution定时器，并返回重要的统计结果  star: 9905</li>
<li>Vorlonjs 远程调试移动端页面的工具，有和PC页面调试一致的体验。比如native app内嵌h5页面、手机h5页面等。国内也一个相同功能的软件moblie debug。star: 2666 view</li>
</ul>
<h5 id="canvas-数据可视化"><a href="#canvas-数据可视化" class="headerlink" title="canvas/数据可视化"></a>canvas/数据可视化</h5><ul>
<li>d3 一个基于数据操作文档的js数据可视化框架，最流行的数据可视化库之一  star: 78354</li>
<li>incubator-echarts 基于canvas的纯js图表库，提供直观，生动，可交互，可个性化定制的数据可视化图表  star: 29730</li>
<li>Chart.js 使用canvas标签的简易html5图表  star: 39063</li>
<li>c3 一个基于 d3.js 的可重用 javascript 图表库，几乎零学习曲线  star: 7921</li>
<li>g2 是一套基于可视化编码的图形语法，以数据驱动，具有高度的易用性和扩展性，可定制的颗粒度极细，相比项目echart大而全且易用的图表库，这个库会让你有不一样的体验，且官方提供了g2-react的react封装包  star: 5838</li>
<li>sketch.js 跨平台javascript创意编码框架，gzip压缩后仅有2kb  star: 3211</li>
<li>zrender 一个轻量级的canvas类库，mvc封装，数据驱动，提供类dom事件模型，让canvas绘图大有不同  star: 3098</li>
<li>highcharts 基于svg的javascript图表框架  star: 7900</li>
<li>g6 是一个由纯 JavaScript 编写的关系图基础技术框架。开发者能基于 G6 进行关系图的分析视图和编辑视图进行快速的二次开发  star: 2795</li>
</ul>
<h5 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h5><ul>
<li>animate.css 一个跨浏览器的css动画库，实现了多种css3动画效果，简单易用易上手  star: 53850</li>
<li>anime 极小的js动画引擎，支持 css3、svg 的动画效果，能编写出各种复杂动画效果，gzip后6K左右  star: 23042</li>
<li>move.js 极小的js库,支持css3的动画效果,非常简单优雅  star: 4370<br>TweenJS 是一个简单但强大的js动画库，createjs 套件的一部分  star: 2760</li>
<li>bounce.js 一个用于制作漂亮的css3关键帧动画的js库，使用其特有的方式生成的动画效果  star: 5650</li>
<li>tween.js 一款可生成平滑动画效果的js动画库，允许你以平滑的方式修改元素的属性值，它可以通过设置生成各种类似css3的动画效果  star: 5764</li>
<li>parallax 轻量级的的视差引擎，能对智能设备的方向作出反应  star: 13271</li>
<li>velocity 是一款和jQuery的 $.animate() 有相同API的动画引擎，很适合移动端的动画开发，还打包了颜色动画，转换，循环，easing效果，类动画、滚动等功能  star: 15056</li>
</ul>
<h5 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h5><ul>
<li>front-end-plugins 前端常用插件汇总  star: 755</li>
<li>awesome-browser-extensions-for-github 收集关于github上优秀的浏览器插件，非常实用  star: 1292</li>
<li>video.js 开源的html5和flash视频播放器，支持自定义进度条、按钮以及工具栏的底色  star: 22351</li>
<li>fullPage.js pc端的全屏滚动插件  star: 24488</li>
<li>onepage-scroll 可以轻松建立一个动感的响应式的滚动效果页面，比较适用于单页面的专题站。支持现代浏览器和IE8以上版本  star: 9347</li>
<li>superslides 致力于解决网站大部分特效展示问题，网站上常用的焦点图/幻灯片，tab标签切换，图片滚动，无缝滚动等  star: 1478</li>
<li>github-hovercard github 鼠标悬停显示用户，仓库等摘要信息  star: 1164</li>
</ul>
<h5 id="框架、库和组件"><a href="#框架、库和组件" class="headerlink" title="框架、库和组件"></a>框架、库和组件</h5><ul>
<li>ice 阿里飞冰，从此再也不担心管理系统的开发。(个人觉得简单项目还是可以，复杂的做不了)  star: 7339 view</li>
<li>polymer 以一切皆组件、最少化代码量、最少框架限制为设计理念的web组件构建框架  star: 20117</li>
<li>impress.js 创建令人兴奋的演示。使用css3的转换和过渡，这个库允许你创建令人印象深刻的演示文稿  star: 33881</li>
<li>ScrollMagic 一款非常赞的滚动交互的js插件，可用于官网与宣传广告场景  star: 10037 view</li>
<li>reveal.js 基于css3的3D幻灯片工具，能够制作绚丽的演示文稿并生成html格式，将它发布到web上  star: 42092</li>
<li>nodePPT 使用nodejs写的网络幻灯片，可能是迄今为止最好的网页版ppt  star: 5068</li>
<li>three.js 是js编写的webgl第三方库，提供了非常多的3D显示功能  star: 44417</li>
<li>TimelineJS 轻松制作时间轴  star: 8577</li>
<li>highlight.js js语法高亮，既可以运行在浏览器端也可以运行在服务端  star: 12783</li>
<li>commander.js nodejs命令行工具，可用于制作那种node命令行终端应用  star: 12342</li>
<li>togetherjs 由Mozilla打造的一款可以给网站添加实时协作功能的js库  star: 6174</li>
<li>HTML 轻量级的简化与dom操作的js库  star: 1438</li>
<li>wechat.js 微信相关的 js 操作：分享、网络、菜单  star: 917</li>
<li>JavaScript-Load-Image 一个js加载和转换图像文件的库  star: 3048</li>
<li>progress.js 一个js的库，帮助开发人员为网页上的每个对象创建和管理进度条效果  star: 2323</li>
<li>foundation 号称世界上最先进的响应式前端框架，也是一款移动端优先的框架  star: 27575</li>
<li>Sugar 扩展了现有的js对象的方法，让你可以用更少的代码做更多的事情  star: 3938</li>
<li>todomvc 帮你挑选一款mv框架，它使用不同的最流行的mv框架实现了一个相同的todo应用  star: 24270</li>
<li>Pikaday 是一个js日期选择器，特点是轻量级、无依赖和模块化的css  star: 6238</li>
<li>webuploader 一个简单的以html5为主，flash为辅的现代文件上传组件。支持大文件分片并发上传，极大的提高了文件上传效率  star: 6115</li>
<li>headroom.js 是一个轻量级、纯js组件，用来隐藏或展现页面上的元素，为你的页面留下更多展示内容的空间  star: 9905</li>
<li>ua-device 史上最全面的userAgent解析库，百度FEX出品  star: 829</li>
<li>share.js 一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣等  star: 2240</li>
</ul>
<h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><ul>
<li>fastclick 触摸UI上的消除点击延迟js库  star: 16750</li>
<li>mui 最接近原生APP体验的高性能框架  star: 4033</li>
<li>SUI-Mobile 由阿里巴巴国际UED前端出品的移动端UI库，轻量精美  star: 5740</li>
<li>amazeui 移动优先的跨屏前端框架。面向html5开发，使用css3做动画和交互  star: 12196</li>
<li>ionic 先进的html5移动端开发框架，帮助开发者使用HTML5, css和js做出不可思议的hybrid app  star: 35177</li>
<li>zepto.fullpage 专注于移动端的全屏滚动插件  star: 1993</li>
<li>lib-flexible 淘宝出品的移动端可伸缩布局方案  star: 8184</li>
<li>swipe 加速移动触摸滑块与硬件之间的转换  star: 6724</li>
<li>hammer.js 一个支持多点触摸的手势库  star: 18889</li>
<li>zepto 一款面向移动端设备、api与jquery兼容的基础库  star: 13987</li>
<li>Swiper 纯js打造的滑动特效插件，面向手机、平板电脑等移动终端。能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果  star: 17392</li>
</ul>
<h5 id="Node-js相关"><a href="#Node-js相关" class="headerlink" title="Node.js相关"></a>Node.js相关</h5><ul>
<li>awesome-nodejs 关于node包和资源的收集  star: 25729</li>
<li>node-lessons nodejs包教不包会  star: 13468</li>
<li>node123 node.js中文资料导航  star: 2936</li>
<li>meteor 快速构建web应用的全栈框架，拥有非常常强大的生态圈，但是国内不是很流行  star: 40213</li>
<li>Ghost nodejs开发最新博客系统, 简单简洁, 响应式设计, 支持完全自定义, 免费, 专注博客  star: 27230</li>
<li>NodeBB 基于node编写的现代化社区论坛  star: 9118</li>
<li>hexo 一款快捷，简单，强大的博客框架  star: 23362</li>
<li>nodeclub 使用nodejs和mongodb开发的社区系统  star: 7699</li>
<li>N-chat 使用express和socket搭建的多人聊天室  star: 1001</li>
<li>electron 使用js,css,html构建跨平台的桌面应用  star: 63960</li>
<li>hackathon-starter 一个非常棒的noder初始项目，拥有完整系统架构与用户系统（第三方登录）  star: 24457</li>
<li>nest 完全使用typescript编写的服务端框架，相比传统nodejs项目，可维护性、健壮性、可重构性大大加强。号称node版的spring boot  star: 8147 view</li>
</ul>
<h5 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h5><ul>
<li>pug 基于nodejs的强壮的、优雅的功能强大的模版引擎，相当简洁  star: 17150</li>
<li>handlebars.js 一个js语义模板库，能让你轻松高效的编写语义化模板  star: 13673</li>
<li>artTemplate 性能卓越的js模板引擎  star: 7287</li>
<li>ejs tj大神写的嵌入javascript的模板引擎  star: 3985</li>
</ul>
<h5 id="WEB编辑器"><a href="#WEB编辑器" class="headerlink" title="WEB编辑器"></a>WEB编辑器</h5><ul>
<li>monaco-editor 微软开发的vs code编辑器的核心编辑组件，可以在浏览器中使用使用的代码编辑器，并支持各种语言高亮，功能相当齐全，制作代码编辑器首选  star: 10899 view</li>
<li>CodeMirror 一个轻量级的代码编辑器，核心代码相当的少，同样支持非常多的编程语言的编辑。star: 15450 view</li>
<li>editor 下一代的高度定制化的浏览器网页内容编辑器，是基于react开发  star: 6990 view</li>
<li>tinymce 支持图片在线处理，插件多，文档良好且齐全，功能强，编辑能力优秀，界面好看，推荐使用 recommand star: 5642 view</li>
<li>ckeditor-dev 界面极其优秀的一款，功能强大，编辑能力极强，基本和word差不多  star: 4162 view</li>
<li>wangEditor 轻量简洁，最重要的是开源且中文文档齐全。设计的UI漂亮  star: 5567 view</li>
<li>simditor 团队协作工具Tower使用的富文本编辑器，样式好看，插件不多，基本满足需求，维护较好  star: 3972 view</li>
<li>ueditor 中文文档，插件多，基本满足各种需求，类似贴吧中的回复界面。缺点：不再维护，文档极少，使用并不普遍，图片只能上传到本地服务器，如果需要上传到其他服务器需要改动源码，较为难办，加载速度慢  star: 3847 view</li>
<li>kindeditor 界面类似百度，效果很像，文档齐全但用例较少，使用还算方便。缺点：总感觉样子不是很好看，没有现代那种风格，还是老式的传统图标  star: 1287 view</li>
<li>dillinger 一个完整的基于node与angular的可以直接部署md项目，可以学习整个项目架构  star: 6067 view</li>
<li>simplemde-markdown-editor 极简版的markdown编辑器，非常轻量级，可以用于简单的md编辑场景  star: 5515 view</li>
<li>tui.editor 一款功能非常强大的markdown编辑器，有点想”有道云笔记”的md编辑器。非常方便添加自定义功能。recommand star: 7068 view</li>
</ul>
<h5 id="React相关"><a href="#React相关" class="headerlink" title="React相关"></a>React相关</h5><ul>
<li>react-developer-roadmap react的学习路线图2018版  star: 8779</li>
<li>react-in-patterns react开发设计模式  star: 9903</li>
<li>react-bits react最佳实践，有你想知道  star: 9323</li>
<li>awesome-react react资源大全，react该有的都有了  star: 27383</li>
<li>create-react-app facebook官方提供react开发命令工具，解决初学者的各种烦恼  star: 54549</li>
<li>next.js react服务端渲染框架  star: 28519 view</li>
<li>ant-design 管理系统UI组件库，各类组件一应俱全，优秀的文档，良好的api，值得拥有 recommand star: 32790 view</li>
<li>ant-design-mobile react移动组件库，兼容react-native recommand star: 5788 view</li>
<li>ant-design-pro 阿里团队官方实现的应用antd的，管理系统项目模版，开箱即用 recommand star: 11731 view</li>
<li>gatsby 静态页面生成器，非常强大，自定能力强，模版极多  star: 25050</li>
<li>preact react的瘦身版，兼容官方react所有api,压缩后只有3kb  star: 19912</li>
<li>recharts d3图表库的react版  star: 9706 view</li>
<li>Sortable react的拖拽排序组件  star: 14180 view</li>
<li>react-loadable react组件懒加载组件  star: 9932</li>
<li>react-dnd react拖拽组件，满足各种拖拽需求  star: 9218 view</li>
<li>react-grid-layout 可拖拽的伸缩的布局组件，admin dashboard必备精选，很高大上 recommand star: 6950 view</li>
<li>docz 基于react开发的写文档的神器,号称 写文档从未如此简单 recommand star: 9670 view</li>
<li>react-spring 写react动画的好帮手，不废话看样例  star: 7074 view</li>
<li>react-360 react VR 开发框架  star: 6364 view</li>
<li>taro 一套遵循 React 语法规范的 多端开发 解决方案, 有一套代码多端编译，适用小程序与原生app  star: 7296 view</li>
<li>ink 用react开发命令行交互工具，很酷  star: 6252</li>
<li>ag-grid 非常强大的table组件，完全满足以数据为主的数据展示表格  star: 4231</li>
</ul>
<h5 id="编程软实力"><a href="#编程软实力" class="headerlink" title="编程软实力"></a>编程软实力</h5><ul>
<li>fks 前端技能汇总，包含前端知识架构，后端知识，运维知识，书籍推荐等  star: 13015</li>
<li>javascript-algorithms 包含了多种基于js的算法与数据结构,每种算法都有自己的README说明与YouTube视频  star: 35654 view</li>
<li>CS-Notes 计算机相关的各种记录，涉及到编程的方方面面  star: 33697</li>
<li>math-as-code 学术论文可能会吓着自学游戏和图形的程序猿,通过对比数学符号和JavaScript代码来帮助开发者更容易了解数学符号  star: 6306 view</li>
<li>free-programming-books-zh_CN 免费的计算机编程类中文书籍,不得不说，现在这个时代太好了。star: 37842</li>
</ul>
<h5 id="浏览器兼容方案"><a href="#浏览器兼容方案" class="headerlink" title="浏览器兼容方案"></a>浏览器兼容方案</h5><ul>
<li>es6-shim 提供兼容性垫片，使ES6能兼容于传统的js引擎  star: 2646</li>
<li>Modernizr 用来检测浏览器功能支持情况的js库,可以检测18项css3功能以及40多项关于h5的功能  star: 22910</li>
<li>html5shiv 主要解决html5提出的新的元素不被ie6-9识别  star: 9085</li>
</ul>
</body></html>]]></content>
      <categories>
        <category>前端项目</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>前端开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title>2018吧</title>
    <url>/2019/01/17/sum2019/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="2018吧"><a href="#2018吧" class="headerlink" title="2018吧"></a>2018吧</h1><p>  时间让我明白，生活对每个人都不曾温柔过。它的不温柔总是推陈出新，无从选择更无从逃避。2018已经悄悄走完。更值得我去总结这特殊且及其重要的一年。因为我刚好踏出大学校门踏入社会的一周年。我也正好选择在这一天圆满完结自己的总结—<font color="red">2019.01.17</font>。</p>
<p>  2018年是忙碌而充实的一年，工作、生活、学习，交替而至，更替而走，人不是那些人了，情也已不是那份情。刚毕业的熊孩子，我深知：学习是为了更美好的生活，工作的重点不在于钱，而是在于能力、经验的积累，有了牢固的地基，才能搭建高楼大厦。</p>
<h2 id="工作："><a href="#工作：" class="headerlink" title="工作："></a>工作：</h2><ul>
<li>1月~4月：入职参与软件开发的工作，接触软件开发从需求、原型、编码、测试、部署上线等整体流程；学习系统开发中的总体设计以及详细设计的系统设计概论，所以这4个月时间是以软件开发为中心，实现了说酒App的功能需求；因此巩固和掌握了很多开发技术，积累了一定的工作经验。</li>
<li>5月：这是一个承上启下的一个月，一方面是说酒App的正式上线，二是公司拓展卫星大数据的业务板块成立贵阳欧比特公司，并且做足了充分准备在数博会上正式亮相宣布进入市场。这也意味着我们将会进入一个崭新的领域，掌握新的东西。除此之外总结了说酒App开发中的问题并实施对应解决方案，再则是涉足新领域部门和个人的发展方向。</li>
<li>6月：一方面解决之前开发留下的bug，总结了一些技术解决方案， 二是卫大数据的需要，自学了一些py和图像识别的处理、了解卫星遥感和GIS，翻阅了很多文献和文章以及开发中的多种多样的库或包；完全是自学，目标和过程都是模糊的，收获还是有的。</li>
<li>7月：出差广州参加了一次正规的图像处理培训ENVI和卫星基础知识，也为公司做了一次遥感及图像处理的培训。随着公司数据生产部的成立，我也参与其中一起解决问题和开展工作，由于公司业务的迅猛推进，需要一起和遥感同事对接测绘院相关工作。</li>
<li>8月~9月：为了加快卫星大数据发展和业务稳步进行，出差到广州欧比特总部进行轮岗学习，为期1个月，深入了解了很多高光谱数据的处理、应用方式，学知识的过程中融洽了珠海同事的关系，搜集了我们想要搜集的知识，也是大开眼界。</li>
<li>10月:花了半个月时间做了专家评审系统，以及完善之前的前端解决方案，珠海学习的GIS开发等。</li>
<li>11月：和后端新同事配合完成了公司内部项目—卫星查询平台,GIS开发得到了应用，解决了一些难以解决的技术难题，卫星轨迹和实时拍摄区域计算等。后期参与了一些技术方案的编写和招聘工作。</li>
<li>12月：这个月的精力大部分都放在了经开区考核系统，由于前端人员配置欠缺也加紧了招聘工作，同时也去了解了一些人工智能领域的知识，最后开发团结一致，在一个月内完成了客户的一期需求。另外对人工智能有了一定的了解，也成功参与了一次人工智能的面试。</li>
</ul>
<h2 id="生活："><a href="#生活：" class="headerlink" title="生活："></a>生活：</h2><p>​      2018对我是不平凡的一年，毕业之际有很多期望和打算，信心满满。一些不成熟的决定，自己跳进了坑。终于在无助和委屈中度过了艰难时刻。感谢自己也感谢爱情以及帮助过我的人。3年兄弟一般的大学爱情经受住了一次重大的打击，没有被扼杀掉同时收获了付出代价的人生经历。反而这一切都让我内心变得强大，不会去计较更多的是改变；结合到日常工作反而充实；遇到挫折想办法解决，而不是逃。收获颇多。</p>
<h2 id="学习："><a href="#学习：" class="headerlink" title="学习："></a>学习：</h2><p>​      很庆幸，不管发生了什么我保持住了自己最后的一丝学习心态，总结了自己失败的原因；沉淀了自己，不能凭着自己的年少轻狂去做事，应该成熟、应该周全、更应该满足和长远。</p>
<p>  在公司提供的平台下我学会了更好的交际方式、如何在工作中学习、如何协同完成项目、如何在团队中共同成长等等。所以在工作中或工作之余我补充了自己未知领域的知识:例如前端方面较为全面的知识体系、App开发的移动端知识、一部分服务器端的后端知识、遥感与前后端结合的GIS知识、算法框架与软件开发结合的人工智能知识等。另外收集和购买了2T的视频资料，整理和购买了部分开发相关纸质书籍或文档，更新了10篇自己的博客，收藏了几十个优秀的学习网站，每天会逛一逛。另外尝试了PS相关的图片处理等，我深知自己各方面知识还不够深入，例如前端流行框架的测试框架根本没用过,对原生开发没人才更没有去寻找应用机会。这些只是学习和充实自己的开始。</p>
<h1 id="2019哇："><a href="#2019哇：" class="headerlink" title="2019哇："></a>2019哇：</h1><p>  回过头来翻看这一年的点点滴往事再次历历涌上心头，生活的步伐不曾停止，在新的一年谁也不知道会发生什么，但须知这一年想要的是什么。不管是学习，工作，还是生活，都应该在平时养成总结的习惯，至少不会在路口六神无主，有始有终，学习如此，做人亦如此，做个有耐心的人，不急不燥。</p>
<h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><p>   猪年，属于我的猪年，本命年</p>
<h3 id="学习：-1"><a href="#学习：-1" class="headerlink" title="学习："></a>学习：</h3><p>​      T型、X型去发展自己，学习管理者思想，习惯去分解每一个动作。</p>
<h3 id="生活：-1"><a href="#生活：-1" class="headerlink" title="生活："></a>生活：</h3><p>​      能够继续这样的状态和态度，2018生活很平淡，2019要多花时间和父母聊家常、自己的方方面面。计划带女朋友去旅游一次，为生活买一台相机，记录生活的点点滴滴。多去打几场球锻炼身体，工作之余多和同事朋友聚聚会，聊聊生活、多转转了解市场和发展…获得更多工作、生活、成长道路上的建议和意见。</p>
<p>  我会一直在路上，我也愿意相信我可以在工作，生活和学习上找到一个平衡点，希望生活越来越好，我要去听更多的声音，看更多的风景。</p>
<h3 id="工作：-1"><a href="#工作：-1" class="headerlink" title="工作："></a>工作：</h3><p>  说实话我的团队目标很简单，我就是希望让大家开发的更开心，更轻松一些。让每个人都不会加班，就是我的目标。我不是很想花很多时间去做一些收益很低，但是可以拿去讲的东西。我只希望我做的事情能让大家真心感到有用。如何让部署更快一些，让每次的上线影响范围最小，让错误回滚更及时，如何减少开发一个页面的成本，让数据更安全，更快的发现线上问题…开发项目我们能够得心应手、游刃有余，离开百度我们还是一位名副其实的工程师。能把学到的教授他人，能把赚到的分享给他人…</p>
<p>  我们不需要熟练工，我们需要在某领域拥有超过常人的积累认知，和拥有整套完整思维模式和优秀认知事物能力的人…他很诚恳地告诉我，你还年轻，真的应该好好地静下心来，深入地研究一些东西，自己写一些东西，而不是这也用过，那也知道，但是多半都是局限于仅仅见过，会用，却从来没有认真思考过其代码背后蕴含的思想，更少有人研究过源码，进而体会大师们在某些问题的解决上秉承的思想和思维的风格。个人感觉，这也算是国内大部分程序员最让人悲哀的地方了，当然这也与外界浮躁氛围的蔓延不无关系。不了解这一行的人总觉得程序员都是代码民工，如果自己也认为自己是敲代码的机器的话，那真的是错误的。相反，我强烈地认为，程序员应该是最有活力和最有思想的一个群体，只要你不肯让自己浮于表面，更重要的是，必须勤于思考。</p>
<h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>  每年都会做一些不一样的事情。很多事情，想做就做了。内心总是会有那么一些信仰和坚持。你不需要时时刻刻都伟大，你必须在自己的位置体现出足够的伟大，慢慢的去思考，不断成长的强烈的思绪，便同泉水一样不断涌现出来。是的，学习，不断地学习，才能走一步是一步。而年轻人，就是应当去学习，你也应该像科比一样看看凌晨四点的洛杉矶，德鲁大叔说过你想要得分就应该主动去投篮。我深信这是千真万确的，因为每一次得分都离不开背后上百万次的投篮。</p>
<p>  依旧的，总结仍然是我习惯的 PWD 模式（编程、写作、设计）。听着这首美国大学毕业歌<sound of silence>写完了自己的总结，就像歌曲表达的一样，寂静的夜晚没人敢发出声音，我觉得应该敢于打破寂静发出自己最真诚的声音。最后；无论我幸福或是不幸，我也都希望呢，每个人都幸福生活、快乐成长。</sound></p>
</body></html>]]></content>
      <categories>
        <category>向后想</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>年吧</tag>
      </tags>
  </entry>
  <entry>
    <title>2019吧</title>
    <url>/2020/01/01/summary2019/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><hr>
<h1 id="2019-吧"><a href="#2019-吧" class="headerlink" title="2019 吧"></a>2019 吧</h1><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>  2020 年的第一天了，我想我应该写点什么。嗯~不得不感慨时间过得太快，记忆中的 2019 仿佛一片空白，但是细细回味之后，这一年许多人许多事都还历历在目。<br>  2019 年过去，2020 的到来。踏过本命年，仿佛意识到自己确实已经不小了。但一想到自己的现状，只能说：<font color="red"> 革命尚未成功，我辈仍需继续努力！！！ </font></p>
<blockquote>
<p>灵魂拷问: 时间回到 2019 年年初，你当时立下的 flag，现在又完成了多少呢？</p>
</blockquote>
<p>  2019 年是我毕业后的第二年，已经不能厚脸皮说自己还是个学生、是个职场新人，到目前为止已经过去 2 年 2 个月了(2017.10)，如果要是算年头的话，2020 年已经是我成为程序员的第 4 个年头了，看着这些数据真的是细思极恐，哇不忍直视！</p>
<p>  然写想着是写 2019 年度总结，写着写着，我更想借此对自己从参加工作到现在的生活和工作进行梳理。整理过去的人和事，确定今后的方向（立 flag），轻装上阵。</p>
<p>  那闲话不多说，既然是总结，那就先对这过去的<font color="red"> 3 </font>个年头做一个简单的回溯吧</p>
<h2 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h2><blockquote>
<p>2017 有很多遗憾，难过和委屈，那年匆匆</p>
</blockquote>
<p>网易云热评上看到过这样一句话：</p>
<blockquote>
<p>跨越数千公里，只身来到一个陌生的城市，火车站凌晨昏黄的灯光照在脸上时大概是一个人最孤独的时候吧。</p>
</blockquote>
<p>虽然我没决定去远方，但我依然孤独</p>
<p>然而生活中谁又何尝不是负重前行，忍受孤独呢？我们都是平凡的普通人，所以你只管努力，其他的交给时间就好。</p>
<h3 id="年度关键字"><a href="#年度关键字" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>毕设</li>
<li>毕业</li>
<li>转换</li>
<li>萌新</li>
<li>起点</li>
<li>努力</li>
</ul>
<h3 id="入职"><a href="#入职" class="headerlink" title="入职"></a>入职</h3><p>  毕业之年，用完了快乐，没有毕业旅行；2017.4 2017.11 2017.12，接连参加了省考、国考、研究生考；那时候也算是初生牛犊不怕虎，眼高手低，真是一波未平一波又起，于是我习惯了失望；我还是决定当个普通人吧，于是 12 月底拿到一家软件公司 offer，这才有种如梦初醒的感觉（我是谁？我在哪？我怎么跑这来了？？？），晃悠晃悠到了现在的公司</p>
<h3 id="工位"><a href="#工位" class="headerlink" title="工位"></a>工位</h3><p>  入职后来到一个新的环境，新的事物新的朋友，公司安排了宿舍，现在想想真的很温馨，大家对我都很关照。记得那时上手的技术大部分都没用过。学习之路-路漫漫其修远兮，吾将上下而求索</p>
<h3 id="成长"><a href="#成长" class="headerlink" title="成长"></a>成长</h3><p>  12 月就是一个接收新事物的一个月，学习到新的技术，认识到新的朋友。那段时间也许是出于自身的焦虑，也或许是作为实习生应该要有一个努力上进的态度，每晚都在办公室学习，造轮子很久。</p>
<p>  时间过得很快，每天过着充实的学习生活，当时就像一片海绵，疯狂的吸取自己缺少的那些水分。记得当时已经开始帮同事解决禅道上的一些小 bug（当时还用的禅道 haha），直到年底，12 月底，项目组接到了一个新的项目，我也有幸成为了项目的一员。当时我也不会想到这个项目一作就做到了现在，而且做到现在最初的那些开发人员也就只剩下了我和*，那些熟悉的面孔逐渐变成陌生又慢慢变为熟悉。</p>
<h2 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h2><p>  一辈子有很多夏天，但没有任何一个夏天像今夏</p>
<p>  2018 年见了太多的别离，2018 年也是毕业那年，记得那年夏天，记得那些人，四年美好的回忆</p>
<h3 id="年度关键字-1"><a href="#年度关键字-1" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>项目</li>
<li>自律</li>
<li>运动</li>
<li>博客</li>
<li>涨薪</li>
<li>全栈</li>
<li>出差</li>
<li>累</li>
</ul>
<p>  2018 算是自己人生中历史性的一年吧，这一年正式摇身一变成为一名社会银，这一年正真开始了自己的程序生涯。</p>
<h3 id="博客、分享"><a href="#博客、分享" class="headerlink" title="博客、分享"></a>博客、分享</h3><p>  回到公司，我开始迷上了一个东西：博客</p>
<p>  最初对于博客一直有敬畏之心，觉着能发表博客的都是大佬，都是业界大牛，这种想法直到我参加了一次小组的技术分享后发生了转变。</p>
<p>  以前在学校虽然也组织一些活动，参加一些活动，但是那些都是在自己熟悉的同学老师面前，做一些自己擅长的事情。而作为一个职场新人技术小白组内的技术分享对我来说就像是关公面前耍大刀（这个比拟比较夸大哈哈哈~），记得当时分享的是 quartz，当时做了很多准备，结合自己的使用经验，以及实践社区大佬的使用经验总结成书面的技术分享文章，后来分享效果还挺不错，起码把自己懂得，理解到的，用过的都分享了出来并做了总结。</p>
<p>  通过那次的分享，逐渐明白完全掌握一个新知识新技术，并不是你会用就可以了，而是你能够将这个知识讲出来，教会别人，并能为其答疑解惑。</p>
<p>  自此，博客成了我记录学习，总结知识的方法和途径。</p>
<h3 id="程序生涯开启"><a href="#程序生涯开启" class="headerlink" title="程序生涯开启"></a>程序生涯开启</h3><h2 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h2><blockquote>
<p>做正确的事儿，正确的做事儿</p>
</blockquote>
<p>  2019 年是生活重心都在工作的一年，这一年也是五味杂陈的一年，这一年暴露出了自身的很多潜藏问题和缺点。</p>
<h3 id="年度关键字-2"><a href="#年度关键字-2" class="headerlink" title="年度关键字"></a>年度关键字</h3><ul>
<li>升职加薪</li>
<li>整合</li>
<li>规范</li>
<li>责任</li>
<li>管理</li>
<li>优秀员工</li>
</ul>
<p>这一年的项目情况就不多作介绍，主要对自己项目工作以外的一些事件进行总结</p>
<h3 id="五味杂陈"><a href="#五味杂陈" class="headerlink" title="五味杂陈"></a>五味杂陈</h3><p>  说到五味杂陈，离不开情之一字，哈哈哈，这种事其实不应该出现在程序员的年度总结中，但是键盘敲到这里，思绪划过 2019 一整年，真的是五味杂陈，感情痛点也算是这一年不可缺的的一部分，经历了很多的争吵，产生过很多的矛盾。一个在计划未来，一个却在谋划离开。这一年刚刚开始就已经结束了；愿这些烦恼都随 2019 一起远去。</p>
<h3 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h3><p>  经过 1 年的打怪升级，管人理事，优化组织结构和人员配置，技术中开发套路和基本架构都已经熟悉，在对目前项目中在使用的延时任务进行了整合，并以微服务形式提供接口支持。防止出现重复造轮子的现象，提高开发效率。</p>
<h3 id="返璞归真"><a href="#返璞归真" class="headerlink" title="返璞归真"></a>返璞归真</h3><p>   刚入行的时候就有朋友给提点过：做这一行，到了最后拼的都是内功，话俗理不俗！</p>
<h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p>  博客输出已经成为一种习惯，虽然我的更新频率十分不规律，而且技术深度也一般，但是相信自己只要坚持输出，终会有所收获。</p>
<p>  写博客已经不单单是记录和总结了，就像能用嘴巴说出来的东西，不一定能用文字清楚的表达。而写博客更多的是分享和文档撰写、信息归纳汇总的锻炼，就像锻炼一个人的文字表达能力一样。</p>
<h3 id="架构升级"><a href="#架构升级" class="headerlink" title="架构升级"></a>架构升级</h3><p>  哈哈，我已经开始全栈旅行啦<del>~</del></p>
<h3 id="有趣的人"><a href="#有趣的人" class="headerlink" title="有趣的人"></a><strong>有趣的人</strong></h3><p>  学贵得师，亦贵得友。</p>
<h3 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a><strong>旅行</strong></h3><p>  因为今年各种不开心，就没有心思怎么去玩儿。不过还是在节假日时间和家人在一起，节假日和家人在一块儿，我觉得一家人开心，比自己一个人怎么开心都幸福，我没成家之前应该多陪陪他们。</p>
<h3 id="暴露出的问题"><a href="#暴露出的问题" class="headerlink" title="暴露出的问题"></a>暴露出的问题</h3><p>  前面都是在总结一些自己的阶段性成果和大事件，但对于过程中暴露出额自身问题却只字未提，这里想把他们单拎出来，警示自己：</p>
<ul>
<li>未能时常关心到家人 —–> 做到一周最少一次联系（特别好奇是不是男生都和家里联系少？还是就我是这样？总之这样是不对的）</li>
<li>完善管理 —–> 为自己制定计划表，和奖惩措施，调整心态，微笑面对生活</li>
<li>读书太少 —–> 提升内涵，多读书，读好书</li>
<li>运动太少 —–> 加强锻炼，控制体重（增重增重……惨不忍睹，体重太少~我要当个男人）</li>
<li>熬夜太多 —–> 早睡早起，狗命重要！！！</li>
<li>技术宅 —–> 重拾兴趣爱好，充实业务生活，生活需要伴侣</li>
<li>多的 flag 着实不想立了，不想来年打脸，但以上这些已经列出来的问题点，是必须优先解决的。</li>
</ul>
<h2 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h2><blockquote>
<p>逆水行舟不进则退，长期处于舒适区只会习惯于停留在原地</p>
</blockquote>
<p>  最后的这一节，就像小时候写新学期打算一样，要求新的一年做出展望和规划，也是必不可少的。</p>
<p>  新的一年也算是一个新的起点，希望自己初心不改，保持现在的节奏稳扎稳打，努力提升自己，变得更优秀。</p>
<h3 id="健康"><a href="#健康" class="headerlink" title="健康"></a><strong>健康</strong></h3><p>  在这一点上今年做的特别不好，虽然体检没有任何问题，但感觉身体长期处于亚健康，成年累月的“排骨瘦肉精”，时常后背肌肉酸痛，骨头没事。身体健康是做任何事情的前提，应该作为一个重要的投资项。</p>
<p>  今年更多是生活的磨砺，内心让我更加强大，要感谢生活终于到的每个人，对于一个善于迭代的人，很多时候别人的一句话就能极大改变自己，我也庆幸这么多年我也影响了好多人，结果混的都比我好多了，不断作为鞭策自己的工具。年终收获了不错的工作绩效，是对我一年的肯定，怀着忐忑的心情，来年交付更大成绩（组织和个人）</p>
<p>  很多人都说计划赶不上变化，这句话没问题，并且计划本身也是动态调整的，其实我们依然要有计划的原因是强迫自己不断去思考目标修炼排期规划能力，过程保证了尽可能的做的是正确的事。</p>
<h3 id="她"><a href="#她" class="headerlink" title="她"></a><strong>她</strong></h3><p>   等我变优秀了，我想我会重新遇到一个满眼都是她的女孩子</p>
<div align="center">
2020仍会平凡而伟大<br>  
低头看路，抬头轻唱<br>  
忙碌、踏实、宁静<br>  
不负人、不负事；<br>  
每一天都可以<br>  
安然入睡<br>  
微笑醒来；<br>  
一介草民<br>  
三尺微命<br>  
仍需十分努力;
<br>  
</div>
</body></html>]]></content>
      <categories>
        <category>向后想</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>年吧</tag>
      </tags>
  </entry>
  <entry>
    <title>生活</title>
    <url>/2018/06/23/todayFeel/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). -->

</head><body><h2 id="那天"><a href="#那天" class="headerlink" title="那天"></a>那天</h2><p>  天黑了，没人可以等你回家，你告诉自己离家很近。</p>
<p>​   蹒跚在路上，路灯微暗，周围行人匆忙，路边小贩一旁大声吆喝着，你想过去买些水果，顺带和大叔唠嗑两句，不知自己是想聊天还是想买水果，想着想着，而你已经走过了那小水果摊位，算了，你也没有吃水果的习惯。</p>
<h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>​   今天天气还不错，没有雨，不算热，你居然有点开心起来，假装着将一切抛掷脑后，哼着背不熟的歌曲，回想着明星的模样，他和歌词的描述那样，上进，阳光，积极。一切都是你想要的样子。</p>
<p>​   园区里，一只小黄猫只蹲在垃圾桶上，一直往里看，好像掉了什么东西。它身躯瘦小，好像是饿了很久了。你路过它身旁，目光一直在它身上，但它似乎对你没有多大兴趣。在它眼里，你并不如垃圾桶的东西呢。</p>
<p><a href="https://goss.cfp.cn/creative/vcg/nowarter800/new/VCG211130066346.jpg?x-oss-process=image/format,webp" data-fancybox="group" data-caption="markdown" class="fancybox"><img alt="markdown" title="markdown" data-src="https://goss.cfp.cn/creative/vcg/nowarter800/new/VCG211130066346.jpg?x-oss-process=image/format,webp" class="lazyload"></a></p>
</body></html>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>记事儿不记人</tag>
      </tags>
  </entry>
  <entry>
    <title>实用网站收藏</title>
    <url>/2020/05/27/website-collect/</url>
    <content><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p><strong>搞学习</strong></p>
<ul>
<li>CSDN：<a href="https://www.csdn.net/" target="_blank" rel="noopener">https://www.csdn.net/</a></li>
<li>TED（最优质的演讲）：<a href="https://www.ted.com/" target="_blank" rel="noopener">https://www.ted.com/</a></li>
<li>谷粉学术：<a href="https://gfsoso.99lb.net/scholar.html" target="_blank" rel="noopener">https://gfsoso.99lb.net/scholar.html</a></li>
<li>大学资源网：<a href="http://www.dxzy163.com/" target="_blank" rel="noopener">http://www.dxzy163.com/</a></li>
<li>简答题：<a href="http://www.jiandati.com/" target="_blank" rel="noopener">http://www.jiandati.com/</a></li>
<li>网易公开课：<a href="https://open.163.com/ted/" target="_blank" rel="noopener">https://open.163.com/ted/</a></li>
<li>网易云课堂：<a href="https://study.163.com/" target="_blank" rel="noopener">https://study.163.com/</a></li>
<li>中国大学MOOC：<a href="http://www.icourse163.org" target="_blank" rel="noopener">www.icourse163.org</a></li>
<li>网易云课堂：study.163.com</li>
<li>哔哩哔哩弹幕网：<a href="http://www.bilibili.com" target="_blank" rel="noopener">www.bilibili.com</a></li>
<li>我要自学网：<a href="http://www.51zxw.net" target="_blank" rel="noopener">www.51zxw.net</a></li>
<li>知乎：<a href="http://www.zhihu.com" target="_blank" rel="noopener">www.zhihu.com</a></li>
<li>学堂在线：<a href="http://www.xuetangx.com" target="_blank" rel="noopener">www.xuetangx.com</a></li>
<li>爱课程：<a href="http://www.icourses.cn" target="_blank" rel="noopener">www.icourses.cn</a></li>
<li>猫咪论文：<a href="https://lunwen.im/" target="_blank" rel="noopener">https://lunwen.im/</a></li>
<li>iData（论文搜索）：<a href="http://www.cn-ki.net" target="_blank" rel="noopener">www.cn-ki.net</a></li>
<li>文泉考试：<a href="https://www.wqkaoshi.com" target="_blank" rel="noopener">https://www.wqkaoshi.com</a></li>
</ul>
<h2 id="找书籍"><a href="#找书籍" class="headerlink" title="找书籍"></a><strong>找书籍</strong></h2><ul>
<li>书栈网（极力推荐）：<a href="https://www.bookstack.cn/" target="_blank" rel="noopener">https://www.bookstack.cn/</a></li>
<li>码农之家（计算机电子书下载）：<a href="http://www.xz577.com" target="_blank" rel="noopener">www.xz577.com</a></li>
<li>鸠摩搜书：<a href="http://www.jiumodiary.com" target="_blank" rel="noopener">www.jiumodiary.com</a></li>
<li>云海电子图书馆：<a href="http://www.pdfbook.cn" target="_blank" rel="noopener">www.pdfbook.cn</a></li>
<li>周读（书籍搜索）：ireadweek.com</li>
<li>知轩藏书：<a href="http://www.zxcs.me/" target="_blank" rel="noopener">http://www.zxcs.me/</a></li>
<li>脚本之家电子书下载：<a href="https://www.jb51.net/books/" target="_blank" rel="noopener">https://www.jb51.net/books/</a></li>
<li>搜书VIP-电子书搜索：<a href="http://www.soshuvip.com/all.html" target="_blank" rel="noopener">http://www.soshuvip.com/all.html</a></li>
<li>书格（在线古籍图书馆）：<a href="https://new.shuge.org/caj" target="_blank" rel="noopener">https://new.shuge.org/caj</a></li>
<li>云阅读：<a href="http://cajviewer.cnki.net/cajcloud/" target="_blank" rel="noopener">http://cajviewer.cnki.net/cajcloud/</a></li>
<li>必看网（人生必看的书籍）：<a href="https://www.biikan.com/" target="_blank" rel="noopener">https://www.biikan.com/</a></li>
</ul>
<h2 id="冷知识-黑科技"><a href="#冷知识-黑科技" class="headerlink" title="冷知识 / 黑科技"></a><strong>冷知识 / 黑科技</strong></h2><ul>
<li>上班摸鱼必备（假装电脑系统升级）：<a href="http://fakeupdate.net/PIECES" target="_blank" rel="noopener">http://fakeupdate.net/PIECES</a> </li>
<li>拼图（30 个 CSS 碎片进行拼图，呈现 30 种濒临灭绝的动物）：<a href="http://www.species-in-pieces.com/" target="_blank" rel="noopener">http://www.species-in-pieces.com/</a></li>
<li>图片立体像素画：<a href="https://pissang.github.io/voxelize-image/" target="_blank" rel="noopener">https://pissang.github.io/voxelize-image/</a></li>
<li>福利单词（一个不太正经的背单词网站）：<a href="http://dict.ftqq.com" target="_blank" rel="noopener">http://dict.ftqq.com</a></li>
<li>查无此人（刷新网站，展现一张AI 生成的人脸照片）：<a href="https://thispersondoesnotexist.com/" target="_blank" rel="noopener">https://thispersondoesnotexist.com/</a></li>
<li>在线制作地图图例：<a href="https://mapchart.net/" target="_blank" rel="noopener">https://mapchart.net/</a></li>
<li>创意光线绘画：<a href="http://weavesilk.com/" target="_blank" rel="noopener">http://weavesilk.com/</a></li>
<li>星系观察：<a href="https://stellarium-web.org/" target="_blank" rel="noopener">https://stellarium-web.org/</a></li>
<li>煎蛋：<a href="http://jandan.net/" target="_blank" rel="noopener">http://jandan.net/</a></li>
<li>渣男-说话的艺术：<a href="https://lovelive.tools/" target="_blank" rel="noopener">https://lovelive.tools/</a></li>
<li>全历史：<a href="https://www.allhistory.com/" target="_blank" rel="noopener">https://www.allhistory.com/</a></li>
<li>iData：<a href="https://www.cn-ki.net/" target="_blank" rel="noopener">https://www.cn-ki.net/</a></li>
<li>术语在线：<a href="http://www.termonline.cn/" target="_blank" rel="noopener">http://www.termonline.cn/</a></li>
</ul>
<h2 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a><strong>写代码</strong></h2><ul>
<li>GitHub：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></li>
<li>码云：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></li>
<li>源码之家：<a href="https://www.mycodes.net/" target="_blank" rel="noopener">https://www.mycodes.net/</a></li>
<li>JSON to Dart：<a href="https://javiercbk.github.io/json_to_dart/" target="_blank" rel="noopener">https://javiercbk.github.io/json_to_dart/</a></li>
<li>Json在线解析验证：<a href="https://www.json.cn/" target="_blank" rel="noopener">https://www.json.cn/</a></li>
<li>在线接口测试（Getman）：<a href="https://getman.cn/" target="_blank" rel="noopener">https://getman.cn/</a></li>
</ul>
<h2 id="资源搜索"><a href="#资源搜索" class="headerlink" title="资源搜索"></a><strong>资源搜索</strong></h2><ul>
<li>DogeDoge搜索引擎：<a href="http://www.dogedoge.com" target="_blank" rel="noopener">www.dogedoge.com</a></li>
<li>秘迹搜索：<a href="https://mijisou.com/" target="_blank" rel="noopener">https://mijisou.com/</a></li>
<li>小白盘：<a href="https://www.xiaobaipan.com/" target="_blank" rel="noopener">https://www.xiaobaipan.com/</a></li>
<li>云盘精灵（资源搜索）：<a href="http://www.yunpanjingling.com" target="_blank" rel="noopener">www.yunpanjingling.com</a></li>
<li>虫部落（资源搜索）：<a href="http://www.chongbuluo.com" target="_blank" rel="noopener">www.chongbuluo.com</a></li>
<li>如风搜（资源搜索）：<a href="http://www.rufengso.net/" target="_blank" rel="noopener">http://www.rufengso.net/</a></li>
<li>爱扒：<a href="https://www.zyboe.com/" target="_blank" rel="noopener">https://www.zyboe.com/</a></li>
</ul>
<h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a><strong>小工具</strong></h2><ul>
<li>奶牛快传（在线传输文件利器）：cowtransfer.com</li>
<li>文叔叔（大文件传输，不限速）：<a href="https://www.wenshushu.cn/" target="_blank" rel="noopener">https://www.wenshushu.cn/</a></li>
<li>云端超级应用空间（PS，PPT，Excel，Ai）：<a href="https://uzer.me/" target="_blank" rel="noopener">https://uzer.me/</a></li>
<li>香当网（年终总结，个人简历，事迹材料，租赁合同，演讲稿）：<a href="https://www.xiangdang.net/" target="_blank" rel="noopener">https://www.xiangdang.net/</a></li>
<li>二维码生成：<a href="https://cli.im/" target="_blank" rel="noopener">https://cli.im/</a></li>
<li>搜狗翻译：fanyi.sogou.com</li>
<li>熵数（图表制作，数据可视化）：<a href="https://dydata.io/appv2/#/pages/index/home" target="_blank" rel="noopener">https://dydata.io/appv2/#/pages/index/home</a></li>
<li>拷贝兔：<a href="https://cp.anyknew.com/" target="_blank" rel="noopener">https://cp.anyknew.com/</a></li>
<li>图片无限变放大：<a href="http://bigjpg.com/zh" target="_blank" rel="noopener">http://bigjpg.com/zh</a></li>
<li>幕布（在线大纲笔记工具）：mubu.com</li>
<li>在线转换器（在线转换器转换任何测量单位）：<a href="https://zh.justcnw.com/" target="_blank" rel="noopener">https://zh.justcnw.com/</a></li>
<li>调查问卷制作：<a href="https://www.wenjuan.com/" target="_blank" rel="noopener">https://www.wenjuan.com/</a></li>
<li>果核剥壳（软件下载）：<a href="https://www.ghpym.com/" target="_blank" rel="noopener">https://www.ghpym.com/</a></li>
<li>软件下载：<a href="https://www.unyoo.com/" target="_blank" rel="noopener">https://www.unyoo.com/</a></li>
<li>MSDN我告诉你（windows10系统镜像下载）：<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a></li>
</ul>
<h2 id="导航页（工具集）"><a href="#导航页（工具集）" class="headerlink" title="导航页（工具集）"></a><strong>导航页（工具集）</strong></h2><ul>
<li>世界各国网址大全：<a href="http://www.world68.com/" target="_blank" rel="noopener">http://www.world68.com/</a></li>
<li>小森林导航：<a href="http://www.xsldh6.com/" target="_blank" rel="noopener">http://www.xsldh6.com/</a></li>
<li>简捷工具：<a href="http://www.shulijp.com/NiceTool.net" target="_blank" rel="noopener">http://www.shulijp.com/NiceTool.net</a> </li>
<li>好工具网：<a href="http://www.nicetool.net/" target="_blank" rel="noopener">http://www.nicetool.net/</a></li>
<li>现实君工具箱（综合型在线工具集成网站）：<a href="http://tool.uixsj.cn/" target="_blank" rel="noopener">http://tool.uixsj.cn/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/" target="_blank" rel="noopener">http://lcoc.top/</a></li>
<li>偷渡鱼：<a href="https://touduyu.com/" target="_blank" rel="noopener">https://touduyu.com/</a></li>
<li>牛导航：<a href="http://www.ziliao6.com/" target="_blank" rel="noopener">http://www.ziliao6.com/</a></li>
<li>小呆导航：<a href="https://www.webjike.com/index.html" target="_blank" rel="noopener">https://www.webjike.com/index.html</a></li>
<li>简法主页：<a href="http://www.jianfast.com/" target="_blank" rel="noopener">http://www.jianfast.com/</a></li>
<li>KIM主页：<a href="https://kim.plopco.com/" target="_blank" rel="noopener">https://kim.plopco.com/</a></li>
<li>聚BT：<a href="https://jubt.net/cn/index.html" target="_blank" rel="noopener">https://jubt.net/cn/index.html</a></li>
<li>精准云工具合集：<a href="https://jingzhunyun.com/" target="_blank" rel="noopener">https://jingzhunyun.com/</a></li>
<li>兔2工具合集：<a href="https://www.tool2.cn/" target="_blank" rel="noopener">https://www.tool2.cn/</a></li>
<li>爱资料工具（在线实用工具集合）：<a href="http://www.toolnb.com" target="_blank" rel="noopener">www.toolnb.com</a></li>
<li>工具导航：<a href="https://hao.logosc.cn/" target="_blank" rel="noopener">https://hao.logosc.cn/</a></li>
</ul>
<h2 id="看视频"><a href="#看视频" class="headerlink" title="看视频"></a><strong>看视频</strong></h2><ul>
<li>阿木影视：<a href="https://www.aosk.online/" target="_blank" rel="noopener">https://www.aosk.online/</a></li>
<li>电影推荐（分类别致）：<a href="http://www.mvcat.comAPP" target="_blank" rel="noopener">http://www.mvcat.comAPP</a></li>
<li>影院：<a href="https://app.movie/" target="_blank" rel="noopener">https://app.movie/</a></li>
<li>去看TV：<a href="https://www.qukantv.net/" target="_blank" rel="noopener">https://www.qukantv.net/</a></li>
<li>动漫视频网：<a href="http://www.zzzfun.com/" target="_blank" rel="noopener">http://www.zzzfun.com/</a></li>
<li>94神马电影网：<a href="http://www.9rmb.com/" target="_blank" rel="noopener">http://www.9rmb.com/</a></li>
<li>NO视频官网：<a href="http://www.novipnoad.com/" target="_blank" rel="noopener">http://www.novipnoad.com/</a></li>
<li>蓝光画质电影：<a href="http://www.languang.co/" target="_blank" rel="noopener">http://www.languang.co/</a></li>
<li>在线看剧：<a href="http://dy.27234.cn/" target="_blank" rel="noopener">http://dy.27234.cn/</a></li>
<li>大数据导航：<a href="http://hao.199it.com/" target="_blank" rel="noopener">http://hao.199it.com/</a></li>
<li>多功能图片网站：<a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">https://www.logosc.cn/so/</a></li>
<li>牛牛TV：<a href="http://www.ziliao6.com/tv/" target="_blank" rel="noopener">http://www.ziliao6.com/tv/</a></li>
<li>VideoFk解析视频：<a href="http://www.videofk.com/" target="_blank" rel="noopener">http://www.videofk.com/</a></li>
<li>蓝调网站：<a href="http://lcoc.top/vip2.3/" target="_blank" rel="noopener">http://lcoc.top/vip2.3/</a></li>
<li>永久资源采集网：<a href="http://www.yongjiuzy1.com/" target="_blank" rel="noopener">http://www.yongjiuzy1.com/</a></li>
</ul>
<h2 id="学设计"><a href="#学设计" class="headerlink" title="学设计"></a><strong>学设计</strong></h2><ul>
<li>码力全开（产品/设计师/独立开发者的资源库）：<a href="https://www.maliquankai.com/designnav/" target="_blank" rel="noopener">https://www.maliquankai.com/designnav/</a></li>
<li>免费音频素材：<a href="https://icons8.cn/music" target="_blank" rel="noopener">https://icons8.cn/music</a></li>
<li>新CG儿（视频素材模板，无水印+免费下载）：<a href="https://www.newcger.com/" target="_blank" rel="noopener">https://www.newcger.com/</a></li>
<li>Iconfont（阿里巴巴矢量图标库）：<a href="https://www.iconfont.cn/" target="_blank" rel="noopener">https://www.iconfont.cn/</a></li>
<li>小图标下载：<a href="https://www.easyicon.net/Flight" target="_blank" rel="noopener">https://www.easyicon.net/Flight</a></li>
<li>Icon：<a href="https://www.flighticon.co/" target="_blank" rel="noopener">https://www.flighticon.co/</a></li>
<li>第一字体转换器：<a href="http://www.diyiziti.com/" target="_blank" rel="noopener">http://www.diyiziti.com/</a></li>
<li>doyoudosh（平面设计）：<a href="http://www.doyoudo.com" target="_blank" rel="noopener">www.doyoudo.com</a></li>
<li>企业宣传视频在线制作：<a href="https://duomu.tv/" target="_blank" rel="noopener">https://duomu.tv/</a></li>
<li>MAKE海报设计官网：<a href="http://maka.im/" target="_blank" rel="noopener">http://maka.im/</a></li>
<li>一键海报神器：<a href="https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&utm_medium=referral" target="_blank" rel="noopener">https://www.logosc.cn/photo/?utm_source=hao.logosc.cn&utm_medium=referral</a></li>
<li>字由（字体设计）：<a href="http://www.hellofont.cn/" target="_blank" rel="noopener">http://www.hellofont.cn/</a></li>
<li>查字体网站：<a href="https://fonts.safe.360.cn/" target="_blank" rel="noopener">https://fonts.safe.360.cn/</a></li>
<li>爱给网（免费素材下载的网站，包括音效、配乐，3D、视频、游戏，平面、教程）：<a href="http://www.aigei.com/" target="_blank" rel="noopener">http://www.aigei.com/</a></li>
<li>在线视频剪辑：<a href="https://bilibili.clipchamp.com/editor" target="_blank" rel="noopener">https://bilibili.clipchamp.com/editor</a></li>
</ul>
<h2 id="搞文档"><a href="#搞文档" class="headerlink" title="搞文档"></a><strong>搞文档</strong></h2><h2 id="找图片"><a href="#找图片" class="headerlink" title="找图片"></a><strong>找图片</strong></h2><ul>
<li>电脑壁纸：<a href="http://lcoc.top/bizhi/" target="_blank" rel="noopener">http://lcoc.top/bizhi/</a></li>
<li><a href="https://unsplash.com/" target="_blank" rel="noopener">https://unsplash.com/</a></li>
<li><a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></li>
<li><a href="https://www.pexels.com/" target="_blank" rel="noopener">https://www.pexels.com/</a></li>
<li><a href="https://visualhunt.com/" target="_blank" rel="noopener">https://visualhunt.com/</a></li>
<li><a href="https://www.ssyer.com/" target="_blank" rel="noopener">https://www.ssyer.com/</a></li>
<li>彼岸图网：<a href="http://pic.netbian.com/" target="_blank" rel="noopener">http://pic.netbian.com/</a></li>
<li>极像素（超高清大图）：<a href="https://www.sigoo.com/" target="_blank" rel="noopener">https://www.sigoo.com/</a></li>
<li>免费版权图片搜索：<a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">https://www.logosc.cn/so/</a></li>
</ul>
</body></html>]]></content>
      <categories>
        <category>收藏</category>
      </categories>
      <tags>
        <tag>实用网站</tag>
      </tags>
  </entry>
</search>
